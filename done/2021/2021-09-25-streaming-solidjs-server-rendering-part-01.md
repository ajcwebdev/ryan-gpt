---
showLink: "https://www.youtube.com/watch?v=0zadjVUV7zM"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "Streaming SolidJS - Server Rendering"
description: ""
publishDate: "2021-09-25"
coverImage: "https://i.ytimg.com/vi/0zadjVUV7zM/sddefault.jpg?v=614e0353"
---

## Episode Description

Ryan Carniato explores SolidJS’s server rendering, detailing its architectural evolution, performance benchmarks, SSR techniques (string rendering, streaming), and the Solid Start framework with demos.

## Episode Summary

Ryan Carniato’s stream dives into SolidJS’s approach to server-side rendering, beginning with his framework’s origins and performance focus. He contrasts client-side rendering against traditional SSR, revealing how Solid’s string-based rendering and removal of reactivity on the server deliver remarkable speed gains. Through detailed benchmarks comparing Solid against React, Preact, Svelte, Marko, and others, he underscores the efficiency of Solid’s SSR, async, SSG, and streaming modes under various network conditions. Carniato demonstrates live examples, showcasing simple SSR setups, static site generation, async rendering, and streaming implementations, each illustrating unique trade-offs. He explains hydration mechanics, minimal JavaScript delivery, and the concept of partial hydration. In the latter half, he introduces Solid Start, highlighting file-based routing, isomorphic actions for data fetching, and project scaffolding. Closing with community and roadmap discussions, the session offers an in-depth guide to building high-performance, isomorphic SolidJS applications.

## Chapters

### 00:00:00 - Introduction: SolidJS SS Rendering Context and Community Updates

In the opening minutes of the stream, Ryan Carniato greets viewers and introduces the primary focus: server-side rendering (SSR) and static site generation (SSG) in SolidJS. He sets the stage by noting that the stream is impromptu and acknowledging existing conversations around multi-page application (MPA) versus single-page application (SPA) architectures in the community. Carniato highlights recent developments in SolidJS’s ecosystem, including frameworks offering MPA modes and Netlify’s new sponsorship, which will aid in project infrastructure and domain protection. He also mentions Party Town, an innovative library for offloading analytics scripts to a Web Worker, and shares his praise for a recent interview with React core team member Sunil, which provides insights into React Server Components and their motivations. This introduction establishes context around both community happenings and technical trends, warming viewers to the detailed SSR content to follow.

The second paragraph builds on Carniato’s opening commentary by elaborating on the importance of staying up-to-date with evolving front-end approaches. He juxtaposes the ongoing MPA versus SPA debate, explaining that many frameworks are adapting to support both paradigms. Carniato’s mention of Netlify’s sponsorship underscores the growth and professional backing for SolidJS. He briefly highlights Party Town’s proxy-based approach to prevent analytics scripts from blocking the main thread, emphasizing performance mindfulness. Lastly, his recommendation of Sunil’s interview reinforces the stream’s theme: understanding the rationale behind server-centric optimizations is key to choosing the right rendering strategy. Together, these points frame the stream as a timely conversation about balancing developer productivity, performance, and architecture in modern front-end development.

### 00:05:00 - Origins of SolidJS and Client-Side Performance Focus

Beginning around five minutes in, Carniato transitions to sharing his screen and delving into SolidJS’s origins and philosophy. He candidly admits that when he first built Solid, server-side rendering was not on his radar. Solid’s genesis came from a desire to create a reactive framework featuring fundamental primitives, inspired by Knockout’s observables, but significantly more performant. He recounts his experience working on private social media applications for education, where server-side rendering was unnecessary, reinforcing his initial lean towards client-centric design. Benchmarks from 2014–2015, which highlighted slow update performance in key-value observable frameworks like Knockout and Ember, motivated him to build something that could outperform them.

The second paragraph expands on Carniato’s insights into Solid’s focus on raw client-side speed. Early Solid demos, including a Hacker News clone and real-world benchmarks, revealed that client-only rendering could outperform server-rendered pages in metrics such as First Contentful Paint. By paralellizing fetch requests and optimizing code splitting, Solid minimized network waterfalls and script loading overhead. Carniato explains that at the time, server-side rendering techniques were rudimentary, delivering full HTML synchronously without preloading scripts or leveraging efficient streaming. This realization sparked his conviction that a reimagined SSR approach, built on top of Solid’s high-performance client runtime, could unlock significant performance gains while preserving developer ergonomics.

### 00:10:00 - Client-Side Rendering vs Traditional SSR: Performance Considerations

At the ten-minute mark, Carniato explores why traditional server-side rendering often trailed behind modern client-side architectures in performance metrics. He demonstrates that with solid engineering, client-only pages can render faster than SSR frameworks like Sapper and Next.js in Lighthouse scores. By sending a minimal HTML “app shell” immediately and deferring data fetching to the client, Solid achieved quicker first paints and interactive experiences. Carniato emphasizes that classical SSR typically waited for every data request to resolve and for the entire HTML to be generated before responding, resulting in longer time-to-first-byte and delayed script preloading. These factors combined to make many SSR pages slower on average networks than well-optimized SPAs. He asserts that while SSR is often perceived as essential for SEO or performance, naive implementations can be slower than their client-side counterparts.

Continuing, the second paragraph places this contrast in the context of network conditions and user experience. Carniato explains that on a fast North American or European connection, shipping only an app shell and letting the browser load JavaScript before rendering often leads to faster perceived performance than traditional SSR’s “render-everything-then-send” model. By preloading scripts and initiating fetches as soon as possible, SPAs can outperform SSR in time to interactive. He notes that once hydration overhead is factored in, simple SSR pages can actually lag behind. However, he also acknowledges that SSR has its place when implemented correctly—particularly when streaming or advanced async techniques can start data requests earlier on the server. This exploration sets up the need for Solid’s bespoke SSR methodology built to overcome those traditional shortcomings.

### 00:15:00 - Implementing SSR: Transition from DOM Emulation to String Rendering

Around fifteen minutes into the stream, Carniato explains his first attempts at enabling SSR in Solid: using the DOM or JSX DOM on the server. Initially, he tried leveraging Solid’s runtime directly against a server-side DOM, hoping to clone templates and run reactive updates as if on the client. However, he found that this approach was surprisingly slow. The overhead of creating DOM nodes, attaching event listeners, and simulating reactivity made server rendering fragile and inefficient. Recognizing these limitations, he pivoted toward a string-based approach, where Solid’s compiled templates produce arrays of static strings with holes for dynamic values. By concatenating these strings into HTML, Solid circumvented the overhead of server-side DOM manipulation.

In the second paragraph, Carniato dives into the mechanics of Solid’s string rendering. He demonstrates a code snippet where JSX compiles into a function that returns an array of string segments and placeholders representing dynamic expressions. On the server, Solid’s SSR engine calls this function with the current state to produce a fully-serialized HTML string. He introduces the concept of a “hydration key” inserted into templates to uniquely identify dynamic spots for later hydration on the client. Carniato also touches on string escaping, noting that Solid originally borrowed Svelte’s escape algorithm—an area that was later optimized for faster HTML generation. This transition from DOM emulation to direct string concatenation laid the foundation for Solid’s high-performance SSR.

### 00:20:00 - Server-Side Reactivity and Isomorphic Builds: Structuring SolidJS for SSR

At the twenty-minute point, Carniato shifts to demonstrating Solid’s codebase in Visual Studio Code, revealing how Solid distinguishes between server and client builds using conditional exports. He shows Solid’s package structure, where “browser” exports provide the full reactive runtime and “node” exports point to a lightweight server runtime that strips out unnecessary reactivity. On the server, Solid removes the cost of signals, effects, and computed values because no subsequent DOM updates occur once the HTML string is generated. This clever use of Node’s conditional export maps ensures that the same import statements work seamlessly on both client and server while automatically swapping out the reactive implementation for a minimal, no-op version.

The second paragraph further elaborates how eliminating server-side reactivity boosts performance. Carniato describes how Solid’s server runtime transforms reactive constructs into simple function calls that compute values once and then terminate, eliminating the need for dependency tracking or scheduling. Functions like `createSignal`, `createEffect`, and `onCleanup` become no-ops or basic getters, ensuring that string concatenation does not suffer from reactive overhead. By unifying server and client code with conditional package exports, Solid ensures that developers can write isomorphic components without special SSR syntax. This architecture forms the backbone of Solid’s SSR, enabling it to deliver near-zero overhead when rendering HTML on the server.

### 00:25:00 - Benchmarking SSR Performance: SolidJS vs Competitors

At around twenty-five minutes, Carniato introduces the Isomorphic UI benchmark, comparing Solid’s server HTML generation speed against other popular frameworks like React, Preact, Svelte, Marko, and Inferno. He navigates to the benchmark website, which includes two representative tests: a search results page inspired by eBay’s layout and a simple color picker application that exercises UI reactivity. In the search results test, Solid initially recorded around 600–700 operations per second, lagging behind Marko’s \~8,000 ops/s and Inferno’s \~2,000. Meanwhile, React and Preact hovered near 900 ops/s. After a community contribution replaced the escape algorithm with a faster implementation, Solid’s performance surged, nearly matching Marko and outperforming Svelte, Preac, and others by a significant margin.

The second paragraph dives deeper into the color picker benchmark, which emphasizes incremental updates and some static HTML. Carniato notes that Inferno’s efficient attribute escaping temporarily vaulted it past Marko until a bug in escaping was discovered. Solid’s optimized escape and string-based rendering pushed it to double the speed of Preac and Svelte, making it roughly ten times faster in some cases. These results underscore that Solid’s architecture—removing server reactivity and concatenating strings rather than manipulating a virtual DOM—yields outstanding SSR performance. Carniato highlights that while such benchmarks simplify real-world complexity, they provide a compelling reason to trust Solid for applications that demand fast server-side HTML generation.

### 00:30:00 - Overview of SSR Strategies: Static Generation, Sync, Async, and Streaming

At the thirty-minute mark, Carniato outlines his approach to demonstrating various Solid SSR strategies through a simple example application. He created four render modes—synchronous SSR with client-side data fetching, asynchronous SSR where all data is fetched on the server, static site generation (SSG), and streaming SSR. He acknowledges that SSR can take many forms depending on use cases, from fully static Jamstack builds to multi-page dynamic sites. Carniato notes that developers often face a choice: pre-render at build time, fetch data at run time in a blocking fashion, or stream content as it becomes available. Each strategy offers trade-offs between time-to-first-byte, user experience, and complexity.

The second paragraph explains how his wrapper around a simple router and three routes—Home, Profile, and Settings—adapts to each SSR technique. In the synchronous SSR mode, the HTML is generated server-side and handed off to the client, which then hydrates and continues data fetching. In async SSR, the server waits for all data to populate before rendering the HTML, resulting in blocking but fully populated pages. For SSG, data fetching happens at build time, meaning pages are shipped fully ready with zero data-fetching overhead at runtime. Finally, streaming SSR interleaves HTML and data as it arrives, allowing the browser to begin loading assets and rendering placeholders while awaiting remaining content. This overview sets the stage for deep dives into each mode.

### 00:35:00 - Simple SSR Demo: Application Structure and Data Fetching Patterns

Between thirty-five and forty minutes, Carniato examines his simple SSR demo in more detail. He describes the router configuration, which employs Solid’s built-in suspense mechanism to handle lazy-loaded route components. Each route—Home, Profile, and Settings—is lazy-loaded to avoid blocking the initial bundle. In the Profile route, he wraps the component in a “Data” wrapper that fetches a user object, then uses that user’s ID to fetch related information, simulating a waterfall where one request depends on another. By structuring data fetching this way, he demonstrates common pitfalls: if both data fetches happen client-side, users see loading placeholders and spinners in succession rather than arriving concurrently.

The second paragraph elaborates on how Suspense boundaries encapsulate loading states. Carniato places an outer Suspense around the route to suspend on the initial user fetch and component bundle load. Within Profile, an inner Suspense further isolates the user detail fetch. This nested setup allows the page to display partial content—namely, once the user’s main profile is fetched, the outer loading spinner is replaced by user details while an inner loading indicator shows until the secondary user info arrives. By carefully orchestrating these Suspense layers, Carniato showcases how Solid enables developers to manage waterfall data dependencies gracefully, even in a synchronous SSR context.

### 00:40:00 - Server-Side Data Fetching with Suspense: Managing Reactivity and Caching

Around forty minutes into the stream, Carniato dives into how Solid handles data fetching on the server when reactivity is stripped out. He explains that although Solid’s server runtime lacks fine-grained reactivity, it still maintains a coarse cache of resource results to avoid refetching duplicate requests. When a Suspense boundary suspends server-side, Solid re-renders everything under that boundary using the most recent cached results. Because string concatenation is extremely fast compared to reactive scheduling, re-rendering an entire component subtree produces minimal overhead. Carniato notes that even if a Suspense boundary suspends multiple times due to nested data dependencies, the cost remains a small percentage compared to naive synchronous SSR.

In the second paragraph, Carniato reasons about the “worst-case” scenario where Solid might re-render a component tree twice on the server due to cascading Suspense boundaries. He calculates that even this double rendering would yield performance still five times better than frameworks that both hydrate on the client and use a virtual DOM on the server. By prioritizing string concatenation over DOM manipulation or virtual DOM diffing, Solid can afford occasional re-renders without significant performance degradation. This design choice simplifies the SSR implementation: developers can use Suspense for data fetching without worrying about invalidating complex reactive graphs on the server.

### 00:45:00 - Live Demonstration: SSR Implementation and Performance Profiling

Between forty-five and fifty minutes, Carniato runs a live SSR example in a browser, showing exactly how the synchronous SSR code operates. He refreshes the page to reveal the server-rendered HTML immediately, then points out how the client console logs show server-side code did not execute—only the client undertook data fetching. By profiling the network and performance timeline, he highlights that the server-rendered payload arrives quickly, followed by client-side JavaScript that hydrates the page and triggers subsequent fetches. Although simulated fetch calls (via timers) blur in the profiler, Carniato points to the timeline markers as evidence of when the first and second data loads complete.

In the second paragraph, Carniato outlines the SSR server code: using `renderToString`, the server invokes Solid’s compiled template function, returns an HTML string containing placeholders for hydration keys, and sends it in the HTTP response. On the client, a small hydration script executes to replay event listeners and reattach reactive contexts. Because data fetching resides in the client’s lifecycle (via `createResource`), each page load logs “loadUser” and “loadInfo” only in the browser console. Carniato notes that even without true network calls, the simulated timers effectively emulate waterfall delays, demonstrating how a synchronous SSR approach still yields a functioning app shell before client hydration.

### 00:50:00 - Static Site Generation Demo: Build-Time Fetching and Instant Loads

Just past fifty minutes, Carniato switches to the static site generation (SSG) demo. He runs the build step, which triggers data fetching on the server at compile time. Viewers observe two 400ms simulated requests executed immediately within the build process, with the resulting data serialized into the generated HTML files. When Carniato starts the static server and refreshes the page, there is no visual flicker between page loads: the browser holds the previous navigation until the new HTML is ready. Because all data is embedded at build time, first paint and first contentful paint metrics drop into the low 20ms range, dwarfing the times seen in SSR or client-side rendering modes.

In the second paragraph, Carniato examines the generated HTML source, showing how Solid automatically injects a `<script>` containing a `window.__HYDRATION__` object with serialized resource data. On initial client hydration, Solid reads from this hydration object to skip fetching the same resources again. The profiler timeline reveals that page hydration JavaScript kicks in quickly once the static HTML arrives, and there are no inbound data fetches on the client. This “ship HTML + embedded data” approach exemplifies typical Jamstack performance, effectively illustrating that when data is known ahead of time, static generation is the fastest possible delivery method for interactive pages.