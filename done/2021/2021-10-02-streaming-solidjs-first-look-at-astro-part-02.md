---
showLink: "https://www.youtube.com/watch?v=UPhx3OxUH0w"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "Streaming SolidJS - First look at Astro"
description: ""
publishDate: "2021-10-02"
coverImage: "https://i.ytimg.com/vi/UPhx3OxUH0w/hqdefault.jpg?v=615732c7"
---

## Episode Description

A deep, live exploration of integrating SolidJS with Astro, covering JavaScript news, Solid updates, server-side rendering, project setup, hydration mechanics, and dynamic data handling in a three-hour hands-on stream.

## Episode Summary

In this extensive three-hour livestream, Ryan Carniato introduces viewers to the emerging landscape of multi-page and single-page applications, citing recent JavaScript discussions and highlighting SolidJS’s rapid growth within the community. He then transitions to an in-depth look at Astro, a modern static site generator, demonstrating how to set up a Solid-integrated Astro project from scratch. Throughout the stream, Ryan navigates configuration nuances, sheds light on Solid’s export conditions, and delves into hydration strategies, showcasing progressive hydration with Solid’s event replay. He also tackles dynamic data fetching in Astro, wrestling with CSS scoping, layout slotting, and troubleshooting Node-fetch integration. The episode concludes by contrasting asynchronous and synchronous server-side rendering, emphasizing best practices for building performant, component-driven web apps, and offering practical Q\&A-driven insights drawn from live audience interaction.

## Chapters

### 01:07:58 - Attempting Dynamic Data Loading in Astro: CSS & Layout Challenges

Turning his attention to dynamic content, Ryan aims to build a small Hacker News–style feed in Astro using Solid’s asynchronous features. He begins by copying prebuilt static HTML and CSS from a previous project to quickly mock up a list layout. Placing the HTML in an `index.astro` file, he notices Astro’s global CSS is not applying as expected due to scoped styling conventions. He experiments with both inline `<style>` tags and importing a global CSS file from the `public` folder. Ryan emphasizes that mixing global styles with scoped component styles requires careful handling—Astro’s default behavior hashes class names to prevent conflicts, so proper configuration or prefixing may be necessary.

Next, he attempts to create a reusable layout component (`components/Layout.astro`) to wrap multiple pages, including a `<slot />` for page-specific content. By trial and error, Ryan finds that Astro requires a `---` frontmatter block even in layout files, and that CSS scoping can inadvertently hide elements if class names conflict. Despite initial styling glitches, he ultimately integrates the header and footer into a layout component, demonstrating how Astro’s file-based routing automatically picks up layout inheritance. Through this process, viewers learn practical tips for slot usage, frontmatter syntax, and debugging scoped CSS leaks within an Astro environment.

### 01:12:10 - Implementing Layouts, Slotting, and CSS Scoping in Astro

With the layout component in place, Ryan revisits the `index.astro` page to wrap its contents with `<Layout>` tags. He shows how to import the layout component and pass page content into the `<slot />`. Ryan also points out that Astro’s default CSS scoping adds unique hashes to component-specific styles; if you import global CSS, you must use the `:global` selector to override scoped classes. By inspecting DevTools, he traces why certain styles—such as headline colors—weren’t applying, discovering that the layout’s `<h1>` was still using its original hashed class name. After adjusting CSS selectors to target the correct scoped classes, the page’s typography and layout render correctly.

Ryan then experiments with component-level CSS by creating a new `components/StoryList.astro` file. He embeds both HTML and CSS inside this component, illustrating that Astro’s scoped CSS only applies to elements inside that component. He contrasts this with importing a global stylesheet from `public/`—useful for site-wide resets and common utilities. Throughout this section, Ryan emphasizes the importance of understanding Astro’s CSS scoping and frontmatter syntax: any changes to `<style>` blocks in `.astro` files must be accompanied by proper selectors (scoped vs. global), and layout inheritance can introduce unintentional style overrides if not carefully managed.

### 01:16:09 - CSS Integration and Public Asset Handling in Astro

Moving deeper into CSS strategies, Ryan clarifies how Astro treats files in `public/` as top-level static assets. For instance, importing `/styles/style.css` from `public/` places it at the root of the deployed site without bundling or hashing. He demonstrates adding an external CSS file that lives in `public/css/site.css`, then referencing it in the page via `<link rel="stylesheet" href="/css/site.css" />`. This ensures that CSS is served as a separate asset, cached, and not processed through Astro’s build pipeline. Ryan contrasts this approach with embedding component-scoped CSS via `<style>` tags directly in `.astro` or `.css` files in `src/`, noting when to choose each method.

He also briefly touches on image and favicon management within the `public/` directory, stressing that any file placed here is copied verbatim at build time. This knowledge helps viewers understand how to organize fonts, icons, and other static resources without interfering with Astro’s bundler optimizations. By the end of this chapter, audience members have a clear blueprint for balancing global styles in `public/` with component-scoped CSS in `src`, ensuring predictable styling and asset linkage in both development and production.

### 01:21:00 - Converting Static HTML to Astro Pages and Dynamic Routes

Ready to integrate dynamic content, Ryan transforms the static Hacker News–style HTML into an Astro page. He creates a `stories.astro` file under `src/pages/` and pastes the HTML markup, taking care to wrap top-level elements correctly since Astro requires a single root element. He experiments with dynamic route parameters by renaming the file to `[page].astro`, using the “slug” convention to capture `page` from the URL path. Ryan writes a `getStaticPaths()` function that tells Astro which page routes to pre-render (e.g., `/1`, `/2`, `/3`), generating static pages for each numbered page. Viewers learn that Astro’s dynamic routing uses bracket syntax akin to Next.js, allowing for flexible page generation.

In the same context, Ryan describes how props are passed into `[page].astro` via the `Astro.props.page` object. By logging `Astro.props`, he confirms that the route parameter is correctly passed, enabling the page logic to fetch or display content conditionally. Although the dynamic routing example uses placeholder HTML, the audience sees firsthand how to transition from a basic static site to one that accepts URL parameters, paves the way for data-driven pages, and leverages Astro’s prerendering capabilities without needing a separate API layer.

### 01:26:22 - Integrating Solid Components, JSX Syntax, and Initial Rendering

Shifting from pure Astro pages to hybrid Astro+Solid, Ryan renames `stories.astro` to `stories.jsx` and sets out to embed Solid components directly. He removes static HTML from the `.jsx` page, replacing it with a Solid-friendly JSX render function—converting tags like `<ul>` and `<li>` into JSX syntax. A common pitfall arises: forgetting to close void elements (`<br />`, `<img />`, etc.) in JSX, generating compilation errors. After fixing those, he wraps the content in a React-like fragment (`<> … </>`) so that results can be returned from the default export function.

With this conversion complete, Ryan launches the dev server and confirms that Solid components are rendered on the server, producing the expected HTML without client-side interactivity. He points out that because the page is a `.jsx` file, Astro delegates rendering to Solid’s server-side renderer. Viewers note that everything is still static—there is no hydration script injected—demonstrating that Solid components can seamlessly produce server-rendered markup inside an Astro page. This segment underscores how straightforward it is to migrate existing JSX or React code into Solid+Astro with minimal changes, essentially treating Solid as a drop-in replacement for React at the server-render layer.

### 01:30:34 - Server-Side Rendering Solid Components and Examining Hydration Scripts

To transition the static page into an interactive one, Ryan reintroduces Solid’s client-side hydration by marking the component as hydratable—setting `Hydratable: true` in the Solid renderer’s plugin configuration. He clears Astro’s cache and rebuilds to remove stale artifacts, then reloads the page. Upon inspection in DevTools, Ryan demonstrates that Solid’s hydration script is now injected: a `<script type="module">` near the bottom loads `solid-js/web` and rehydrates the server-rendered component in the browser. Viewers see how Solid’s hydration attributes (e.g., `data-hk`) map the previously generated HTML to the dynamically attached event listeners and reactive state.

During this investigation, Ryan toggles between SSR and client-only rendering modes by adjusting `renderToString` to `render` in the Solid plugin. When switching to pure client rendering, the server output no longer includes HTML for the component; instead, the browser runs Solid’s runtime to mount and display the component. These comparisons highlight how simple it is to toggle rendering strategies in Solid+Astro: an entirely static page for SSG, a hydrated SSR page for MPA interactivity, or a fully client-side mount for an SPA-like experience. Audience members gain a crisp understanding of how Solid’s hydration scripts orchestrate the “handoff” from server-rendered HTML to a fully reactive client UI.

### 01:37:11 - Implementing Solid’s createResource: Debugging Data Fetching with Node-Fetch

Motivated to fetch live data, Ryan creates a simple Solid data-fetcher function using `createResource`. He writes an `api.js` file exporting a `getStories` function that calls the Hacker News API via `node-fetch` and returns a promise. In the `stories.jsx` component, he imports `createResource` from Solid and calls `createResource(() => getStories(page))`, where `page` comes from `Astro.props`. A Suspense boundary wraps the story list, ensuring that Solid waits for `getStories` before rendering. As Ryan reloads the page, no data appears, indicating that the fetch call is failing silently—he consoles-logs the resource result and sees undefined values.

Ryan realizes that the route parameter name isn’t matching—`Astro.props` only contains `page`, but he referred to `props.stories`. After correcting the prop reference, he still encounters a “fetch.default is not a function” error. Viewers learn that this common Node-fetch integration issue arises because ESM default exports can require extra handling. Ryan notes that Astro does not polyfill `fetch` on the server, so he must import Node-fetch explicitly. Although he juggles import syntax to get `fetch` defined, the code remains perplexingly undefined, illustrating the typical debugging pain points when bridging Solid’s SSR environment with external data-fetch libraries.

### 01:43:11 - Troubleshooting Node-Fetch and Workarounds for Server Data Fetching

Continuing to troubleshoot, Ryan unwraps the `getStories` function inside a try/catch block and logs errors to identify underlying fetch failures. He experiments with different import styles—`import fetch from 'node-fetch'`, `const fetch = require('node-fetch')`, and destructuring `import { default as fetch } from 'node-fetch'`—yet consistently sees `fetch` undefined. He concludes that the Astro dev server’s internal ESM loader may be interfering with Node-fetch’s CJS→ESM conversion. Frustrated but undeterred, Ryan decides to bypass external HTTP calls entirely by mocking the API response: writing a simple `fetchStories` function that returns a promise resolved via `setTimeout`, simulating a network delay before returning a hard-coded JSON array of two story objects.

With the mock data in place, Ryan re-runs the server. Solid’s `createResource` now resolves immediately with the fake data, and the list of stories renders inside the Suspense boundary. Although the data is static, the Suspense placeholder briefly appeared on page load, confirming the flow of asynchronous fetching and server rendering. This workaround demonstrates to viewers that, when integration with external libraries fails, constructing a mock or a simplified data source can keep development moving forward. By the end of this chapter, the audience has gained insight into debugging SSR data-fetch patterns in Solid and Astro—learning when to simulate data and how to isolate the root cause of fetch-time failures.

### 01:49:11 - Switching between Async and Sync SSR in Solid for Astro

Having mocked the data fetching, Ryan explores the distinction between Solid’s asynchronous (`renderToStringAsync`) and synchronous (`renderToString`) server-side rendering methods. He points out that with `renderToStringAsync`, Solid can perform Suspense-driven server rendering—resolving data promises before emitting HTML. In contrast, `renderToString` blocks on data resolution during build time or loads a “loading” fallback in an SSG scenario, then expects client-side JavaScript to fetch data after hydration. Ryan toggles the Solid plugin’s SSR setting: first using `renderToStringAsync`, which yields a fully populated HTML page (no loading spinner), and then switching to `renderToString`, which emits only the static “Loading …” placeholder in the HTML.

Ryan explains that for a dynamic feed—like a Hacker News clone where stories change frequently—`renderToString` plus client-side data fetch can be more appropriate. The server sends minimal HTML immediately (just the “Loading …” wrapper), and Solid then hydrates in the browser to fetch the latest data. Conversely, if the data is relatively static or SSG is run on a schedule, `renderToStringAsync` can embed story data at build time, yielding fully rendered pages without additional client network requests. By walking through both configurations, Ryan equips viewers with a nuanced understanding of SSR modes in Solid+Astro—helping them choose between server-driven or client-driven data strategies.

### 01:55:00 - Demo: Client-Side Data Loading with Suspense and SSG Trade-offs

With the Solid plugin set to `renderToString`, Ryan refreshes the Astro site. The initial HTML shows only the “Loading …” text wrapped in the Suspense boundary, confirming server-side behavior. He then inspects network requests in DevTools, observing that a subsequent HTTP call is made by Solid on the client to retrieve the data (either the mocked JSON or a real API call, if re-enabled). As data arrives, Solid suspends the placeholder and renders the populated story list in-place. This pattern replicates a typical JAMstack experience: build-time pages show a shell that hydrates on the client to fetch live data—thus combining fast initial loads with dynamic content updates.

Throughout this demonstration, Ryan highlights the importance of selecting the right balance: if story content rarely changes, using `renderToStringAsync` at build time ensures that users always get fully rendered pages without extra network requests. If story content updates frequently (e.g., in minutes or seconds), `renderToString` plus client hydration can provide up-to-the-minute data without requiring continuous rebuilds. He also notes that this hybrid approach avoids shipping large hydration scripts for the entire page: only the necessary event handlers and minimal JavaScript run locally, aligning with Astro’s “zero-JS by default” design. By the end of this section, viewers clearly see how to implement dynamic data flows while maintaining optimal performance across various use cases.

### 02:00:39 - Exploring Streaming, SSR Strategies, and Static Site Generator Use Cases

Ryan shifts to a broader discussion about SSR strategies beyond static site generation. He contrasts Astro’s SSG mode with serverless functions and streaming SSR: for instance, using `renderToStream` with Solid on a platform like Cloudflare Workers or Netlify Functions can deliver HTML progressively as data resolves. He explains that streaming SSR allows browsers to begin rendering the page before all data or asynchronous work completes, reducing time to first byte (TTFB). However, not all deployment targets support streaming; if server environments cannot stream, developers might prefer `renderToStringAsync`, which still resolves data before sending, albeit at the cost of slightly delayed initial payload.

Ryan also references other frameworks—Next.js, SvelteKit—that similarly offer a range of SSR modes: full static export, serverless SSR, or streaming SSR. He emphasizes that Solid’s flexibility, combined with Astro’s modular plugins, allows developers to adapt to any hosting environment: whether that means generating an entirely static site for a CDN, deploying SSR endpoints for on-demand rendering, or streaming pages for extremely low latency. This conversation provides viewers with a mental map of SSR workflows, helping them identify the best approach based on data volatility, performance requirements, and hosting constraints.

### 02:06:30 - Comparing Astro and Marco: Progressive Hydration and Optimization

Ryan revisits a Marco demo—his other project—to illustrate how progressive hydration can work even without shipping any JavaScript to the client. He shares that in Marco’s Hacker News example, multiple Suspense islands stream to the browser, rendering placeholders and swapping in content as it becomes available on the server, all without a hydration script running in the client. He notes that this is possible because Marco uses server-initiated partial hydration: instead of bundling a hydration runtime, it leverages streaming SSR to swap content nodes directly in the DOM. By comparing Astro’s hydration model—where individual islands hydrate using client-side scripts—with Marco’s streaming approach, Ryan demonstrates different ways to achieve fine-grained interactivity without universal client JavaScript.

During this evaluation, he underscores that while Astro’s island model works well for static or moderately dynamic sites, the streaming paradigm in Marco can reduce client-side load even further by eliminating runtime hydration altogether. However, he cautions that full streaming SSR may not be necessary—or even beneficial—for all use cases; sometimes partial hydration via islands is the optimal trade-off between interactivity and minimal client payload. By juxtaposing Astro’s “zero-JS by default” approach with Marco’s streaming-first approach, Ryan equips developers with a spectrum of progressive hydration strategies to choose from when architecting high-performance web applications.

### 02:12:30 - Best Practices for Astro + Solid: Building Component-Driven Apps

Drawing threads from earlier demos, Ryan articulates a recommended pattern for building Astro+Solid apps: develop UI components in Solid so they can be reused across server and client contexts, then embed them as “islands” in Astro pages. He advises structuring pages so that only truly interactive components—forms, counters, live-updating sections—are marked as hydratable, while static content (headers, footers, text blocks) remains pure HTML or statically rendered markup. In practice, this means that an Astro page’s layout and content can be defined with simple `.astro` components or templates, and any interactive widget can be a small Solid component imported where needed.

Ryan also emphasizes the importance of code-splitting and lazy loading interactive islands when they appear further down the page. He recommends using Solid’s `visible` directive (based on `IntersectionObserver`) to defer hydration until an island scrolls into view—though he cautions that deferring hydration for small components might actually delay user experience for negligible JavaScript savings. Finally, Ryan reminds viewers to leverage Solid’s conditional exports to eliminate unused features in production builds. Overall, this section distills practical advice on structuring Astro+Solid projects for maintainability, performance, and a cohesive developer experience.

### 02:18:30 - Q\&A: SSR Patterns, Async vs. Sync, and Fetch Integration

As the livestream approaches its close, Ryan invites live questions from the audience about server-side rendering configurations, switching between async and synchronous modes, and best practices for using `fetch` inside Solid+Astro. He clarifies that asynchronous SSR (using `renderToStringAsync`) is ideal when data can be resolved at build time—ensuring fully rendered pages without a hydration spinner—whereas synchronous SSR (`renderToString`) plus client-side fetching is better for highly dynamic or frequently updated data sources. An attendee asks about the trade-off between shipping hydration scripts and streaming SSR, prompting Ryan to re-emphasize that developer needs and hosting environment constraints should inform the SSR mode choice.

Another viewer inquires about how to integrate environment variables securely within `fetch` calls on the server versus the client. Ryan explains that Astro exposes environment variables prefixed with `PUBLIC_` to client code, whereas private secrets (e.g., API keys) should only be accessed within server-render functions or serverless endpoints. He demonstrates using `import.meta.env` inside a Solid `createResource` function to fetch API data exclusively on the server, avoiding accidental exposure. By the end of this Q\&A, participants have concrete guidance on SSR patterns, environment variable handling, data-fetch techniques, and security considerations when building full-stack Astro+Solid applications.

### 02:24:00 - Wrap-Up: Final Recommendations and Takeaways

To wrap up the session, Ryan recaps the highlights: the initial exploration of Astro’s project structure, the intricacies of Solid’s hydration and reactivity, and the dynamic data-loading examples. He reiterates key takeaways: harness Solid’s compile-time dead-code elimination to keep client bundles minimal; use `renderToStringAsync` for mostly static content at build time; and switch to `renderToString` plus client-side data fetching when content changes too frequently for static regeneration. He also reminds attendees about Astro’s hybrid capabilities: easily toggling between SSG, SSR, and streaming based on hosting environment support. These distilled recommendations serve as a cheat sheet for viewers to consult when starting their next Astro+Solid project.

Ryan further encourages the community to contribute to Solid’s documentation—particularly around SSR and hydration nuances—and to share feedback on Astro integration. He expresses excitement about how both frameworks are evolving rapidly and acknowledges that while some APIs may be in flux, the core philosophies of shipping minimal JavaScript and leveraging fine-grained reactivity will remain valuable. As he completes this final summary, Ryan thanks viewers for their questions and participation, reinforcing that the session’s intent was to demystify complex topics through hands-on examples and interactive discussion.

### 02:30:00 - Conclusion and Sign-Off

In the last segment, Ryan ensures that all remaining chat questions have been addressed, providing quick clarifications on any lingering points—such as how to configure global CSS in Astro, slot usage in layouts, and hooking into Solid’s hydration boundaries. He acknowledges that some troubleshooting steps (e.g., integrating Node-fetch) may require reading Astro’s or Solid’s documentation in more depth and recommends pragmatic workarounds like mocking data during development. With nearly three hours on the clock, Ryan expresses appreciation for the live audience’s engagement and patience, noting that even experienced developers may grapple with new SSR patterns when juggling multiple libraries.

Before formally signing off, Ryan reminds viewers of important resources: SolidJS’s GitHub repo for export condition examples, Astro’s documentation on layout slotting and dynamic routes, and community channels (Discord, GitHub) for troubleshooting. He shares excitement about upcoming improvements in both Solid and Astro—such as better automated hydration boundaries and deeper SSG optimizations—and encourages everyone to experiment with the patterns shown during the stream. With a final “Have a great weekend!” Ryan ends the livestream, leaving participants equipped with actionable insights to build fast, component-driven websites using SolidJS and Astro.
