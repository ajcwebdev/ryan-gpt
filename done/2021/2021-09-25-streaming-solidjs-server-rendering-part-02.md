---
showLink: "https://www.youtube.com/watch?v=0zadjVUV7zM"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "Streaming SolidJS - Server Rendering"
description: ""
publishDate: "2021-09-25"
coverImage: "https://i.ytimg.com/vi/0zadjVUV7zM/sddefault.jpg?v=614e0353"
---

### 00:55:00 - Async SSR Demo: Blocking Rendering Until Data Completes

Between fifty-five minutes and the one-hour mark, Carniato presents the asynchronous SSR (async SSR) mode, which blocks HTML rendering until all data dependencies resolve on the server. Using `renderToStringAsync` or a similar API, Solid waits for `createResource` to fetch both the main user and the secondary user info before generating HTML. As a result, the initial page load shows no content—no app shell, no placeholders—until both fetches complete. In the live demo, viewers see a blank page for approximately 800 milliseconds. Once the server sends the fully populated HTML, the time to first paint occurs, but this is often slower than client-side or streaming modes that show placeholders earlier.

In the second paragraph, Carniato compares async SSR timings to those of static and synchronous SSR. While async SSR ensures that users receive a fully ready page without client-side loading states, it suffers from longer time-to-first-byte and first paint metrics because the server must complete data fetching before responding. Carniato highlights that this approach is common in frameworks like Next.js and SvelteKit, where developers sometimes prefer a fully rendered page without progressive placeholders. However, he cautions that async SSR can result in poorer perceived performance on slower networks, as nothing appears until all data is fetched, contrasting with streaming or client-fetched SSR’s ability to show content sooner.

### 01:00:00 - Streaming SSR Demo: Combining Shell and Data Streams

At the one-hour mark, Carniato moves to the streaming SSR demonstration, which delivers the best of both worlds by streaming HTML chunks and serialized resource data as they become available. He invokes `pipeToNodeWritable` (or a Cloudflare Worker equivalent) to start sending the HTML app shell immediately, complete with suspense fallbacks (loading spinners) for pending data. As each resource fetch resolves on the server, Solid appends `<script>` tags that serialize finished resources into the HTML stream. This allows the browser to begin loading assets, render fallback UI, and hydrate resources incrementally without waiting for the entire page to be ready.

In the second paragraph, Carniato underscores how streaming SSR significantly improves both time to first paint and time to interactive compared to async SSR. By flushing partial HTML down the wire, the browser receives a usable app shell almost instantly—typically around 30ms in ideal conditions—followed by progressive loading of actual user and secondary user info. Carniato notes that although the current implementation streams resource data rather than streaming HTML fragments into active placeholders, this hybrid solution still dramatically reduces perceived loading times. Developers can add full HTML streaming in the future, but even this data-driven streaming approach yields performance on par with or better than pure client-rendered or async SSR pages.

### 01:05:00 - Performance Comparison on Fast Networks: Streaming vs SSR vs Async

Between 1:05:00 and 1:10:00, Carniato compares performance metrics across SSR techniques on a fast network. He highlights that streaming SSR’s first paint often occurs in the low 30ms range—virtually indistinguishable from static generation—because the HTML shell and suspense placeholders arrive almost immediately. Synchronous SSR, which sends the full page then hydrates on the client, yields first paint around 70–90ms. Async SSR, by contrast, waits until all data is fetched (about 800ms) before first paint, making it the slowest among the three. Carniato uses the Chrome DevTools performance panel to illustrate these differences, showing how streaming SSR consistently outperforms async SSR and comes within a hair of static generation under good network conditions.

The second paragraph expands on these findings by emphasizing developer decision-making. On a fast network, streaming and synchronous SSR deliver largely equivalent interactive experiences, though streaming edges out because it preloads assets earlier. Synchronous SSR may be simpler to implement, but misses the opportunity to render placeholders before hydration. Async SSR, while simpler for some server setups (e.g., when middleware needs to resolve all data), yields considerably slower perceived performance. Carniato concludes that for user-facing pages requiring fast interactivity under optimal conditions, streaming SSR offers the best balance between progressive rendering and minimal complexity.

### 01:10:00 - Performance on Slow Networks: Why Streaming and Async Outperform Client-Side Rendering

Between 1:10:00 and 1:15:00, Carniato simulates a “Fast 3G” network condition to demonstrate how rendering strategies behave under slower connections. He throttles network speed in Chrome DevTools, then re-profiles each mode. In streaming and async SSR, data fetching begins on the server as soon as the initial request arrives, so the server can include results in the response stream or post-fetch HTML. Even though first byte takes longer due to throttling—dropping around 600ms—the server has often already fetched the data, allowing the browser to render placeholders and populate content almost immediately. In his demo, both streaming and async SSR complete around 1.3 seconds to first paint.

In contrast, client-side rendering (CSR) suffers a severe penalty under the same throttled conditions. First, the browser must completely download the minimal HTML shell (around 600ms), then fetch and execute JavaScript (another 600ms), and only then initiate the data fetches (another 600ms), creating a “waterfall” that pushes the full page load to roughly 2.6 seconds. Carniato shows DevTools network and performance timelines where those cascading delays become evident. He concludes that under poor network conditions, streaming or async SSR are not just marginally better—they can be two to three times faster than CSR for user-facing, data-rich pages, making SSR a necessity in low-bandwidth scenarios.

### 01:15:00 - Under the Hood: SolidJS Streaming API and Server Adapters

Around 1:15:00, Carniato delves into the code underpinning Solid’s streaming SSR implementation. He navigates to the `solid-ssr` package and examines the `pipeToNodeWritable` helper, which accepts a render function and a Node.js response stream (or Cloudflare Worker equivalent) to stream content. The API leverages web streams to flush HTML and `<script>`-serialized resource chunks as resources resolve. Carniato explains that Solid provides multiple server adapters—Node.js, Cloudflare Workers, and potentially other environments—to ensure streaming SSR works seamlessly regardless of hosting platform. Key to this approach is using conditional exports so that developers write identical import statements for both client and server.

In the second paragraph, he highlights how the streaming helper automatically handles response headers like `Content-Type: text/html; charset=utf-8` and streams the head, body, and hydration scripts in a logical sequence. As each Suspense boundary resolves a resource, Solid injects a `<script>` that populates `window.__HYDRATION__` with resource data, then flushes remaining HTML. Carniato notes that while full HTML streaming (inserting actual content into placeholders before hydration) isn’t implemented today, data streaming alone suffices to start asset loading and spinner replacements much earlier. He points out that Cloudflare Workers support streaming out-of-the-box, whereas other serverless environments may require upgrades in their runtime to fully support streaming.

### 01:20:00 - Hydration Mechanics: Efficient DOM Walking and Minimal JS

At about 1:20:00, Carniato shifts focus to Solid’s hydration mechanics, illustrating how Solid minimizes client-side JavaScript for hydrating server-rendered HTML. He shows that the same template-based compilation used for SSR on the server also powers client-side hydration. Because Solid separates template creation (chunking HTML into strings and placeholders) from DOM walking (adding event listeners and reactive contexts), hydration only injects code for dynamic parts. Static HTML segments—such as `<html>`, `<head>`, and `<body>` tags—never ship to the client because Solid recognizes they’re unnecessary once in the DOM. This eliminates hundreds of lines of JavaScript associated with static markup.

The second paragraph explains how Solid conditionally strips out template code when hydrating from a document rather than rendering from scratch. Using simple DOM traversal—`firstChild` and `nextSibling` calls—Solid identifies dynamic holes quickly without resorting to expensive `querySelector` lookups. This approach not only accelerates hydration but also dramatically reduces the JavaScript bundle size responsible for hydration logic. Carniato demonstrates that even if developers mistakenly leave server-only code in their components, Solid’s “server-only” directive can prune out entire HTML template chunks, resulting in zero-KB JavaScript for pages with no interactive elements. By focusing on minimal, essential hydration code, Solid ensures that users only download what’s strictly necessary to make the page interactive.

### 01:25:00 - Partial Hydration Discussion: Astro vs SPA Focus and Future Directions

Shortly after 1:25:00, the discussion turns to partial hydration and how Solid’s approach compares to frameworks like Astro or Marko that emphasize islands architecture. Carniato acknowledges that true partial hydration—where static content remains in the DOM and only interactive “islands” hydrate—can deliver even smaller initial JavaScript bundles. He notes that Solid could support an Astro-style strategy by identifying static template segments and binding hydration code only to components flagged as dynamic. However, he also points out the complexity in implementing a universal islands solution: Solid would need to analyze templates at compile time and produce separate hydration bundles for each island, which demands significant tooling and infrastructure.

In the second paragraph, Carniato shares his rationale for prioritizing single-page application (SPA) optimizations over a full islands architecture. He argues that since Solid already excels at delivering minimal hydration code via template walking, its incremental bundle sizes are small enough to rival islands approaches. He further notes that integrating with frameworks like Marko or Astro for an MPA workflow might be more pragmatic for multi-page sites, leaving Solid to focus on SPA use cases where developers expect a single JS bundle. Carniato suggests that once Solid supports multiple hydration roots and seamless streaming, many of the perceived benefits of islands will be covered without the additional complexity. He outlines a vision where full streaming SSR and multi-root hydration provide nearly identical performance advantages within a unified SPA model.

### 01:30:00 - Introducing Solid Start: Boilerplate, File-Based Routing, and Dev Experience

At the 1:30:00 mark, Carniato introduces Solid Start, a new project scaffold that combines Solid’s SSR capabilities with file-based routing, metadata management, and asset bundling. He opens a freshly generated Solid Start project and explains its directory structure: a `src/routes` folder where developers place `.ts` or `.tsx` files to automatically generate pages. Solid Start comes pre-configured with essential components like `<Routes>`, `<Meta>`, `<Outlet>`, and `<Scripts>`, which handle route rendering, document head tags, nested route injection, and hydration logic, respectively. Carniato emphasizes that Solid Start leverages Vite’s speedy bundling and built-in features like environment variables, CSS handling, and Hot Module Replacement (HMR) to streamline development.

In the second paragraph, he walks through the `root.tsx` file, showcasing how developers wrap `<Routes>` inside `<Meta>` and `<Scripts>` within a single `Root` component. This `Root` component defines shared layout elements—like a navigation bar—that appear across all pages. Carniato points out that Solid Start’s Dev mode automatically triggers full page reloads when non-component files (like HTML or route files) change, while still supporting SPA-style HMR for component edits. Although he discovers some rough edges with Vite’s glob imports and route auto-reloading, he underscores that Solid Start’s minimal boilerplate dramatically accelerates the process of creating an isomorphic Solid application by handling routing, meta tags, and hydration under the hood.

### 01:35:00 - Solid Start Router in Action: Creating Dynamic Routes and Nested Layouts

Between 1:35:00 and 1:40:00, Carniato demonstrates adding new pages via Solid Start’s file-based routing. He creates a `hello.tsx` file under `src/routes` and populates it with a simple `Hello` component that reads from `useParams()`. After saving the file, Vite automatically updates the development server, injecting the new route into the navigation. When navigating to `/hello`, the page displays “Hi, \[param]”, showcasing how Solid Start derives dynamic parameters from file names—e.g., `[id].tsx` yields `useParams().id`. Carniato shows how removing or renaming route files triggers a full reload of the server in Dev mode, reminding viewers that some aspects of the routing system still rely on file watches.

In the second paragraph, Carniato introduces nested layouts via Solid Start’s `<Outlet>` component. He moves `hello.tsx` into a `/users` folder to create a parent `/users` layout. By adding a `_layout.tsx` file in `src/routes/users`, he defines shared markup—such as a header or sidebar—wrapping all `/users/*` pages. In `_layout.tsx`, the `<Outlet>` placeholder injects matching child routes, enabling hierarchical page structures without manual router configuration. This nested routing capability parallels other file-based frameworks like Remix or Next.js but is tailored to Solid’s reactive components. Carniato asserts that these conventions drastically reduce boilerplate, letting developers focus on building UI rather than wiring routing logic.

### 01:40:00 - Actions API: Simplifying Isomorphic Data Fetching with Functions

At around 1:40:00, Carniato introduces Solid Start’s “actions” feature, which lets developers author isomorphic data-fetching functions directly in route files. Instead of defining REST endpoints, developers create a file named `users.actions.ts` exporting functions—e.g., `getAllUsers()`—that return Promises. In the component code, they import these functions under an `actions` namespace. When calling an action inside a `createResource`, Solid automatically resolves the function on the server during SSR, streams the data to the client, and caches it to avoid duplicate fetches. Carniato emphasizes that because actions run identically on both server and client, there is no need for separate API route files or custom fetch logic.

In the second paragraph, he demonstrates how streaming works with actions. He places a `console.log(“getAllUsers”)` inside the action and shows that on a server-rendered request, only the server console logs appear. When navigating client-side after page load, the log shifts to the browser console, indicating that the action is now running in the client environment. Viewers see how `createResource(actions.getAllUsers)` triggers streaming on SSR—embedding `<script>` tags containing serialized user data—while, in CSR mode, the action behaves like a standard fetch. By abstracting data access into simple functions, Solid Start removes the need to maintain separate server-only and client-only code, streamlining the developer experience.

### 01:45:00 - Interactive Components with Actions: Mutations and Server-Side Execution

Between 1:45:00 and 1:50:00, Carniato demonstrates using actions to implement interactive features and server-side mutations. He creates a simple `sayHello(name)` action in `greeting.actions.ts` that returns a greeting string. In a React-like fashion, he uses Solid’s `onMount` to call the action once upon component initialization, storing the result in a signal. Viewers watch the greeting “Hi, Tom” appear instantly during SSR, proving that the action ran on the server and streamed the data. He then wires an input field and button so that on a click, the `sayHello` action executes in the client environment, updating the greeting dynamically.

In the second paragraph, Carniato explains that actions work seamlessly across both server and client without requiring separate endpoints or fetch wrappers. When the button triggers `sayHello` in the browser, a network request is sent to invoke the same action on the server, which then returns the greeting string for client display. He shows how both “loadUser” and “sayHello” logs appear in the appropriate console (server or client) depending on where the action runs. This pattern highlights Solid Start’s ability to model typical CRUD operations or form submissions as simple functions rather than RESTful handlers, making it easier to reason about data flow and reducing boilerplate.

### 01:50:00 - Building and Deploying Solid Start: Production Build Process and Challenges

Shortly after 1:50:00, Carniato shifts to building the Solid Start project for production. He runs `npm run build`, showing how Vite compiles and bundles the server-side code under a `server` directory and client assets under `dist`. For node-based deployment, the `server` folder contains an `index.js` that uses Solid’s `renderToNodeStream` or `renderToString` functions to handle incoming requests. Carniato then runs `npm run start` to spin up a production server, which should serve the app at `http://localhost:3000`. However, he encounters a runtime error due to Vite’s recently changed file handling in Dev mode—underscoring that Solid Start remains a work-in-progress and reliant on Vite for bundling configuration.

In the second paragraph, Carniato discusses the production build challenges and what’s needed to polish deployment. He notes that while Solid Start’s scaffold generates everything required for basic SSR, real-world deployments often require adjustments: environment variable handling, static asset serving, and serverless function compatibility. The error he encounters demonstrates that minor changes in Vite’s glob import behavior can break route auto-registration, reminding viewers that Solid Start’s file-based routing must stay in sync with Vite’s API. Carniato encourages community contributions to iron out these issues, stating that once such wrinkles are smoothed, Solid Start will provide a robust foundation for deploying high-performance SolidJS apps anywhere.

### 01:55:00 - Solid Start Roadmap: Current Status, Documentation, and Community Contributions

Between 1:55:00 and 2:00:00, Carniato outlines Solid Start’s status and upcoming roadmap. He acknowledges that core SSR features (streaming, multi-root hydration, code splitting) function well, but there’s minimal public documentation. He stresses that as APIs stabilize—especially once multi-hydration roots and full HTML streaming are implemented—comprehensive guides will follow. Carniato admits he prioritized refining Solid’s reactive runtime and SSR engine before dedicating significant effort to Solid Start’s docs. He assures viewers that once the streaming story is complete, he will focus on fleshing out documentation, tutorials, and examples to help developers adopt Solid Start easily.

In the second paragraph, Carniato invites community involvement to expedite Solid Start’s maturation. He lists high-impact areas: testing route auto-reloading, ironing out Vite-specific quirks, adding nested layout caching, and creating starter templates. He emphasizes that while Solid Start’s code scaffolding is relatively minimal, it stands on Solid’s robust SSR engine; contributions around error handling, environment variable management, and adapter extensions (e.g., Deno, AWS Lambda) would significantly enhance its usability. Carniato stresses that SolidJS thrives on community feedback and pull requests, encouraging interested developers to join the Solid Discord or GitHub repo to help stabilize Solid Start before its wider release.

### 02:00:00 - SSR Documentation Philosophy: Timing and Completeness Before Public Release

From 2:00:00 to 2:05:00, Carniato explains his philosophy around documenting SSR features only once they reach a certain level of completeness. He acknowledges that many tutorials and blog posts provide partial or outdated information, leading to confusion. To prevent this, he prefers to delay official documentation until core SSR mechanisms—such as streaming, async rendering, and hydration optimization—settle into stable APIs. Carniato believes that premature documentation can mislead developers about best practices, so he opts for “less, but better” content. Once Solid’s SSR offering covers all major use cases with clear patterns, he will publish a thorough guide covering everything from basic SSR to advanced streaming and partial hydration.

The second paragraph discusses the balance between transparency and waiting for features to mature. Carniato notes that by the time he publishes detailed SSR docs, Solid’s performance and API may already improve due to ongoing optimizations. He wants documentation that reflects the current reality of Solid’s engine rather than describing outdated workflows. This approach may frustrate some early adopters, but he argues it’s preferable to releasing fragmented or obsolete information. Carniato also mentions community-driven docs and blog posts can fill interim gaps, but the “official” guide should align with Solid’s long-term vision. This ensures that developers have accurate, up-to-date references when building production-grade applications.

### 02:05:00 - Community Involvement and Future Features: Call for Contributors and Next Steps

Between 2:05:00 and 2:10:00, Carniato reiterates the importance of community contributions to accelerate Solid’s SSR and Solid Start development. He highlights key areas open for collaboration: implementing full HTML streaming (sending actual content fragments to replace placeholders before hydration), enabling multiple independent hydration roots (allowing partial hydration akin to islands), refining Solid’s build pipeline for optimized code splitting, and improving adapter compatibility across diverse hosting environments. Carniato believes these features are crucial for Solid to offer a cutting-edge developer experience that rivals or surpasses frameworks like Next.js, Astro, and Marko. He urges viewers to test current APIs, report bugs, propose enhancements, and submit pull requests to the official GitHub repositories.

The second paragraph focuses on the SolidJS ecosystem’s collaborative spirit. Carniato emphasizes that while he personally spearheads core SSR and reactive engine improvements, the vibrant Solid community’s collective energy drives features like Party Town integration, Netlify deployment optimizations, and CSS-in-JS experiments. He encourages developers of all skill levels to engage in discussions, share use cases, and contribute tutorials or sample projects. By aligning on a shared vision—where server and client rendering work seamlessly, performance remains paramount, and developer ergonomics remain intuitive—Solid can extend its momentum beyond client-side performance to full-on isomorphic excellence. Carniato wraps up by thanking volunteers who have already contributed and invites new developers to “get their hands dirty” in code, documentation, or community events.

### 02:10:00 - Closing Remarks and Farewell

From 2:10:00 until the final timestamp at 2:14:32, Carniato delivers closing remarks and thanks viewers. He reiterates that while he covered many topics—Solid’s SSR origins, performance benchmarks, streaming API, hydration mechanics, and Solid Start—there is still more to explore. He reminds everyone that Solid’s documentation will expand in the coming months to include comprehensive SSR guides once features stabilize. Carniato also expresses appreciation for community engagement during the stream, acknowledging chat questions and sharing contact points like the Solid Discord server. He emphasizes that SolidJS’s future depends on collective effort and open communication between maintainers and users.

In his final words, Carniato previews upcoming milestones: polishing full HTML streaming support, implementing multi-root hydration, and releasing official Solid Start documentation. He thanks early adopters who have tested bleeding-edge features and provided invaluable feedback. Carniato encourages everyone to code, experiment, and report issues, reinforcing that Solid’s core merits—simplicity, performance, and reactivity—will remain unchanged. As the stream winds down, he invites viewers to tune into future streams, ask questions on Discord, and contribute to GitHub. Finally, he signs off with a friendly “Have a good weekend,” officially concluding the session at 2:14:32.