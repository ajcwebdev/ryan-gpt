---
showLink: "https://www.youtube.com/watch?v=UPhx3OxUH0w"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "Streaming SolidJS - First look at Astro"
description: ""
publishDate: "2021-10-02"
coverImage: "https://i.ytimg.com/vi/UPhx3OxUH0w/hqdefault.jpg?v=615732c7"
---

## Episode Description

A deep, live exploration of integrating SolidJS with Astro, covering JavaScript news, Solid updates, server-side rendering, project setup, hydration mechanics, and dynamic data handling in a three-hour hands-on stream.

## Episode Summary

In this extensive three-hour livestream, Ryan Carniato introduces viewers to the emerging landscape of multi-page and single-page applications, citing recent JavaScript discussions and highlighting SolidJS’s rapid growth within the community. He then transitions to an in-depth look at Astro, a modern static site generator, demonstrating how to set up a Solid-integrated Astro project from scratch. Throughout the stream, Ryan navigates configuration nuances, sheds light on Solid’s export conditions, and delves into hydration strategies, showcasing progressive hydration with Solid’s event replay. He also tackles dynamic data fetching in Astro, wrestling with CSS scoping, layout slotting, and troubleshooting Node-fetch integration. The episode concludes by contrasting asynchronous and synchronous server-side rendering, emphasizing best practices for building performant, component-driven web apps, and offering practical Q\&A-driven insights drawn from live audience interaction.

## Chapters

### 00:00:00 - Introduction, JavaScript News, and Solid Updates

Ryan welcomes viewers to the stream, setting the stage by sharing recent happenings in the JavaScript ecosystem, including ongoing debates around multi-page versus single-page application architectures and performance trade-offs. He reflects on a podcast discussion with Rich Harris regarding the value of server-rendered sites and observes that multi-page apps can deliver excellent performance while still offering a robust developer experience. During this opening segment, Ryan subtly gauages audience presence and encourages live interaction before pivoting to talk about SolidJS’s latest community and sponsorship news, emphasizing Solid’s collaboration with Netlify and the project’s rapid adoption, including translations of documentation into ten languages.

Over the span of the first few minutes, Ryan delves into SolidJS’s momentum, highlighting significant contributions from the community, such as the CSS-Tricks article and positive feedback from prominent React developers. He expresses gratitude for the supportive response within the React community, recounting invitations to speak at events like React Finland, which he initially feared might be adversarial. By the end of this introduction, viewers have a clear sense of the stream’s scope: a blend of industry commentary and hands-on exploration of SolidJS with Astro, framed by Solid’s growth and Open Source sponsorship milestones.

### 00:04:26 - Solid vs. React, Server-Side Rendering, and Introducing Astro

Building on the earlier JavaScript news, Ryan examines the narrative often presented in the multi-page apps versus single-page apps debate, pointing out that longstanding veterans of each camp sometimes fail to see eye to eye. He reflects on Rich Harris’s assertion that multipage applications are primarily about reducing JavaScript payloads rather than performance alone and contends that modern frameworks can indeed deliver both performance and developer experience. Ryan argues that server-side JavaScript—exemplified by Next.js or Astro—allows for powerful server-rendered apps without overloading the browser, effectively bridging the gap between multipage and single-page paradigms.

Having set up the context for server-side rendering, Ryan formally introduces Astro, describing it as a relatively new multipage application (MPA) static site generator designed to optimize web fundamentals by shipping minimal JavaScript. He outlines Astro’s flexibility in supporting “islands” of interactivity—partial hydration boundaries where only necessary components become interactive in the browser. This segment wraps up by Ryan expressing his familiarity with Astro’s concepts through videos and articles but confessing he has yet to build a project himself, setting the stage for hands-on experimentation in the subsequent chapter.

### 00:10:08 - Initializing an Astro Project and Developer Preferences

Ryan begins the practical portion of the stream by creating a new directory for the Astro project and running the command to initialize an Astro starter. As Astro’s interactive CLI appears, he navigates through the available starter templates, ultimately choosing the generic blog template to keep things simple. While awaiting the project scaffolding, he shares personal reflections on how developer tools have shaped his workflow, recalling his days coding in CoffeeScript with extremely compact code that allowed him to view entire files at a glance. He admits to initially resisting opinionated formatters like Prettier, but acknowledges their value in promoting consistency.

As the Astro starter setup completes, Ryan expresses appreciation that SolidJS was included in Astro’s list of supported frameworks—especially gratifying given the difficulty new frameworks can face gaining traction. He recalls submitting pull requests to other projects years ago that took two years to merge due to Solid’s relative obscurity at the time. In these early minutes of building the project, Ryan not only demonstrates the simplicity of Astro’s scaffolding commands, but also highlights how strategic tool support and community momentum can rapidly elevate a framework’s visibility and integration.

### 00:15:06 - Examining Astro’s Project Structure and File Format

With the Astro project created, Ryan opens the folder in his code editor (VS Code) and navigates through the newly generated file tree. He showcases the `public` directory for static assets and `src` for source code, where global CSS and standard file-based routing structures—`pages` and `components`—reside. He briefly experiments with installing a VS Code extension to highlight `.astro` syntax, reminiscing about his preference for compact code views and larger fonts due to his CoffeeScript background. As he explores Astro’s file types, Ryan highlights how Markdown integration works natively, noting that Astro’s audience—often web developers familiar with static site generators—will appreciate embedded Markdown support.

Ryan then opens Astro’s configuration and project files (`tsconfig.json`, `astro.config.mjs`) while exploring sample pages and components. He expresses admiration for Astro’s built-in conventions, such as automatically loading Markdown files as pages and supporting CSS files in the page generation flow. Although Ryan admits he isn’t fully conversant with every Astro convention yet, he appreciates the clear separation between public assets, global styles, and component definitions. By the end of this chapter, viewers have a solid understanding of Astro’s foundational project layout and file formats.

### 00:20:20 - Running Astro Dev Server and Resolving Errors

Ryan launches the Astro development server with `npm start` and navigates to `localhost:3000` in the browser. He inspects the rendered static HTML and notes Astro’s default homepage content. However, he quickly notices his Solid integration did not automatically apply—Astro rendered the generic blog template without Solid components, indicating the Solid renderer plugin wasn’t installed. He decides to restart the project generation process using the Solid-integrated starter to bypass manual renderer installation: deleting the existing folder and re-running `npm init astro` with the Solid counter starter selected. This time, the Solid template includes a simple counter example in JSX, confirming Solid integration.

After the project re-creation, Ryan runs `npm install` and `npm start` again, monitoring VS Code’s output and the browser’s DevTools console. He toggles between the terminal and Chrome, verifying that Solid’s `solid-counter` component appears on the page. Throughout this troubleshooting, Ryan emphasizes that beginners may encounter similar pitfalls—installing the wrong template or missing the framework option—and that learning to debug build errors is a crucial developer skill. By the end of this chapter, he successfully boots a working Astro + Solid starter with the familiar Solid counter component.

### 00:26:43 - Investigating Solid-Astro Integration and Hydration Behavior

With the Solid starter running, Ryan inspects the rendered counter component in the browser, marveling at how the Solid component behaves like a web component—only the counter element updates without a full page refresh. He opens the Astro plugin code for Solid, locating the `astro-solid-js` renderer package and its `index.js` file. In this code, Ryan identifies how the plugin chooses between server-side rendering (SSR) and client-side hydration, noting the use of `renderToString` for SSR and the template’s hydration attributes. He also confirms that the plugin configures Babel with `@babel/preset-solid` to transform JSX and handle Solid’s reactivity on both client and server.

To better understand how Solid components are rendered in Astro, Ryan walks through the plugin’s code paths: creating a Solid component, generating HTML with `renderToString`, and injecting it into Astro’s template. He observes that the plugin currently re-renders the entire component on the client instead of hydrating in place, resulting in a brief flicker. This chapter wraps up with Ryan expressing gratitude for the community members—Nate Moore, Trevor—who built the Solid integration, and he acknowledges that, as a newcomer to Astro, he is now “walking in blind” while still comprehending the high-level mechanisms at work.

### 00:32:18 - Deep Dive into Solid’s Conditional Exports and Bundler Optimizations

Ryan transitions to a broader discussion of how Solid optimizes for both client and server environments using conditional exports in `package.json`. Screen-sharing his terminal, he pulls up the SolidJS repository on GitHub, navigating to `package.json` to highlight the `exports` field. He explains that Solid specifies different entry points—such as `import: “./dist/solid.js”` for client-side usage and `node: “./dist/solid.server.js”` for server-side contexts. This mechanism allows bundlers like Rollup and Vite to intelligently pick the correct build variant without additional configuration, ensuring that server-only APIs are not shipped to the browser.

Diving deeper, Ryan covers how Solid’s approach enables tree-shaking to strip out unused features like concurrent rendering or transition support when they aren’t activated. For instance, if a developer never uses `Suspense`, Solid’s build will exclude all of the associated code, yielding extremely small bundles. He contrasts Solid’s technique with React and Preact, noting that Solid’s elimination of dead code at runtime is key to its performance gains. By the end of this segment, viewers understand the power of conditional exports in accelerating build times and minimizing client-side payloads.

### 00:38:11 - Understanding Astro’s Solid Renderer and Hydration Mechanics

Returning to the Astro Solid renderer code, Ryan examines how the plugin integrates with Astro’s build pipeline. He highlights that the renderer’s `index.js` imports Solid’s server-side entry and calls `renderToString` with `Hydratable: true`, while the client entry uses `render` or `hydrate` to attach event listeners and reactive state. Ryan points out the plugin’s clever use of Solid’s `renderToStringAsync` to support suspense boundaries—allowing asynchronous data fetching to block HTML generation until promises resolve. He muses about current limitations in Solid’s `renderToStringAsync` regarding multiple suspense islands, noting that full support will require further enhancements.

To demonstrate how Solid’s hydration scripts behave within Astro, Ryan inserts breakpoints and inspects the output HTML and JavaScript bundles in DevTools. He notes that Astro injects a `<script type="module">` for the Solid hydration runtime, which grabs serialized data from the HTML and replays user events—ensuring a smooth transition from server-rendered HTML to a live reactive UI. Throughout this technical deep dive, Ryan stresses that understanding the interplay between server-side rendering, hydration, and client bundling is essential for building high-performance MPA sites with Astro and Solid.

### 00:44:00 - Debugging Hydration, Clearing Cache, and Observing Event Replay

To see hydration in action, Ryan deliberately breaks the Solid renderer by switching the plugin’s `Hydratable: true` flag to `false`, then clears Astro’s cache and rebuilds the project. As expected, the Solid counter no longer hydrates properly—clicks do nothing when interacting with the server-rendered HTML. Ryan then restores hydration, reloads the page, and interacts with the counter before it’s hydrated. The audience sees a brief “jump” in count when the component hydrates, showcasing Solid’s event replay feature: user clicks on the unhydrated button are queued and replayed once hydration completes.

Ryan walks through the Solid hydration script code—loaded from Astro’s assets—and explains how it globally delegates click and input events to nearest hydration boundaries marked by `data-hk` attributes. When hydration triggers, Solid replays any stored events in the correct order, ensuring seamless user interaction even if users click before the JavaScript runtime fully loads. By the end of this debugging session, developers gain a clear picture of how progressive hydration works under the hood: events are captured at the document level, bound to hydration contexts, and replayed precisely on component initialization.

### 00:48:45 - Solid’s Hydration Script Mechanics and Community Q\&A on React & Web Components

Pausing for a sip of water, Ryan addresses live chat questions about Solid’s hydration internals, web component compatibility, and Solid’s position relative to React and Svelte. He highlights that Solid’s hydration script registers delegators for common DOM events (click, input, etc.) and uses a microtask queue to replay them in sequence. He also points out that Solid natively handles Shadow DOM by walking up the event’s composed path to find the closest hydration key, allowing seamless integration with Web Components. A viewer asks about “LE5” and Ryan connects with community members like Dan Shappir (React core team), joking that some folks might know more about Solid’s compilers than he does these days.

During this section, Ryan revisits Solid’s broader philosophy: fine-grained reactivity, no virtual DOM overhead, and zero-bundle-cost transitions when features aren’t used. He acknowledges that Solid’s documentation may lag behind on certain SSR topics, but emphasizes that the core reactivity and hydration model remains cutting-edge. Audience members also bring up size comparisons: Solid components often ship smaller client bundles than Svelte once a site grows, and they dramatically outperform React or Vue in complex benchmarks. Ryan wraps up by reiterating Solid’s unique selling point: borrow the best of React’s ergonomics while benefiting from tiny, compile-time optimized bundles and instantaneous updates.

### 00:55:03 - Solid Reactivity, Data-Driven Binding, and Performance Comparisons

Picking up on previous comparisons, Ryan dives deeper into Solid’s reactivity system and how it leverages compile-time transformations to generate minimal DOM update code. He explains that Solid creates distinct client and server runtimes—Solid’s “client” runtime handles DOM updates, while the “server” runtime handles SSR logic, both toggled via `exports` in `package.json`. When bundling, a condition like `node` or `browser` picks the appropriate build, eliminating unnecessary code. He notes that Solid can remove entire features such as transitions, concurrent rendering, or even Suspense if they are not imported, resulting in bundles that can be smaller than Svelte’s or Preact’s in real-world apps.

ryan shows attendee comments comparing bundle sizes: a single “Hello World” component in Solid can be \~220 bytes gzipped, compared to \~350 bytes for Svelte and \~1.6 KB for React. He demonstrates how a typical Hacker News app built with Solid can have a 1.6 KB client bundle, whereas Svelte’s counterpart might be 3 KB, and React significantly larger. This segment highlights that developers can choose Solid for its unique combination of runtime performance—up to 10× faster UI updates in some benchmarks—and near-zero incremental cost for features they don’t use. Overall, the conversation provides a clear rationale for Solid’s appeal in building modern, data-driven web apps.

### 01:01:00 - Sharing State Between Components and Conceptualizing Partial Hydration

Ryan responds to a question about sharing state between multiple Solid islands on the same page in Astro. He proposes a simple global-store pattern, creating a `components/store.jsx` file that exports a reactive signal (`createSignal`) and a setter. By assigning the store object to `window.$store`, he demonstrates how two separate `solid-counter` components in different parts of an Astro page can reflect the same shared state. He acknowledges that attaching state to `window` is somewhat “hacky” but effective; in production, one might instead configure a global store with events or a pub/sub mechanism that decouples islands without hoisting all state to a parent.

Moving into partial hydration territory, Ryan explains that Solid’s compile-time reactivity makes it possible to ship only the minimal code required to hydrate interactive components, while omitting static templates entirely. For example, if a component never updates after its initial render, Solid can exclude the associated creation logic from the client bundle. This approach—often called partial hydration or “islands architecture”—reduces JavaScript payload even further. Although Solid’s tooling does not yet fully automate this pattern, Ryan illustrates how one could manually mark non-interactive components as server-only to remove their templates from the client bundle, saving around 50% of code in some scenarios.