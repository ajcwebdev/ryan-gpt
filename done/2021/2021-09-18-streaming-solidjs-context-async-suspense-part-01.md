---
showLink: "https://www.youtube.com/watch?v=8Ou6domKfU4"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "Streaming SolidJS - Context, Async, & Suspense"
description: ""
publishDate: "2021-09-18"
coverImage: "https://i.ytimg.com/vi/8Ou6domKfU4/sddefault.jpg?v=61453cfd"
---

## Episode Description

Ryan Carniato guides viewers through an extensive SolidJS livestream, detailing context APIs, fine-grained reactivity, async handling with createResource, Suspense, and concurrent transitions.

## Episode Summary

In this extensive livestream, Ryan Carniato begins by sharing recent JavaScript trends—such as multi-page app (MPA) modes in frameworks, Svelte versus React syntax debates, and Vue’s no-JS MPA approach—before shifting focus to SolidJS’s design philosophy. He examines context APIs in Solid, explaining how createContext and createRoot power a hierarchical, efficient context mechanism that avoids prop drilling and unnecessary re-renders common in virtual DOM frameworks. Carniato then introduces createResource for managing asynchronous data and demonstrates Suspense’s integration, showing how Solid pauses and resumes fine-grained updates without full tree reconciliation. He outlines transitions and createDeferred, contrasting them with React’s concurrent mode, and explains how Solid’s scheduler forks reactive graphs for smoother UI updates. Throughout, he addresses performance trade-offs, server-side rendering considerations, caching strategies, and influences from React Query and GraphQL. By the end, Carniato offers practical examples, Q\&A sessions, and insights into Solid’s future, making complex topics accessible to both newcomers and experienced developers.

## Chapters

### 00:00:00 - Introduction and JavaScript Trends

In this opening chapter, Ryan Carniato welcomes viewers to his SolidJS livestream and outlines the session’s casual format. He encourages audience interaction, mentions his intention to discuss SolidJS features and design decisions, and signals that viewers should feel comfortable asking questions throughout the stream. While waiting for other participants to join, Carniato dives into recent developments in the JavaScript ecosystem, particularly drawn from conversations on Twitter. He highlights hot topics like the emergence of multi-page app (MPA) architecture in frameworks, including Vue’s newly introduced MPA mode, which reportedly can default to “no JavaScript” setups. This trend, along with discussions about partial hydration and streaming frontends, aligns with approaches similar to Marko and Astro, frameworks Carniato has worked with since 2014. His firsthand experience with Marco framework informs his perspective as he notes that many projects are now racing to replicate these MPA capabilities simply to stay competitive.

The chapter then transitions into an exploration of Svelte versus React syntax comparisons, prompted by a widely circulated meme on Twitter. Carniato analyzes the meme’s representation of Svelte’s “let count” syntax and critique of React’s more verbose `useState` API. He points out that the meme omits essential script tags surrounding Svelte code for proper context, a detail that few casual viewers notice. This oversight spurred Carniato to underscore the subtle differences between frameworks aiming to minimize boilerplate. He remarks on how Svelte deliberately adopted a non-JavaScript syntax to feel more approachable to developers, whereas React’s hooks require explicit imports like `useState`. By weaving in these topical issues, Carniato sets the stage for why SolidJS’s approach to reactivity and boilerplate reduction matters in the current landscape.

### 00:06:00 - Syntax Debates and Reactive Grammar

Continuing from the Svelte versus React meme, Carniato delves into broader conversations about reactive language syntax across frameworks. He observes that all modern UI libraries—Svelte, Vue, Solid, and React—are converging on reactive principles such as state management, derivations (computed values), and side effects. He notes that Svelte’s design deliberately incorporates a language-level reactive syntax (e.g., `$:` labels) to feel like writing plain JavaScript, while React steers developers toward hooks and function calls (e.g., `useState`) to manage state. Carniato also calls out a community plugin by Alexis that enables Svelte-like labeling in Solid via a Babel plugin, effectively stripping away import statements for signals and allowing a more concise syntax. The discussion emphasizes that syntactic preferences often reflect each framework’s underlying philosophy and trade-offs between readability and tooling support.

He then compares Vue’s composition API, which leverages decorators on functions rather than per-variable labels. By using decorators, Vue maintains a clear boundary between reactive and non-reactive code within its setup script, although exporting values across files may still require prefix conventions like double-dollar signs. Carniato highlights these subtleties and acknowledges that no single syntax is objectively “best”; rather, they solve different developer expectations. For example, React’s immutable top-down rendering model deliberately avoids language-integrated reactivity to preserve a render-everything mentality, whereas Solid embraces fine-grained reactivity at the signal level. By exploring these syntax debates, Carniato demonstrates how SolidJS situates itself as a pragmatic compromise: using JSX for familiarity while offering powerful, granular reactivity under the hood.

### 00:12:00 - Philosophical Divergences and Expressive DX

In this segment, Carniato further contrasts philosophies across JavaScript frameworks by focusing on immutability, state management, and developer experience (DX). He notes that React’s emphasis on immutable data flows results in hooks that intentionally avoid reactive language features, believing that forcing developers to treat state as plain functions and dependencies promotes predictable top-down updates. In contrast, Vue aggressively embraces mixture of styles—offering template syntax, reactive refs (`ref()`), and composition API—all in a bid to be flexible. Carniato underlines that these syntactic and philosophical decisions reflect each framework’s intended developer patterns: while Vue aspires to “be everything to everyone,” React adheres to a stricter mental model, and Svelte pursues minimal upfront code. Through this lens, Solid’s design choices—fine-grained reactivity implemented as signals, the absence of a virtual DOM, and a JSX-based API—emerge as a clearer “reactivity-first” philosophy aimed at improved performance and more expressive DX.

He explores specific trade-offs, such as Solid’s choice to require function calls for signals (e.g., `count()` to read a value and `count.set()` to update) versus Vue’s `ref().value` syntax for reactivity. Carniato observes that both patterns introduce verbosity—Solid’s `count()` call wrappers and Vue’s `.value` property access—but ultimately provide clear affordances for explicit reactivity. Meanwhile, Svelte’s language-integrated reactivity hides these details behind labels, sometimes hindering composition unless developers adopt store patterns. Carniato emphasizes that these syntactic variations go beyond aesthetics: they shape how developers think about and structure stateful logic. By comparing these frameworks’ philosophies, Carniato underscores why SolidJS opts for an explicit signal API, granting developers direct control over dependencies, memoization, and cleanup in a consistent, composable manner.

### 00:18:00 - Understanding Context in SolidJS

Transitioning from philosophical contrasts, Carniato introduces SolidJS’s context API, outlining the two main questions: “Why context?” and “How does context work in Solid?” He begins with the “how,” demonstrating that Solid’s context patterns will feel familiar to React developers. Carniato shows code to define a context by calling `createContext()` with an optional default value. This returned context object then provides a `Provider` component that accepts a `value` prop and children to render. Once wrapped, any nested component can call `useContext(MyContext)` to access the nearest ancestor’s provided value. He explains that context uses a unique symbol under the hood so that multiple context instances don’t collide. Carniato also covers default value fallbacks, which allow global configuration values to exist even if no provider wraps part of the tree.

He then demonstrates the typical wrapper pattern: creating a custom provider component that takes an initial state (e.g., a count) and wraps its children with `<Context.Provider value={someSignal}>`. This wrapper abstracts away boilerplate, allowing end users to import a single component rather than a context object and provider separately. Carniato highlights that although this pattern still requires writing a bit of boilerplate, it encapsulates complexity—users who consume the context simply call a consumer hook or component without worrying about implementation details. By the end of this chapter, viewers understand how to set up context in Solid: define a context, wrap with a provider, and use context deeply within the component tree.

### 00:24:00 - Context Usage and Prop-Drilling Avoidance

Building on the context API demonstration, Carniato provides a concrete example of using context to avoid prop drilling. He shows a `main.jsx` file where a `CounterProvider` wraps an `App` component. Within `App`, no reference to `count` is visible; instead, a deeply nested `Nested` component calls `useCounter()` to access the signal directly. The `Nested` component uses the provided `count` signal to render a `Counter` UI that increments or decrements without passing props through intermediate components. This demonstrates how context helps avoid lifting state all the way up the tree and threading props down through every intermediate node. Carniato emphasizes that the `App` component remains oblivious to the context data, illustrating a clean separation between state management and UI layout.

Carniato then addresses a common question: “Why not just import a store or reactive signal from a module instead of using context?” While acknowledging that exporting and importing a standalone signal works for simple cases, he explains that context provides hierarchical scoping and automatic disposal. If a consumer uses `useContext`, Solid automatically tracks reactive dependencies within the provider’s lifespan. When the provider’s reactive root is torn down, any child effects or memos automatically clean up, whereas a global signal would persist indefinitely. This hierarchical behavior prevents memory leaks in dynamic component trees. Carniato also notes that using a global import bypasses Solid’s `createRoot` scoping and scheduling, making subtle errors harder to detect, especially in SSR or streaming scenarios. Therefore, although both patterns exist, context remains a more robust, idiomatic choice within Solid’s fine-grained reactive system.

### 00:30:00 - createRoot, Fine-Grained Reactivity, and Disposal

In this chapter, Carniato dives into SolidJS’s core reactive principles—particularly `createRoot` and how it underpins context and component lifecycles. He explains that every reactive computation in Solid (memos, effects) needs to run under a “reactive root” to manage subscriptions and garbage collection. The `createRoot` function effectively establishes a new “inert effect” that can track child computations. Carniato elaborates that when a root is torn down (e.g., unmounting a component or navigating away), Solid automatically disposes of all nested reactive computations within that root. Without `createRoot`, signals and memos could linger indefinitely, causing memory leaks or stale subscriptions. By illustrating how `createRoot` groups effects into hierarchical contexts, Carniato reveals how Solid maintains predictable cleanup without explicit teardown calls.

Next, he addresses initial render challenges: in Solid, component functions run before their DOM nodes are attached, making typical DOM-based context approaches (like custom events in Web Components) impractical. Carniato clarifies that because Solid defers DOM insertion until after reactive computations run, there is no DOM tree traversal available at the time children initialize. Therefore, he couldn’t use DOM events to propagate context as Web Components do. Instead, Solid piggybacks on reactive roots: each component function sets up a reactive root, and context implementation simply walks up Solid’s reactive context chain (a linked-list of roots). This approach allows context lookups to find the nearest provider in the reactive hierarchy without touching the DOM. Carniato’s explanation illuminates why Solid’s reactivity model avoids a virtual DOM and relies on granular computation nodes instead.

### 00:36:00 - Reactivity, createEffect, and Scheduling

Continuing his deep dive, Carniato explains how Solid schedules reactive computations and manages updates. He describes `createEffect` as the fundamental mechanism that registers reactive dependencies between signals. When a signal changes, all dependent effects re-run, but Solid automatically tracks nested dependencies through subscription lists. This subscription graph enables Solid to know exactly which piece of UI to update when state changes, avoiding full tree re-renders. Carniato demonstrates how components in Solid compile down to JavaScript functions that create DOM nodes and wire up signal subscriptions. He highlights that since Solid builds a static DOM structure with placeholders for dynamic content, updates replace only individual text nodes or attributes—no virtual DOM diffing is required.

He also introduces the concept of scheduling: certain computations—especially those that manipulate DOM or side effects—should run only after the initial render phase. Solid’s scheduler ensures that these “after render” tasks execute synchronously once the DOM has been updated. Carniato contrasts this with microtask-based approaches in other frameworks, noting that Solid chooses synchronous delivery to guarantee “glitch-free” UI updates. By explaining how `createEffect` and `createMemo` register dependencies and when they run, Carniato clarifies how Solid’s reactive runtime achieves both high performance and predictable execution. He stresses that context, createResource, and transitions all leverage this core reactivity engine for optimal results.

### 00:42:00 - Comparing Context in React vs Solid

In this chapter, Carniato draws a direct comparison between React’s context API and Solid’s context implementation. He notes that in React, calling `useState` inside a context provider means that updating state forces the provider component to re-render the entire subtree. This default behavior leads to full reconciliation of the virtual DOM for every consumer update—an approach both React and UI libraries mitigate via memoization patterns like `React.memo` and selectors (e.g., in Redux). Carniato explains that while React’s reconciliation is quite fast, constant subtree re-renders can still hamper performance, especially in large applications with frequent context updates. He cites Mark Erikson’s repeated advice that React context should not be used as a drop-in replacement for state management libraries like Redux because it lacks optimizations to prevent unnecessary renders.

By contrast, Solid context carries signals—primitive reactive values—that consumers subscribe to directly. When a signal changes, only those components whose computations use that signal update, rather than the entire provider subtree. Carniato demonstrates that by passing a signal (created via `createSignal`) through context, nested components can call `const [count, setCount] = useCounter()` and react only to changes in `count()`. This design avoids re-running the parent or sibling components of the provider, ensuring fine-grained updates. Carniato emphasizes that this granular behavior is a “win” for Solid because developers can use context without worrying about unwanted re-renders. Ultimately, this chapter reinforces why Solid’s context API offers performance advantages over React’s default approach.

### 00:48:00 - Store Patterns and createStore Abstraction

Shifting focus from context to alternative global state patterns, Carniato presents a “store” abstraction using `createRoot` to encapsulate reactive state without context. He shows a simple module that exports a `createStore` function which calls `createRoot`, invokes a user-provided initializer, and returns a getter function. By doing so, any component can import the store module and call the getter to access the global reactive state. Carniato emphasizes that because `createRoot` scopes reactive computations under a global root, all memos and signals will persist as long as the application is alive, negating the need for explicit disposal. For simpler use-cases—where components need global, shared state without hierarchical scoping—this pattern can be very lightweight.

However, Carniato cautions that using a global store bypasses some safety checks. Solid’s compiler issues warnings if reactive primitives are created outside a reactive root to help developers detect potential memory leaks. By wrapping store initialization in `createRoot`, Carniato ensures that effects and memos created within the store live in a managed context, but developers still must be aware of SSR implications. When server-side rendering, signals created in a global store could persist across requests if not handled carefully. Thus, while the `createStore` pattern can simplify smaller apps, Solid’s context API remains the safer, more idiomatic choice for components that require hierarchical scoping and efficient cleanup. Carniato suggests that, in the future, community libraries like `@solid-primitives/store` could provide more robust store abstractions.

### 00:54:00 - Introduction to Async Patterns and Suspense

With context and store patterns covered, Carniato turns to asynchronous data handling and introduces Solid’s `createResource` primitive. He begins by demonstrating a basic conditional rendering example using `<Show>` to illustrate how Solid updates only the necessary elements when a reactive signal changes. He sets up a `setTimeout` to simulate data arrival, showing how Solid’s fine-grained approach avoids unnecessary component re-execution: only the text node associated with the loading state toggles, with no virtual DOM diff or parent re-render. Carniato highlights that this contrasts with typical React or Vue setups, where parent components re-render before diffing and patching the DOM. Solid’s optimization emerges from converting conditionals into reactive memos that clone and insert the correct nodes as needed.

Next, Carniato examines a “lazy” component example—one where a promise is returned to simulate code splitting. Without using Suspense, the parent component renders “Welcome,” then logs the returned promise for the “Greeting” component and finally mounts the greeting once resolved, all while toggling a simple fallback. However, when Solid’s `<Suspense fallback={...}>` component wraps the lazy-loaded child, the parent immediately suspends rendering “Greeting” until the promise resolves. Carniato shows how Suspense boundaries let parent components choose where to show loading indicators, eliminating the complexity of nested state checks. By placing `<Suspense>` selectively, developers can ensure existing UI remains visible until the async content finishes loading, improving perceived performance.

### 01:00:00 - Lazy Components and Suspense Behavior

Building on the Suspense introduction, Carniato provides a demonstration of lazy-loaded components wrapped in `<Suspense>` to clarify how Solid handles unresolved promises under different boundaries. He shows code where a “Greeting” component is only imported once it’s needed. Initially, the user sees “Welcome” immediately, but then the browser fetches the “Greeting” code asynchronously. Carniato explains that suspense causes the parent component to display a fallback (e.g., a loading indicator) until the lazy-loaded module arrives. He also notes that because Solid resolves the child only once, the entire component tree remains stable, with no need for the parent to re-evaluate unaffected nodes. This reveals how Suspense centralizes loading logic, delegating complexity away from child components.

Carniato further emphasizes that the precise placement of the `<Suspense>` boundary in the component hierarchy dictates which elements are hidden during loading. Wrapping only the dynamic portion of the UI ensures that static parts remain visible, whereas wrapping the entire component tree hides both static and dynamic parts until all data is ready. He stress-tests this by modifying code to wrap different levels of nested components, demonstrating scenarios where “Welcome” stays visible versus disappearing and then re-rendering. By toggling these boundaries, viewers witness how Suspense grants fine control over UX during asynchronous updates, a feature especially valuable for complex UIs with multiple pending states.

### 01:06:00 - createResource for Reactive Data Fetching

Transitioning from Suspense mechanics, Carniato introduces `createResource`, a primitive designed explicitly for reactive data fetching. He explains that `createResource` takes two arguments: a reactive source (often a signal) and an asynchronous fetcher function that returns a promise. In his example, a “user ID” signal drives the resource, and an async function simulates fetching user data from an API. Carniato emphasizes that this pattern mirrors React Query or SWR, separating query parameters from the actual fetch logic. By returning an object containing both data and pending/error statuses, `createResource` simplifies tracking the state of asynchronous operations in a reactive context, enabling Solid to automatically track dependencies for revalidation when the source updates.

Carniato elaborates on design choices: by isolating the asynchronous fetcher outside of the reactive expression, Solid can maintain caching mechanisms and SSR interoperability. For example, during server-side rendering (SSR) with streaming, the server can initiate fetches as soon as the reactive signal becomes available. When the streamed HTML and accompanying serialized data arrive on the client, Solid can resolve the same promises without additional network requests. Carniato notes that this tight integration of reactive signals, resource management, and streaming SSR capabilities forms a core part of Solid’s data-fetching strategy. He concludes by underscoring the importance of context boundaries in tracking pending resource loads under `<Suspense>`.

### 01:12:00 - Suspense Integration with createResource

In this chapter, Carniato details how Suspense and `createResource` collaborate to manage loading states without explicit null checks. He tears down the misconception that Suspense alone catches data-dependent null errors—explaining instead that Solid treats `createResource` as the trigger for suspense. When a resource is read and its underlying promise is unsettled, Solid throws an implicit signal to the nearest `<Suspense>` boundary, which then displays its fallback. Carniato demonstrates that if a component calls `const [user] = createResource(fetchUser)`, accessing `user()` inside JSX under a `<Suspense>` ensures a built-in loading display. If the resource resolves quickly, the fallback never appears; if it takes longer, the boundary flips to show the loading UI until resolution.

He also highlights that multiple `<Suspense>` boundaries can coexist, each reacting only to resource reads within their respective scopes. By strategically placing boundaries around nested components, developers can isolate loading states for specific UI sections; other parts of the page remain unaffected. Carniato walks through code showing two nested `<Suspense>` blocks: one for fetching user info and another for fetching related data. This layered approach lets components decide when and where to show fallback content. Ultimately, Carniato’s explanation cements the idea that Suspense in Solid is context-driven: boundaries respond to reactive resource reads rather than thrown promises.