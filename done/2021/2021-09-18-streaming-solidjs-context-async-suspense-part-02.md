---
showLink: "https://www.youtube.com/watch?v=8Ou6domKfU4"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "Streaming SolidJS - Context, Async, & Suspense"
description: ""
publishDate: "2021-09-18"
coverImage: "https://i.ytimg.com/vi/8Ou6domKfU4/sddefault.jpg?v=61453cfd"
---

### 01:18:00 - Routing Example with Suspense

Carniato pivots to a routing demonstration, showcasing how Solid’s fine-grained reactivity and Suspense integrate seamlessly with dynamic navigation. He constructs a minimalist route switch using Solid’s `<Routes>` and `<Route>` components, mapping paths like `/1`, `/2`, and `/3` to different page components. In each page component, he employs `createResource` to simulate fetching page-specific data (e.g., text content or delay time). He wraps the routed content in a `<Suspense>` boundary, specifying a loading indicator that displays whenever any page’s data requires asynchronous fetching. Carniato illustrates that as users click different route links, Solid updates only the relevant part of the DOM, leaving static navigation elements untouched.

The chapter emphasizes how `<Suspense>` boundaries prevent the entire page from flickering during data fetches. Carniato’s code shows that on each route change, the pre-existing UI remains visible while awaiting new data. Once the resource resolves, the boundary replaces only the placeholder with updated content. He also walks viewers through how resource caching and parameter tracking enable re-fetching only when route parameters change. Because each page component’s fetch logic depends on the route’s ID parameter, Solid automatically re-triggers the resource when the user selects a new route. This real-time example makes clear how combining signals, resources, and Suspense produces smooth, responsive navigation experiences in Solid applications.

### 01:24:00 - Error Boundaries via Context

Shifting from data loading to error handling, Carniato demonstrates how to implement error boundaries in Solid using context. He begins by defining an `ErrorContext` with a `createContext` call, then creating an `ErrorProvider` component that wraps children and monitors for thrown errors. Inside this provider, Carniato uses `createEffect` to catch exceptions thrown by descendants; if any child component throws an error, the provider stores that error in a signal. The provider’s JSX then includes a `<Show>` or `<Switch>` construct to render a fallback UI (e.g., an error message) when an error signal is truthy. By using context, any part of the component tree can throw an error—for instance, by invoking `throw new Error("Test")`—and Solid automatically finds the nearest provider to handle it.

He elaborates that Solid’s reactive roots simplify automatic cleanup: when a component throws an error, its reactive root tears down, disposing of all nested computations and DOM elements. This ensures that memory leaks don’t occur and that after the error boundary displays its fallback UI, Solid can still mount sibling components normally. Carniato compares this to React’s approach, where an entire subtree re-renders under an error boundary. In Solid, because each child registers under a reactive root, errors propagate solely through context-based providers. This design ensures that error handling remains localized, and unaffected parts of the application continue updating normally.

### 01:30:00 - Motivating Transitions with UX Considerations

In this chapter, Carniato introduces UI transitions and explains their significance for improving perceived load times. He contrasts a naïve loading strategy—where any pending state immediately replaces the entire component—with a more user-friendly approach that keeps existing UI visible until new content arrives. Starting with a simple “Loading” indicator example, Carniato shows how Solid’s `<Show>` component toggles content once a promise resolves. He points out that while this approach works, it can feel jarring: the user sees a blank or loading state even if most of the UI was already present. Carniato argues that this conflict is analogous to how browsers handle page navigations, where the user often sees the existing page until the network fetch completes.

He then demonstrates that by placing `<Suspense>` boundaries around only the dynamic segments, developers can preserve static UI elements. In a route-switch example, the navigation bar and header remain visible while the main content fetches. This selective suspense placement prevents “white screens” and improves perceived performance. However, Carniato notes that suspense alone cannot address some edge cases—such as multiple nested resources or rapid user interactions—because each resource read triggers an immediate suspension. To reconcile this, Solid offers “transitions,” a way to mark updates as low-priority. Carniato sets the stage for creating smoother page transitions that mimic the browser’s own behavior: keep old content visible, show a subtle loading indicator, and then seamlessly swap in new content once ready.

### 01:36:00 - Suspense Refinement and UX Patterns

Here, Carniato refines the UX patterns introduced earlier by combining `<Suspense>` with a proper fallback placement to achieve smoother transitions. Using a greeting-switch example—where clicking tabs loads different greetings with variable delays—he illustrates how wrapping only the dynamic greeting component in `<Suspense fallback={<Loading/>}>` allows the static “Hi there!” text to remain visible while the new greeting fetches. Carniato emphasizes that because Solid resolves pending resource reads outside the initial render, the existing UI persists without any flicker or re-render. He contrasts this with a scenario where `<Suspense>` wraps both static and dynamic parts, which unnecessarily hides content that could remain visible during loading.

Carniato elaborates on how inversion of control works in Solid: child components simply read data via `createResource`, and any unresolved promise automatically triggers the nearest suspense fallback. Parent components do not need to perform explicit null checks or track loading flags manually. This design yields a more declarative model: developers wrap regions that may suspend with `<Suspense>`, and Solid handles when and how to show fallback content. Carniato encourages viewers to encapsulate fallback logic consistently—using skeleton screens or subtle progress bars for any dynamic segments. By the end of this chapter, the audience can appreciate how Solid’s reactive scheduling and fine-grained updates work in concert with suspense to deliver polished loading experiences.

### 01:42:00 - Introducing Transitions and createDeferred

In this chapter, Carniato transitions from suspense-based loading to prioritizing performance under heavy computation. He begins by discussing the “tearing” problem, wherein updating many reactive computations across a large component tree can cause temporary inconsistencies in the UI. To illustrate, he references a classic example (sir pinski’s triangle) where thousands of nested triangle components display numbers that update on a timer. By inserting a small artificial delay (e.g., a 5ms spin-wait) in each component’s computation, Carniato demonstrates that a synchronous update across thousands of child components can lead to noticeable jank or partial renders.

To address this, Carniato introduces `createDeferred`—a Solid primitive that breaks up heavy computations across animation frames using a scheduler. He shows code where nested triangle components perform expensive work inside `createDeferred`, which checks if there’s time left in the current frame. If time is short, the computation yields and schedules remaining work for the next idle period. This approach ensures that updates proceed gradually, preventing long-running synchronous blocks from freezing the UI. However, Carniato warns that while `createDeferred` reduces jank, it can introduce inconsistency—some parts of the UI may update slightly earlier than others. To guarantee consistency, he sets up the stage for `startTransition`, which treats updates as low priority but applies changes atomically once all work is done.

### 01:48:00 - Transition Mechanics versus createDeferred

Carniato deepens the discussion on transitions by comparing `createDeferred` with Solid’s `startTransition` API. He revisits the triangle demo, where artificially delayed triangle generations cause staggered value updates. Using `createDeferred` ensures that each component’s expensive logic defers work when the main thread is busy, resulting in a wave-like pattern of updates but potentially leaving the UI in a partially updated state. Carniato acknowledges that this “tearing” might be acceptable in some contexts but unacceptable in scenarios where data consistency at render completion is crucial—such as financial dashboards or mission-critical displays.

He then introduces `startTransition` (and the related `useTransition` hook) to solve tearing. Wrapping a reactive update (e.g., setting a signal that drives many dependent computations) inside `startTransition` causes Solid to create an alternate “fork” of the reactive graph. During this low-priority update, Solid defers effect commits until all dependent computations finish. Once the entire transition completes, Solid applies all DOM updates at once, replacing the old content seamlessly. Carniato shows that with `startTransition`, the resulting UI update appears as a sudden, atomic change rather than a wave of individual patches. This approach avoids inconsistent UI states, as Solid’s granular scheduler ensures that either all pending updates apply together or none do, improving UX without risking jank.

### 01:54:00 - Deep Dive into Transition Scheduling

In this chapter, Carniato elaborates on the internals of Solid’s scheduler and how it supports transitions without a virtual DOM. He explains that when `startTransition` wraps a state update, Solid duplicates the relevant reactive nodes—signals, memos, and effects—creating a parallel dataflow known as an “alternate reality.” As each reactive computation in the transition runs, Solid’s scheduler tracks whether it originates from a transition. If so, Solid holds new DOM nodes or attribute changes in a temporary buffer, rather than applying them immediately. Only after all transition-related computations finish does Solid commit the batched changes, swapping them in place of the old nodes. Carniato contrasts this with React’s fiber-based offscreen rendering, which builds a virtual DOM tree in the background and then reconciles it upon completion.

He stresses that, unlike virtual DOM frameworks, Solid never reconstructs entire tree diffs. Instead, the scheduler intercepts granular DOM mutations until the transition finalizes. This preserves Solid’s hallmark performance: updates target only the minimal set of modified text nodes or attributes. Carniato also touches on how Solid measures frame deadlines—based on requestAnimationFrame and browser heuristics—to decide when to yield work. By dynamically splitting expensive updates into smaller chunks during transitions, Solid ensures that higher-priority user interactions (e.g., scrolling or input events) remain responsive. Carniato’s in-depth scheduler walkthrough clarifies why Solid can offer atomic, consistent transitions without the overhead of a virtual DOM.

### 02:00:00 - Transition Use-Cases and Trade-Offs

Carniato examines practical trade-offs when adopting transitions in production Solid apps. First, he addresses the question: “Do transitions require wrapping every expensive operation in `createDeferred` or `createMemo`?” While `createDeferred` can mitigate jank for computationally intensive tasks, it may still result in partial UI updates mid-transition, which some users perceive as inconsistent. In contrast, `startTransition` guarantees a fully consistent end state but introduces slightly higher latency before any updates appear. He suggests using `createDeferred` for isolated, non-critical computations (e.g., animations or background processing) and reserving `startTransition` for cases where atomic UI updates matter most, such as large data tables or complex visualizations.

Next, Carniato discusses bundle size considerations. He explains that Solid’s compiler and bundler can remove unused scheduler code via tree-shaking. If an application never imports `enableScheduling`, `startTransition`, or `createDeferred`, the scheduler and its dependencies will not be included in the production build. This ensures that small to medium projects remain lean, even though Solid’s runtime supports advanced concurrency features. However, once developers use transitions or deferred computations, the scheduler code is incorporated, potentially adding a few kilobytes. Carniato encourages viewers to evaluate whether transitions deliver genuine UX improvements for their use case before enabling the scheduling APIs.

### 02:06:00 - Real-World Comparisons: React, Vue, and Inferno

Shifting perspective to other frameworks, Carniato compares Solid’s concurrency model with React’s Fiber, Vue’s reactivity, and Inferno’s performance. He recalls that Inferno’s creator, Dominic Gannaway, worked on React’s core and highlights reports that, even after replacing React with Inferno in Facebook’s codebase, real-world performance gains were modest due to complex user code patterns. Carniato emphasizes that Solid’s fine-grained reactivity—avoiding a virtual DOM—paints a different performance picture. While React re-renders entire subtrees (albeit optimized via reconciliation), Solid updates only the smallest reactive fragments. He points out that for large-scale applications (e.g., Facebook), React’s concurrency and server components address unpredictable heavy-lift computations, but for most use cases, Solid’s reactive scheduling may suffice.

Carniato then compares Vue’s template-driven reactivity and composition API. He notes that Vue’s watchers and ref-based signaling work similarly to Solid signals but still rely on a virtual DOM for batch updates. As Vue scales, multiple watchers can trigger complex patching logic, whereas Solid’s direct DOM mutation strategy reduces overhead. He stresses that while framework choice depends on team familiarity, legacy code, and ecosystem, Solid’s approach often yields exceptional performance for both small startups and mid-to-large projects. Finally, Carniato affirms that no single framework perfectly fits all scenarios; understanding underlying mechanics—Fiber, reactivity graphs, or fine-grained scheduling—is critical to making informed architectural decisions.

### 02:12:00 - SSR, Streaming, and createResource Integration

In this chapter, Carniato explores server-side rendering (SSR) and streaming in the context of `createResource`. He explains that during SSR with streaming enabled, Solid can start fetching data on the server as soon as a resource is encountered. Instead of awaiting the promise on the client, the server resolves the data and streams the serialized result alongside HTML over a single HTTP connection. When the client’s hydration code mounts, it observes that the resource promises are already resolved, so no additional network requests occur. Carniato contrasts this with typical hydration strategies where the client must re-fetch data redundantly after the initial HTML loads. By streaming resource results, Solid reduces TTFB (time to first byte) and improves comparative performance on both fast and slow networks.

He also highlights similarities to React 18’s streaming SSR and resource tracking. In Solid’s implementation, `createResource` registers fetches during SSR and tags them as known dependencies that need to be serialized. When streaming, the server serializes only the resource results needed by the client’s immediate render, enabling progressive hydration. Carniato emphasizes how `createResource` provides a unified API for both client-only and SSR scenarios. Because the reactive context on the server mirrors the client’s context, resources remain consistent across environments. This unified design strengthens Solid’s appeal for applications that require dynamic data loading and consistent behavior from server to client.

### 02:18:00 - Data Fetching Patterns: GraphQL and RSCs

Carniato broadens the discussion to include alternative data-fetching and code-splitting paradigms, comparing GraphQL/Relay and React Server Components (RSCs). He notes that GraphQL solves the API fragmentation problem by defining a unified schema that multiple clients (web, mobile) can query. Relay’s fragment approach lets individual components specify exactly what data they need, enabling fine-grained caching and network optimizations. Carniato points out that while GraphQL is powerful, it introduces complexity—clients must manage query definitions, cache invalidation, and type generation. In contrast, RSCs use a server-centric model where component-level data requirements are automatically fulfilled on the server, rendering components to serialized HTML or completing data fetching before streaming to the client. This approach removes the need for explicit API layers, akin to how Solid’s `createResource` can handle data on both server and client transparently.

He discusses trade-offs across app sizes: smaller projects (akin to early-stage startups) benefit from minimal APIs (e.g., `createResource`) that directly fetch data without GraphQL overhead, whereas larger teams (like those at Facebook) may need Relay’s formal querying patterns and caching strategies. Carniato emphasizes that similar to how micro-frontend architectures can offer team autonomy, Solid’s resource approach offers a lightweight alternative for beginning stages. However, as apps scale and require stricter governance and cross-team schemas, more formal solutions like GraphQL or RSCs become attractive. By examining these patterns, Carniato equips viewers with criteria to choose data-fetching strategies aligned to their project’s scale and complexity.

### 02:24:00 - Code Splitting, Component Refactoring, and Scaling

This chapter focuses on code splitting, component refactoring, and scaling strategies. Carniato begins by explaining a common developer journey: starting with a monolithic component that grows complex over time, only to eventually refactor into multiple smaller components. He highlights that premature abstraction can introduce technical debt, but delaying refactoring can also lead to unwieldy codebases. Carniato draws parallels to data fetching: teams begin with simple REST or fetch-based patterns, then often migrate to GraphQL or other solutions as requirements evolve. He reiterates that while early-stage startups might find `createResource` sufficient, they must remain vigilant for signs indicating a shift to more robust data layers as their application grows.

Carniato also discusses custom rendering targets beyond the DOM, such as Canvas or 3D frameworks. He notes that Solid’s reactive primitives could support alternative renderers (e.g., a Solid Canvas renderer). He outlines how Solid’s compiler could produce compile-time hooks—like `renderToCanvas()`—that define a minimal API (append, remove, update) for synchronizing reactive updates with non-DOM targets. This design aligns with Solid’s low-level approach: developers need only implement a small set of adapter functions, and the reactive scheduler handles the rest. Carniato encourages community feedback to refine the universal renderer abstraction, noting that while virtual DOM frameworks typically rely on diff-based updates, Solid’s granular updates could simplify custom render targets without complex reconciliation logic.

### 02:30:00 - Design Philosophies and Framework Selection

Here, Carniato revisits the differing design philosophies behind React, Vue, Svelte, and Solid, stressing that tool choice depends on project needs and team expertise. He reiterates that React’s virtual DOM and fiber architecture shine in large-scale, unpredictable user code scenarios (e.g., Facebook), where concurrent transitions and server components are vital for controlling heavy computations. Vue offers a flexible template-based syntax and robust plugin ecosystem, appealing to developers who prefer clear separation between templates and logic. Svelte compiles reactive statements at build time, achieving impressive performance for many use cases. Solid, Carniato argues, occupies a middle ground: offering JSX familiarity, fine-grained reactivity, and granular updates without virtual DOM overhead.

He also mentions anecdotal evidence from his startups: for projects comparable in scale to Twitter or an Instagram clone, Solid’s performance and minimal boilerplate proved ideal. He explains that Solid’s compiled output remains small—often under 7 KB—because its reactive primitives simply translate to direct DOM mutations. By contrast, larger frameworks often ship more runtime code. Carniato advises that smaller teams unfamiliar with virtual DOM intricacies might benefit from Solid’s declarative reactivity, while larger organizations with extensive React investments might gain more from RSCs and fiber. Ultimately, he encourages developers to understand underlying mechanics—reactive roots, reconciliation, scheduler priorities—when evaluating frameworks to avoid mismatched architectural choices that hamper scalability.

### 02:36:00 - Q\&A: Stores, Context, and Best Practices

In this chapter, Carniato addresses questions from the audience, focusing on store patterns versus context and best practices for using `createRoot`. He reiterates that while developers can import a global `createSignal` directly, doing so bypasses Solid’s reactive root scoping. To avoid compiler warnings and memory leaks—especially in SSR scenarios—he recommends wrapping global stores within `createRoot` so that all nested memos and effects register under a single root that persists for the application’s lifetime. Carniato offers a balanced perspective: use context for hierarchical scoping and component-specific state, and use a `createStore` abstraction for truly global state that never needs disposal until app teardown.

He also responds to concerns about resource-heavy context usage. Carniato clarifies that because context in Solid merely passes signals, there is no appreciable overhead compared to importing signals directly. He encourages viewers to store resources in context when multiple components need consistent data, rather than repeatedly importing the same resource or creating redundant fetches. By sharing personal examples—including caching patterns he explored while experimenting with React Query analogs—Carniato highlights that understanding dependency tracking and reactive lifecycles remains crucial. He concludes that, although Solid offers multiple ways to manage state, each approach has clear use cases: context for scoped dependencies, `createStore` for app-wide state, and `createResource` for data fetching.

### 02:42:00 - Q\&A: contentEditable, MutationObserver, and Custom APIs

Carniato addresses a viewer’s question about using `contentEditable` elements and `MutationObserver` in Solid components. He acknowledges that while Solid’s reactive system can drive DOM updates directly, contentEditable introduces complexities because the browser manages text editing natively. He suggests that developers wishing to bind Solid signals to `contentEditable` should carefully manage cursor position and selection state, potentially using `onInput` events to update signals and using mutation observers for low-level change detection when necessary. Carniato shares that early versions of Solid used timeout-based hacks (e.g., `setTimeout`) to simulate lifecycle hooks like `onMount`, but he recommends preferring Solid’s built-in `onMount` hook now that it’s available.

Next, the conversation turns to Solid’s support for custom renderers—such as Canvas-based graphics or terminal output. Carniato explains that because Solid’s API exposes low-level reactive primitives (signals, memos, effects), custom render engines could be built by implementing a minimal set of insertion and removal functions. For example, a hypothetical `renderToCanvas` might accept element descriptions (e.g., shapes or draw calls) instead of HTML tags. He acknowledges that designing a universal rendering abstraction involves trade-offs—such as whether to perform diff-based updates or redraw entire scenes—but maintains that Solid’s granular update mechanism simplifies many challenges. By the end of the chapter, viewers understand that Solid’s core reactivity is flexible enough to support diverse render targets beyond the DOM.

### 02:48:00 - Q\&A: Universal Rendering and Custom Targets

In this chapter, Carniato contemplates Solid’s potential for universal rendering, where applications might target platforms outside the browser DOM. He recalls his work on Solid Start—Solid’s full-stack app framework—which requires SSR and client hydration. This naturally led him to consider whether Solid could support native platforms (e.g., mobile via React Native–style abstractions) or custom graphics engines (e.g., WebGL, Canvas, or terminal UIs). Carniato reasons that since Solid’s compiler already separates logic from DOM nodes, creating a separate runtime that implements a handful of core functions—such as `createElement`, `insert`, `remove`, and `setAttribute`—should suffice. This means a “Solid Canvas” or “Solid Terminal” renderer could orchestrate reactive updates by mapping signals to custom drawing operations.

He warns, however, that non-DOM targets often have different performance characteristics. For instance, redrawing a 3D scene each frame might require batching more aggressively than a fine-grained DOM update. Consequently, anyone building custom renderers must carefully balance feature-support (e.g., transitions, suspense) with the constraints of the target environment. Carniato acknowledges initial implementations might skip advanced features (e.g., no suspense or transitions) to keep the core small. He invites community input on essential primitives for universal rendering, encouraging viewers to think about how best to generalize Solid’s reactivity for diverse execution contexts.

### 02:54:00 - Closing Remarks and Future Streams

As the livestream draws to a close, Carniato transitions to final remarks and an anecdote from his past as a musician. He likens live streaming and developer presentations to playing small gigs: even if only a few people tune in, presenters must perform at full energy for those who do show up. He shares memories of touring Canada as part of a punk-pop band, where empty venues still required delivering an enthusiastic performance. This analogy reinforces his belief in maintaining engagement and thoroughness, regardless of audience size. Carniato thanks participants for their questions, notes that he’ll continue hosting SolidJS streams, and invites community feedback on future topics—such as more in-depth SSR demos or custom renderer prototypes.

Before signing off, Carniato briefly recaps key takeaways: Solid’s context API leverages `createRoot` for robust hierarchical state; `createResource` integrates seamlessly with Suspense and streaming SSR; transitions and `createDeferred` address jank by scheduling reactive updates; and Solid’s scheduler and granular reactive model offer performance benefits without a virtual DOM. He hints at future sessions exploring image sinks, CSS-in-JS patterns, or more advanced SSR scenarios. With heartfelt gratitude, Carniato concludes the nearly three-hour stream, encouraging viewers to experiment with Solid’s primitives, ask more questions, and stay tuned for upcoming deep dives.