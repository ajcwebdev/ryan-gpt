---
showLink: "https://www.youtube.com/watch?v=u2MCb7k3hoI"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "So Long Silicon Valley!"
description: ""
publishDate: "2025-05-30"
coverImage: "https://i.ytimg.com/vi/u2MCb7k3hoI/maxresdefault.jpg"
---

## Episode Description

Ryan Carniato reflects on relocation, SolidJS 2.0 progress, deep framework comparisons (React, Angular, Astro, etc.), and evolving frontend paradigms over a 3½-hour livestream.

## Episode Summary

In this extensive livestream, Ryan Carniato begins by updating viewers on his move from San Jose to Portland while briefly chatting about weather and family routines. He dives into creating concise educational videos about JavaScript frameworks, discusses SolidJS’s reactivity model, and analyzes how many developers lack foundational understanding of underlying abstractions. Carniato examines Angular 20’s enhancements (signals, zoneless mode, resource APIs) and explores emerging trends in frameworks (SSRs, islands, IR, AI influences). He shares his work on SolidJS 2.0’s server‐rendering architecture—demonstrating parallel asynchronous rendering without waterfalls—and details conversations with teammate Milo about push‐based reactivity. The stream includes in‐depth commentary on React’s identity crisis, “Last Framework” rhetoric, Remix’s fork from React (Preact), and ecosystem dynamics involving Solid, Astro, and TanStack. Throughout, Carniato balances technical deep dives with personal insights on teaching, developer culture, and the future of web development.

## Chapters

### 01:50:00 – 01:59:59  Immediate Mode vs. Retained Mode and Mobile/Graphics Influences

In this section, Ryan likens web UI frameworks to graphics paradigms: “immediate mode” (drawing each frame directly) versus “retained mode” (maintaining a scene graph for incremental updates). He reveals his background in video game graphics—writing shaders for GPUs and building immediate mode interfaces—fueling his dissatisfaction with retained mode solutions like React’s virtual DOM. While React’s retained DOM lets devs “just rerender everything,” Solid’s compile-time reactivity channels an immediate-mode mindset on the web: tiny, direct DOM updates without reconstructing entire trees. Ryan underscores how compiled reactive primitives in Solid resemble efficient graphics pipelines, reducing needless work. He contrasts this with React’s push toward compilers (JSX transforms, RSCs) as a sign that virtual DOM’s limitations persisted and required radical shifts.

He explores cross-platform implications: Solid’s zero-abstraction reactivity and compiler outputs theoretically enable universal rendering on mobile (React Native, NativeScript) or desktop (Electron) without additional overhead, whereas React’s ecosystem demands bridging with React Native’s specialized runtime. Ryan describes experiments with Solid Universal and mentions community efforts (like Svelte Universal) adopting Solid design. He argues that no framework is inherently tied to a browser; instead, reactivity models and compile targets dictate adaptability. As React struggles to maintain roots in the DOM, immediate-mode principles gain traction—particularly for server rendering where pure pull-based execution short-circuits complex push-pull cycles. Ultimately, he champions narrowing the chasm between graphics and web UIs by embracing immediate-mode reactivity for predictable, performant updates.

### 02:00:00 – 02:09:59  Solid’s Design Philosophy: Ergonomics vs. Simplicity

Ryan revisits Solid’s core design principles: championing simplicity by removing abstractions (no virtual DOM) while preserving developer ergonomics with JSX and intuitive reactive primitives. He recounts how Solid’s memos, signals, and stores emerged to close the gap between user-friendly syntax and high performance. Contrasting Solid’s path with frameworks like Vue or Svelte—built to simplify React’s complexity—Ryan stresses Solid’s explicit rejection of “dumbing down” usage in favor of deeper architectural transparency. While frameworks often layer abstractions to mask complexity (e.g., Vue’s Options API hiding reactivity details), Solid opts for minimal indirection so developers interact with a direct reactive graph, reducing “magic” at runtime.

Citing Angular’s incremental adoption of signals, Ryan explains how various frameworks converge conceptually—steering away from large runtime overhead to compile-time primitives that preserve or exceed VDOM performance. He notes React’s detour into compilers (Concurrence Mode, RSCs) ironically aligns with Solid’s founding vision: forgoing abstraction layers to operate directly on DOM to achieve ultimate speed. Yet Solid remains committed to balancing performance with straightforward APIs: createSignal, createEffect, createResource. Ryan warns that further abstraction often sacrifices clarity, citing React’s “escape hatches” (useEffect, useMemo) as indicators that abstractions leak. By staying close to the DOM’s retained-mode update patterns, Solid offers a transparent, predictable mental model—empowering developers to reason about fine-grained updates without memorizing opaque lifecycle semantics.

### 02:10:00 – 02:19:59  Solid Ecosystem, Shad CN, and Third-Party Integrations

Shifting focus to Solid’s ecosystem, Ryan spotlights Solid Store (2 KB), Solid Start (Solid’s full-stack meta-framework), and Solid’s community-built UI libraries (e.g., ShadCN’s port to Solid). He describes how Solid Store introduced projections—efficiently splitting reactive graphs for localized updates—whereas Solid’s underlying signals model handles state propagation. He mentions upcoming improvements in Solid Base (a headless UI library akin to RadixUI) and ShadCN’s design system integration, praising community members like Nikhil and Jack Harrington for contributions. Although Solid’s small market share shrinks available third-party packages, Ryan is buoyed by projects like ShadCN, Astro integration, and community adapters for Deno, Fresh, and Svelte 5’s prospective adoption of Solid’s reactive model.

He contrasts Solid’s ecosystem growth with React’s vast but often uncoordinated library landscape. Because Solid focuses on minimal abstractions, it lacks the “batteries-included” soft wallet React and Angular boast, but this minimalist stance fosters composability and lean bundle sizes. Ryan notes that while migrating existing React libraries to Solid usually requires slight adaptations (e.g., context bridging, adjusting JSX transforms), Solid’s universal renderers ease porting to non-DOM targets (mobile, desktop, IoT). He conjures a vision where every JavaScript environment can target a single reactivity model, reducing fragmentation—especially as frameworks like Svelte and Angular adopt signals. Ultimately, Ryan reaffirms that Solid’s ecosystem may remain lean, but it prioritizes performance, clarity, and direct alignment with JS fundamentals.

### 02:20:00 – 02:29:59  The Perils of React Ecosystem Entrenchment

Here Ryan addresses the “React ecosystem bubble” phenomenon—wherein React’s popularity sustains a self-perpetuating cycle: more tutorials, libraries, and job postings reinforce React’s dominance. He warns that React’s “winners write history” narrative often erases alternative frameworks’ innovations (e.g., Knockout, Ember, AngularJS). Ryan recounts how early DOM-manipulation techniques (e.g., Backbone, jQuery) morphed into VDOM solutions across frameworks; while React popularized these ideas, it did not invent them. He argues this behavioral bias pushes many devs to prematurely dismiss non-React options, fearing job insecurity or unfamiliarity. However, Ryan cites Solid’s adoption of signals to demonstrate that ecosystems outside React can accelerate progress—evident as Angular, Svelte 5, and other frameworks conform to Solid’s reactive primitives.

Next, he explores the “bundler first” debate: framework creatives like Ryan Florence and Kent C. Dodds embrace server-centric tooling (bundled server functions, AI-first architectures), while others build “no-bundler” solutions. Ryan clarifies that while bundlers streamline modern workflows, overreliance perpetuates complexity. He contends that as the web matures, developers should insist on frameworks that prioritize platform APIs (Fetch, Streams, WebSockets, Web Workers) over heavy bundling. Yet React’s inertia—backed by Meta resources—resists fundamental changes, meaning the ecosystem remains tethered to React’s baggage: large node modules, extensive compilation steps, and multiple “React ways” to do the same task. He concludes that challenging this dominance requires incremental wins (like migrating Angular to signals or introducing lean meta-frameworks) rather than overnight revolutions.

### 02:30:00 – 02:39:59  Mascots, Logos, and Community Culture

Returning to community aesthetics, Ryan revisits the concept of framework mascots—highlighting some of the most memorable icons: Angular’s angelfish, Ember’s hamsters, and Solid’s early snake logo (retired due to negative connotations). He displays camera shots of Angular’s 3D fish variations, remarking on nostalgia for the mid-2010s when every library sported a distinct animal mascot. Audience members share Discord memes comparing logos (Solid’s duck-like emblem), and Ryan jokes that Solid’s initial snake invoked “Metal Gear Solid” imagery. He speculates about Deno’s dinosaur, Astro’s hamster “Houston,” and how mascots serve as brand differentiators, enhancing developer affinity and marketing appeal—especially as frameworks push niche features like signals, islands, or compiler integrations.

Moving on, Ryan uses mascots as a springboard to discuss community culture: how shared artifacts (logos, mascots, Docs) cultivate a sense of belonging or exclusivity. He notes React’s bare-bones iconography versus Vue and Angular’s vibrant mascots, tying this to broader strategies: frameworks that craft an approachable, memorable brand often draw newcomers more readily. Yet he cautions that aesthetics alone cannot drive adoption; substantive technical benefits (e.g., performance, clarity, DX) must complement branding. Drawing parallels between music subcultures and developer subcommunities, Ryan asserts that while mascots foster initial interest, long-term success hinges on consistently delivering value—highlighted by Solid’s emphasis on minimal abstractions and fine-grained reactivity.

### 02:40:00 – 02:49:59  Angular 20 Deep Dive: Resource API and Developer Ergonomics

Revisiting Angular 20’s announcements, Ryan unpacks how Angular’s new resource API (“Http resource”) simplifies data fetching by automatically inferring parameterized routes. He demonstrates code where developers need only provide a fetch function, while Angular handles state transitions (loading, success, error) and caching beneath the hood. Ryan compares this to Solid’s createResource and TanStack Query integrations, observing that Angular—traditionally TypeScript-heavy—now embraces signals and resource patterns reminiscent of modern React and Solid workflows. He praises Angular’s approach for lowering boilerplate: developers no longer juggle separate controllers, models, and manual subscriptions; instead, they define resource dependencies declaratively within component templates, letting Angular’s change detection streamline updates.

Beyond resources, Ryan examines Angular’s “zone-less” shift: migrating from Zone.js–powered global detection to signals triggered only by explicit changes. He notes that Angular’s retained mode (incremental DOM) benefits from signals’ granular updates, reducing unnecessary checks. This delivers significant performance improvements for large enterprise applications—development teams no longer pay a heavy price for every click or timer. Ryan highlights Angular Material’s role, noting how Angular’s core and UI libraries now integrate natively with signals, yielding cohesive DX and performance gains. He concludes that Angular’s evolutionary trajectory—balancing stability, community expectations, and new reactive foundations—framed a blueprint for other large frameworks pondering how to modernize without alienating existing codebases.

### 02:50:00 – 02:59:59  React’s Last Framework Revisited: AI Impacts and Futuristic Predictions

This chapter revisits Theo’s assertion that AI will cement React’s supremacy. Ryan dissects the argument: AI models trained primarily on React code create feedback loops where new developers disproportionately produce React‐centric output, reinforcing React’s dominance. Yet he counters that AI hyperbole often overestimates stagnation: that “React today trumps React tomorrow” presumes that AI cannot learn novel patterns or that ecosystems can’t shift. Ryan likens React to an indie band that “sold out”—fearing that React’s developer appeal erodes as abstractions proliferate. He questions whether React’s path is sustainable if AI or compiler‐based tools demand new paradigms: if AI first frameworks require immediate-mode reactivity, can React adapt accordingly?

Drawing upon his own “Fallout with React” draft, Ryan shares that he once accepted React’s spirituality—only to feel disenfranchised when subsequent Meta-led features (RSCs, the React compiler) diverged from his mental model. He speculates whether React’s core team can reconcile React’s historical philosophy with emerging AI paradigms, streaming architectures, and universal rendering goals. As React bifurcates into multiple sub-frameworks (Next.js, Remix, React Native), Ryan warns that identity dilution risks developer disillusionment. He ends by challenging developers to stay vigilant: not to assume AI guarantees React’s reign forever, but to continue exploring alternative reactive architectures that align closely with evolving platform capabilities—citing Solid, Svelte, and unbundled meta-frameworks as fertile ground.

### 03:00:00 – 03:09:59  Solid vs. React: Application Switches and Community Dynamics

At the three-hour mark, Ryan examines app migration challenges: how developers locked into React’s ecosystem face intricate migration hurdles when considering Solid or Svelte. He recalls building Solid universal renderers (Solid DOM, Solid Native) and porting Solid to Deno and Fresh—achieving cross-platform compatibility with minimal friction. Conversely, he points out that Remix’s decision to fork Preact—despite promising to “stay close to React”—might antagonize existing community members who feel forgotten. Ryan explains that while Solid has a small niche, its code familiarity (JSX) eases onboarding for React devs, though they must learn new reactive primitives (createSignal, createEffect).

He also addresses the “ecosystem pull” phenomenon: React’s vast library stability, robust IDE tooling, and Meta’s resources create a gravitational pull that’s hard to escape. Yet Ryan highlights that enterprise-scale Angular teams rapidly embraced signals once Angular 16 implemented them—a sign that large organizations can pivot toward modern patterns when dependencies shift. By contrast, React’s monolithic inertia makes “going React” a default instead of a studied choice. He contends that Solid’s migration story is feasible precisely because Solid shares many idioms with React yet strips away unnecessary overhead—enabling incremental adoption inside a React codebase through signal wrappers. Ultimately, he asserts that community endorsement—through conference talks, podcast episodes, and library contributions—is vital to break React’s hegemony.

### 03:10:00 – 03:19:59  React-to-Preact Fork: Remix’s Strategic Shift

This chapter centers on Remix’s May 20 commit—briefly visible before removal—revealing its intent to fork Preact, abandoning React dependency. Ryan highlights that Preact, originally a lightweight React alternative, offers similar JSX semantics with a minimal codebase (≈3 KB gzipped) but lacks React’s extensive ecosystem support. Remix’s fork signals a departure from React’s evolving constraints: forgoing class components, recalibrating DOM APIs, and eliminating unneeded abstractions. Yet Ryan cautions: such a fork will likely lead to significant “compat” work—rewriting React-specific lifecycles, migrating existing React Router integrations, and reimplementing essential features like Suspense. He suggests Remix aims to trim the developer experience overhead, shedding features like RSCs, App Router complexity, and bundler dependencies (favoring Rollup or Bun), to build a server-driven, island-style framework.

Next, he speculates on broader ecosystem effects: Shopify’s Hydrogen initially embraced React Server Components for storefront building, but Remix’s pivot may prompt Shopify to reconsider its own custom React-based solutions. Carniato foreshadows that many React devs will face awkward transitions when their team’s code relies on subtle React lifecycle behaviors—now running on a Preact fork that intentionally diverges. While Preact’s simplicity appeals to Remix’s goal of “model-first, build on web APIs, minimal runtime,” he foresees community pushback: longtime React proponents will criticize fragmentation, lament lost compatibility with established tools (DevTools, profilers, hMR), and question the viability of maintaining two separate ecosystems. Ryan concludes: Remix’s bold break might free them from React’s technical debt but risks alienating the mainstream React base, leaving smaller pockets of passionate adopters.

### 03:20:00 – 03:29:59  Ecosystem Ramifications and Developer Psychology

During this time, Ryan reflects on the psychological toll of framework fragmentation—how devs mourning React’s simplicity now grapple with fractured paradigms like Preact forks, multiple server rendering modes, and AI tooling hype. He muses about “React mental model” nostalgia: many devs never understood React’s inner workings (hooks, virtual DOM, fiber reconciliation), so shifting from React to a Preact fork feels like cleaning up under the rug instead of bringing foundational clarity. Ryan predicts that ambitious Remix features—like advanced streaming, data mutations via server functions, or AI-integrated components—will initially energize early adopters but eventually collide with practical constraints: inconsistent community tooling, unpredictable upgrade paths, and scarce ecosystem support outside React’s “blessed” circle.

He examines how Remix, by shedding React’s ballast, aims to recapture “what we loved about React” (modularity, composability) while discarding unnecessary overhead. Yet Ryan cautions that if Remix loses backward compatibility, many React-dependent enterprises (with massive monorepos, extensive CI/CD pipelines) will hesitate to change. In turn, smaller teams might probe Remix’s lightweight model—but often prioritize shipping features over battling core infrastructure changes. This dynamic widens the chasm between tool haves (large players with dedicated engineering) and have-nots (indie devs and startups relying on community-approved solutions). Ultimately, Ryan anticipates a “long tail” of micro-frameworks coexisting alongside React’s colossal footprint, with SolidJS poised to attract curious frontiersmen seeking performant, transparent reactivity.

### 03:30:00 – 03:30:21  Final Reflections and Future Outlook

As Ryan nears three and a half hours, he reiterates that Remix’s move—forking Preact, eliminating React dependencies, and betting on server functions, streaming, and AI-first features—marks a pivotal moment in JavaScript’s ongoing evolution. He acknowledges that while Remix’s technical merits (smaller core, faster cold starts, no class components) may appeal, carving out a distinct niche from React entails significant growing pains: broken tooling, incompatible libraries, and developer reluctance. Nonetheless, Ryan expresses optimism: transitions like this spur reflection on fundamental paradigms—forcing both framework authors and users to reassess assumptions about reactivity, rendering, and full-stack integration.

Concluding the stream, he confesses excitement for SolidJS 2.0’s fresh reactivity engine, Milo’s push-based innovations, and Solid’s ingrained philosophy of simplicity with high performance. While acknowledging the mammoth challenge of dislodging React’s entrenched ecosystem, Ryan remains steadfast that incremental progress—through community education, framework interoperability (ASTRO, TanStack, Deno), and exposing under-the-hood mechanics—will gradually erode React’s unchecked dominance. With the Plexiglas between “React world” and “Solid world” cracking wider, he invites viewers to stay curious, experiment with emerging patterns, and contribute to shaping the web’s next chapter beyond React’s once-insurmountable precipice.