---
showLink: "https://www.youtube.com/watch?v=u2MCb7k3hoI"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "So Long Silicon Valley!"
description: ""
publishDate: "2025-05-30"
coverImage: "https://i.ytimg.com/vi/u2MCb7k3hoI/maxresdefault.jpg"
---

## Episode Description

Ryan Carniato reflects on relocation, SolidJS 2.0 progress, deep framework comparisons (React, Angular, Astro, etc.), and evolving frontend paradigms over a 3½-hour livestream.

## Episode Summary

In this extensive livestream, Ryan Carniato begins by updating viewers on his move from San Jose to Portland while briefly chatting about weather and family routines. He dives into creating concise educational videos about JavaScript frameworks, discusses SolidJS’s reactivity model, and analyzes how many developers lack foundational understanding of underlying abstractions. Carniato examines Angular 20’s enhancements (signals, zoneless mode, resource APIs) and explores emerging trends in frameworks (SSRs, islands, IR, AI influences). He shares his work on SolidJS 2.0’s server‐rendering architecture—demonstrating parallel asynchronous rendering without waterfalls—and details conversations with teammate Milo about push‐based reactivity. The stream includes in‐depth commentary on React’s identity crisis, “Last Framework” rhetoric, Remix’s fork from React (Preact), and ecosystem dynamics involving Solid, Astro, and TanStack. Throughout, Carniato balances technical deep dives with personal insights on teaching, developer culture, and the future of web development.

## Chapters

### 00:00:00 – 00:09:59  Introduction, Relocation, and Stream Setup

Ryan opens by apologizing for starting late after engaging in a lively BlueSky discussion with Dan Abramov, then introduces his current situation—recently moved from San Jose to Portland. He describes his family’s morning routine, mentions returning from his daughter’s school drop‐off, and explains that he’ll keep the session shorter than usual due to a half-day schedule. Ryan reflects on San Jose’s scorching summer heat compared to Vancouver’s milder climate, making light of American weather preferences. After joking about his microphone’s volume, he shifts into sharing his screen somewhat haphazardly to outline topics he’s prepared to cover, apologizing for being disorganized. He lists themes like React’s latest frameworks, push-based reactivity, and upcoming discussions with Milo, then briefly acknowledges recent articles by Dan Abramov on server functions and mentions interest in Remix, Astro, and Angular 20 updates. Throughout, Ryan balances casual banter—toggling between Twitch and browser windows—with genuine enthusiasm, setting a dynamic, conversational tone for the rest of the stream.

As he moves among windows, Ryan touches on his surprise at never needing to work from eBay’s physical office after being hired in early 2020, highlighting remote work norms. He shares a glimpse of his last day in his current office, musing that the office background could remain on future streams even after he moves. While projecting his desktop, he solicits audience input about what to discuss, touching on short‐form videos he’s made, solid 2.0 development, and Angular 20’s announcements. He remarks on balancing video lengths—some preferring under 30 minutes—before pivoting to demonstrate his streaming setup struggles (audio adjustments, multiple chat windows). The segment wraps as Ryan decides to start with shorter videos, setting up a fluid, unscripted environment where viewer interaction steers the conversation, marking an unpolished but endearing kickoff.

### 00:10:00 – 00:19:59  Short-Form Videos, Hikes, and SolidJS Intro

At around ten minutes in, Ryan segues into discussing the success of his recent short-form educational videos on JavaScript frameworks. He notes viewers’ positive feedback contrasting longer videos that may lose focus; the shorter clips (e.g., an 11-minute “Introduction to JavaScript Frameworks”) have garnered attention for distilling core concepts. He explains how one video outlines three methods of rendering the DOM—virtual DOM, string templates (dirty checking), and hyperscript—based on his earlier article “The Fastest Way to Render the DOM.” Ryan reveals a behind-the-scenes anecdote about capturing a scenic shot of Santa Teresa Park in San Jose (rocky ridge trail, green meadows, California poppies), illustrating where his cover image originated. He highlights that while many viewers fixate on bigger‐picture topics like React vs. Solid, some appreciate that visual break reminiscent of outdoor excursions.

Gathering momentum, Ryan introduces SolidJS’s official five-minute “Intro to Reactivity” video, praising Attila for structuring a compact demo showcasing JSX, fine-grained updates, and Solid’s unique reactivity. He recounts criticisms—viewers mistaking it for a React tutorial or refresher on hooks—and the realization that most developers lack mental models of how frameworks update the DOM. Ryan laments that average devs often treat libraries as black boxes, copying code without grasping underlying mechanics (comparing React’s virtual DOM diff cycles, component rerenders, useEffect semantics). He stresses the importance of learning fundamentals—knowing how your tool actually works—even if one cannot build the entire framework from scratch. Viewers chime in, highlighting confusion around signals vs. fine-grained updates, and Ryan acknowledges the need for tiered educational content: pieces for complete beginners, intermediates familiar with React, and advanced devs seeking under-the-hood clarity.

### 00:20:00 – 00:29:59  React vs. Solid, Developer Understanding, and Angular Mascots

This segment begins with a deeper comparison between React and Solid, sparked by viewer comments on how easy it is to conflate Solid’s approach with React’s hook patterns. Ryan contends that simply adding signals to React does not replicate Solid’s performance model, which removes the virtual DOM entirely for true fine-grained reactivity. He imagines library authors confronted with decisions: add abstractions for ease‐of‐use (as Vue and Svelte did) versus maintain minimal underlying layers. Citing anecdotes from React’s evolution—transition from class components to hooks—Ryan observes React gradually compromised on the retained-mode DOM’s advantages in exchange for ergonomic developer experience. He draws parallels with knockout.js and AngularJS, celebrating Pete Hunt’s early demos of React’s virtual DOM but warning that performance trade-offs were masked by marketing hype (“React is fast!”) despite virtual DOM’s inherent slowness compared to direct DOM manipulation. Ryan issues a caution: if developers don’t understand fundamentals, they’ll be seduced by flashy demos, missing core trade-offs.

Pivoting to Angular’s community, Ryan visits the topic of mascot design: sharing various angular fish logos (including “angelfish”) and pondering whether mascots are making a comeback in the JavaScript landscape—a trend last common in the 2010s (e.g., Ember’s hamster). He jokes about Solid’s first snake logo (referencing “Solid Snake” / “Metal Gear Solid”), then reluctantly replaced due to negative cultural connotations around snakes. Viewers contribute mascot suggestions for other frameworks (Deno’s dinosaur, Astro’s Houston the hamster). This lighthearted break preludes a serious dive into Angular 20: Ryan recaps its release at Google I/O, noting Angular’s “zoneless” shift—transitioning from Zone.js–powered dirty checking to a signals‐based incremental change detection—and new resource APIs for simplified data loading (akin to Solid’s resource API or TanStack Query). He highlights Angular’s embrace of modern tooling and component‐level caching (“HP resources”), celebrating its alignment with evolving web standards.

### 00:30:00 – 00:39:59  Angular 20: Signals, Zoneless, and Resource APIs

Ryan climbs deeper into Angular 20’s advancements. He stresses that while AngularJS used zone-based change detection—intercepting every async event, DOM event, and timer to trigger global checks—Angular 20 relies on a new signals API to propagate updates directly to affected components, reducing overhead. He compares the old “check everything” model to polling, then “check on event” (closer to old Angular), moving to React’s “check on setState,” then Solid’s “signal propagation,” explaining why Angular’s shift to zoneless signals is a huge architectural win. As Angular transitions into a finer-grained model, Ryan notes that Angular 16’s stable signals and effect linked list creations laid the groundwork; Angular 20 now makes these stable to use in production apps. He underscores improved “HTTP resource” abstractions that let developers fetch URL‐based data (params and loader integration) with minimal boilerplate, analogous to Solid’s createResource or TanStack Query.

Ryan also highlights templating improvements: enhanced host bindings, VTest integration, and more “modern tooling” support—tying into Angular Material, CKEditor, and experimental frameworks like Vite. He remarks on Angular’s cohesive ecosystem—treating Angular Material as a first-class citizen alongside the core framework, unlike Solid where UI libraries are community-driven—and acknowledges new framework icons (mascots) and a refreshed marketing approach that tries to reduce reliance on RxJS. Despite Angular’s complexity, Ryan is bullish on its trajectory, praising the framework’s commitment to migrating from \$’s older zone-based semantics to a reactive, signal-driven core. He closes by noticing Angular’s shift feels more deliberate and developer-friendly, though still steeped in TypeScript and opinionated structure.

### 00:40:00 – 00:49:59  React “Last Framework” Controversy and Identity Crisis

At approximately 40 minutes, Ryan responds to Theo’s “React is the last framework” video, which posits that AI‐trained models, React’s entrenched ecosystem, and surging popularity make React virtually unassailable. He clarifies: React did not build the “streets”—the web platform did—so improvements in bundlers or virtual‐DOM optimizations cannot replace inherent DOM limitations. While Theo’s auto manufacturer analogy compares car chassis width to web abstractions, Ryan counters that React didn’t pioneer JavaScript frameworks or declarative templates; frameworks like Knockout and AngularJS predated it. He concurs that AI might entrench React further—suggesting that AI models trained heavily on React code may bias new developers toward React—but warns that this view risks complacency. Ryan urges developers to recognize that some abstractions should be removed entirely rather than continually optimized (citing Solid’s removal of the virtual DOM).

He also touches on bundler debates—React’s slow adoption of Vite compared to Next.js, Remix, and others—and how promises of future React compilers or server components kept many locked in, even though underlying constraints remained. Surprise emerges: despite React’s canonical role, Carniato believes architectural shifts—like ASTRO’s HTML-first, island-based sites, Solid’s granular reactivity, and TanStack’s hybrid models—present compelling alternatives. He laments that the dominant narrative often credits React with inventing patterns that earlier frameworks pioneered. Throughout, Ryan mixes technical critique (React’s pipeline, hydration mismatches, server component trade-offs) with personal frustration: he feels React’s “loss of identity” as it morphs into Meta’s bundled ecosystem, losing modularity and clarity. The discussion humanizes Ryan’s own struggle balancing optimism for React’s evolution against disappointment over unfulfilled promises.

### 00:50:00 – 00:59:59  React Evolution, Performance, and Framework Narratives

Continuing the React critique, Ryan explores how React’s successive abstractions—class components, hooks, concurrent mode, and server components—have drifted away from its original “just JavaScript” philosophy. He recounts the shock of discovering React would be optimized by compilers, moving it farther from straightforward paradigms he once appreciated. Drawing on anecdotes about Next.js’s announcement being hailed as “React 18,” he observes React fracturing into multiple tools (Next, Remix, RSCs, the React compiler) that now define React’s future more than React itself. While acknowledging that React’s innovations (unidirectional data flow, JSX, the virtual DOM) made building large SPAs feasible, Ryan underscores that subsequent improvements often retrofitted around existing limitations rather than rethinking fundamentals. His fear: React now celebrates incremental improvements when what’s needed is architectural reinvention.

He compares this to indie music: some artists “sell out,” pivoting to mainstream appeal while abandoning their founding ethos. In a parallel vein, Carniato argues that React’s spirit is diluted by Meta’s strategic direction—server-centric models and platform-driven tooling—rather than community‐driven leaps. He notes that React’s abstractions have become so layered that new developers lack visibility into how the framework actually works, risking a generation of coders who treat React as magical black‐box code generators. Ryan reiterates that understanding fundamentals (retained DOM, direct DOM manipulation, lazy vs. eager reactivity) is crucial, even if one never builds a framework personally. Ultimately, he frames React’s narrative as one of “magic” for most developers, where deep mechanics are obscured under layers of Meta-led optimizations.

### 01:00:00 – 01:09:59  Jane Street, Signals, and Push-Based Reactivity

In this hour segment, Ryan dives into reactivity theory—highlighting inspiration from Jane Street’s OCaml library “Incremental,” which powers massive financial UIs via a dynamic, dependency-tracking graph. He explains that server rendering with signals can bypass expensive push-pull cycles by adopting pure pull-based execution: collect promises during initial render, await resolution, then re execute dependencies. By mapping Solid’s reactivity to a directed graph, Ryan shows how “push-based” systems—where changes immediately propagate down precomputed dependency depths—can eliminate multistage revalidation. He applauds Milo, a Solid core contributor, for devising a push-only approach that resolves the diamond-dependency problem without fallback to pull or manual flags, achieving performance gains over Solid’s existing alien signals model in many benchmarks.

Ryan recounts how he prototyped “runOnce” async parallel rendering: three nested components fetching data in series or parallel—both completing in the slowest network latency rather than cascading. He demonstrates that Solid’s 2.0 server renderer now leverages this model, enabling nested async components to fully resolve in parallel during SSR. While recovering hydration, he notes exceptions remain around error boundaries and lazy loading. This new architecture, he posits, can unify Solid’s 1.0 and 2.0 primitives—providing a simpler, faster, and more predictable reactivity engine. As he charts the evolution from push-pull-push to push-only, Ryan reveals how core reactivity redesigns accelerate Solid’s next generation, offering insights into graph theory, lazy vs. eager scheduling, and the ideological alignment with OCaml’s incremental approach.

### 01:10:00 – 01:19:59  SolidJS 2.0 SSR Progress and React Controversy

Resuming his SolidJS 2.0 updates, Ryan shares that after demonstrating runOnce async prototypes, he integrated them into a SolidJS 2.0 branch—implementing “first‐render promise collection,” streaming SSR, and fully functioning hydration (except for error boundaries and lazy imports). He describes the mechanics: instead of notifying every change (push-pull-push), the graph collects promise dependencies, awaits resolution, and then pulls values down in one pass. This “pure pull” approach removes intercomponent notifications on the server, streamlining SSR. He also notes signals and transactions still remain in play, but eager scheduling simplifies memoization and reduces complexity. Momentum builds as he celebrates Solid 2.0’s potential to match or exceed alien signals performance while shrinking the reactive graph.

Mid-hour, Ryan pivots to reflect on live community interactions: teasing what he’ll discuss with Milo in future streams, noting it’s a pivotal moment before Solid 2.0 shifts from prototype to alpha. Yet his excitement is tempered by parallels to React’s bundler controversies: years of React Core reluctance to fully embrace Vite resulted in create-react-app’s deprecation meltdown. He explains how React’s slow migration to modern tooling spurred frustrations—evident when remix and TanStack community members grew disenchanted with React’s monolithic path. Ryan reminds viewers that React’s entanglement with Meta’s roadmap—streaming, server components, the React compiler—betrays its original simplicity, urging healthier skepticism of “future fixes” that promise to solve architectural issues React itself doesn’t address.

### 01:20:00 – 01:29:59  Ryan’s “Fallout with React,” Angular and AI Musings

At the halfway point, Ryan unveils a previously private “Fallout with React” draft—originating from frustration after Theo’s “Last Framework” video and remix’s bundler fork controversy. He quotes his own reflections: React no longer feels “made for me” as new features (RSCs, isomorphic SSR) demand monolithic adoption rather than opt-in integration. He recounts when Andrew Clark declared Next.js 13 “real React 18,” marking React’s “jumping the shark” moment. With React morphing under Meta’s incantations, Ryan worries new features aren’t uniformly beneficial: server components clash with SPA architectures, and pending “React compiler” promises never fully deliver. He shares personal angst—React’s inversion from community-driven to platform-driven, where React’s core values (modularity, transparency, minimal abstractions) are compromised by Meta’s bundler and AI gambits.

Speculating on AI’s role, Ryan challenges the idea that AI training cements React as permanent—even if AI models are trained on old React code, new paradigms can still emerge. He critiques capitalistic inertia: Meta’s larger React Native team (outnumbering React) and heavy AI research reinforce React’s position, but do not guarantee generational relevance. Ryan fears complacency: React’s “more features, not removing old ones” strategy risks leaving persistent architectural holes unpatched. He juxtaposes React’s trajectory with indie music: creators sometimes “sell out,” but Ryan insists React’s core ought to maintain its original ethos rather than chase every fad. As AI, RSCs, and Remix swirl, Ryan encourages a balanced view: celebrate innovation, but scrutinize promises of “one day it will fix everything.”

### 01:30:00 – 01:39:59  Exploring React’s Fault Lines and Fragmented Ecosystem

This chapter further dissects React’s structural fragmentation into three major paths: deep framework servers (Next.js, Remix, RSCs), client-side SPAs (TanStack Query, single-page approach), and new experimental directions (React compiler). Ryan details how these factions carve community silos: Devs locked into SPAs lean on TanStack Query and React Router, while server-centric devs champion Remix or Next.js debates about bundler choices and server functions. He notes Remix’s forging ahead with “no bundler dependency,” choosing Preact as a light wrapper and migrating away from full React compatibility. Ultimately, he argues that React no longer stands as a single entity, but a conglomerate of frameworks and patterns. This fragmentation creates steep learning curves: devs must navigate multiple toolchains, conflicting paradigms (RSCs vs. CSR vs. SSR), and shifting roadmaps rather than focusing on foundational “web platform” principles.

Ryan critiques React’s “growth at all costs” ethos—observing that while React can optimize slow React programs, React cannot raise performance ceilings where fine-grained updates or zero-bundle islands excel. He compares this to initial React hype—removing DOM slowness—but reminds viewers that React only matched performance of Angular back then; the virtual DOM never fundamentally surpassed direct DOM manipulation. Nonetheless, React’s marketing repositioned VDOM as revolutionary, eclipsing earlier declarative frameworks like Knockout and Ember. Ryan concludes: while React’s innovations propelled web dev forward in the 2010s, today’s landscape demands reconsidering frameworks built on modern reactivity and compiler features. The rest of the industry (Solid, Svelte, Astro) now tackles problems React never fully solved.

### 01:40:00 – 01:49:59  Framework Histories, Declarative Patterns, and Performance Myths

Here, Ryan journeys through frontend history to debunk persistent myths: that tools began with React’s VDOM or that jQuery reigned supreme. He references Knockout and AngularJS as early declarative frameworks and notes community narratives often erase their impact. For example, React’s “unit-directional data flow” and component rerenders echoed Knockout’s MVVM approach. He argues that React’s novelty lay not in inventing declarative templates but in reframing them with a virtual DOM suitable for large complex apps. Ryan recalls Pete Hunt’s Angular vs. React demos—where React was found to match Angular’s rendering speed—and how subsequent “Hype” videos misrepresented virtual DOM as intrinsically faster despite its mechanical limitations. Emphasizing that frameworks share three primary rendering approaches (hyperscript/VDOM, string templates/dirty checking, direct DOM updates), he urges developers to recognize underlying similarities rather than binary React vs. Vue debates.

Turning to Solid’s approach, Ryan lauds Solid’s direct retention of DOM with signals for granular updates (push-based reactivity), contrasting React’s rerendering model. He highlights how Solid’s fine-grained graphs isolate component updates, mitigating unexpected reflows in large apps—benefits invisible in simple microbenchmarks but crucial in enterprise-scale interfaces. Within this context, Angular’s adoption of signals and incremental DOM (zoned change detection to zoneless signals) reveals a broader industry shift: frameworks increasingly converge on reactivity patterns rooted in functional programming. Ryan sees Svelte 5’s adoption of Solid-like patterns (compile-time reactivity) as affirmation. He cements that reframing “virtual DOM vs. no virtual DOM” misses the bigger picture: evaluating how abstractions, compilation, and reactive graphs collectively influence performance and developer experience.