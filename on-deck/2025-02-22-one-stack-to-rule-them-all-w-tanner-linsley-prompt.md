---
showLink: "https://www.youtube.com/watch?v=p16CQPTHS8g"
channel: "Ryan Carniato"
channelURL: "https://www.youtube.com/@ryansolid"
title: "One Stack to Rule Them All w/ Tanner Linsley"
description: ""
publishDate: "2025-02-22"
coverImage: "https://i.ytimg.com/vi/p16CQPTHS8g/maxresdefault.jpg"
---

This is a transcript with timestamps. It does not contain copyrighted materials. Do not ever use the word delve. Do not include advertisements in the summaries or descriptions. Do not actually write the transcript.

- Write a one-sentence description of the transcript and a one-paragraph summary.
  - The one-sentence description shouldn't exceed 180 characters (roughly 30 words).
  - The one-paragraph summary should be approximately 600-1200 characters (roughly 100-200 words).
- Create chapter titles and descriptions based on the topics discussed throughout.
  - Include only starting timestamps in exact HH:MM:SS format, always using two digits each for hours, minutes, and seconds.
  - Chapters should each cover approximately 3-6 minutes of content.
  - Write a two-paragraph description (75+ words) for each chapter.
  - Ensure chapters cover the entire content, clearly noting the last timestamp (HH:MM:SS), indicating total duration.
  - Descriptions should flow naturally from the content, avoiding formulaic language.
Format the output like so:

    ## Episode Description

    One sentence description encapsulating the content within roughly 180 characters.

    ## Episode Summary

    A concise summary of the transcript, typically 600-1200 characters or about 100-200 words, highlighting main topics, significant points, methods, conclusions, and implications.
    ## Chapters

    ### 00:00:00 - Introduction and Overview

    A comprehensive introduction providing readers with the main themes and concepts explored throughout the chapter. The content highlights significant points discussed in detail and explores their broader implications and practical relevance.

    Connections are made between concepts, emphasizing interrelationships and potential impacts on various fields or current challenges. The chapter sets a clear foundation for understanding the subsequent discussions.

## Transcript

[00:00:00]  All right. Hello, everyone. How are you doing today? Sorry, I'm running a bit late. That's all on me. Very excited for today's stream
[00:00:09] . We've been trying to make this happen for a while now, probably about a month. And I'm going to give everyone a chance on Twitch to get past the pre
[00:00:20] -rolls. Of course, you can always subscribe and then you don't have to worry about pre-rolls on Twitch. Just throwing it out there. But yeah
[00:00:28] , how's everyone doing? Yeah, no, this is going to be a good one. I see that people were commenting like days before. There's a lot of
[00:00:39]  excitement about this and I don't blame you all because this is this is some really cool stuff. All right. Yeah. Hi, everyone. Yeah, it's already
[00:00:55]  been. I know it's been a while since I've streamed back to back. So yeah, let's go. Yeah. Or watch YouTube where there's no
[00:01:08]  ads. Yeah. There's no ads. Yeah. Here's the Lord of the Rings. Honestly, with as much work that me and Tanner do together and how often
[00:01:18]  I want to invite them on the stream, it gets harder and harder to come up with stream titles. At one point, we're like, should we just like have
[00:01:24]  like a special name that's like a regular segment? So, you know, like every few weeks or whatever, just invite Tanner on for a bit. I don't
[00:01:32]  know. But I was very uncreative one with Lord of the Rings this time. Is it Bling 2? This is what people really want. They want B
[00:01:41] ling 2. Hey, Brandon. Hi. Hi, Burke. Yeah. Hello, everyone, really. All right. All right. All right. All right. Just
[00:01:55]  kill. Just having some fun and killing it. What's pretty cool here is I think Tanner is streaming on Twitter as well at this point. And of course, he has
[00:02:06]  more viewers than I do. So, you know, it all works. All right. All right. All right. All right. All right. I can tell you guys
[00:02:16]  can't wait. So let me see. Just let me check on Twitch and make sure everybody's OK over here. You guys alive in Twitch? I see some Twitter
[00:02:25]  chat. I see some YouTube chat. I don't see so much Twitch chat going on right here. Just let me make sure that it's good. And I should also
[00:02:32]  retweet on Blue Sky because there are some people who use that app. Let's see here. Give me two seconds. I know I'm doing it off screen. Yeah
[00:02:42] . Yeah. We got Twitch is alive. Yeah. I see that. Thank you. Yeah. Hey. Okay. All right. Let's let's tell the Blue
[00:02:53]  Sky folks. What's up? Because they are not watching live from within the app. All right. Two seconds. Let's quote. Twitch dot TV slash Ryan solid
[00:03:11] . Nine. No, just Ryan solid. Sweet. All right. All right. All right. Okay. I've wasted enough time. Hopefully we built up enough hype
[00:03:24]  here. Apparently there's 460, 400. We're going to get to 500 before, before I invite Tanner on the stream here. Okay. All right. All
[00:03:34]  right. 482. 483. See, Twitter counts it funny. So honestly, this is a number that just keeps on going up. Oh, 497. Okay
[00:03:44] . I think, I think, I think we are probably good here. Um, I've, I've built up enough hype. So, um, let's welcome Tanner
[00:03:55]  to the stream. Hopefully he's ready to go here. Okay. All right. Welcome Tanner. I don't, I'm sorry. Maybe I got you muted.
[00:04:12]  Yeah. Apparently we would, uh, switch from Lord of the Rings to like Tron or something. I see. How are you doing today? I'm doing good.
[00:04:23]  Uh, I'm glad to have you on again. Again, as I said, it's been too long. I think the last time we were on, we were
[00:04:31]  talking about the fundamentals of routing. And that, that was like, I don't think that was a fall. That was like a year ago. It feels like, I
[00:04:36]  don't know. It's been a while. Um, been way too long. So I'm very happy to have you back. Yeah. Cyborg Tanner. Yeah.
[00:04:45]  This is my favorite place to be. So yeah, it's going to be a good time. Uh, let me remove this banner. Let's get stuff going.
[00:04:53]  Somebody said nice shirt. Thank you. Check it out. There you go. Tan stack. Tan stack. Can people buy said shirt? So then do you have a
[00:05:02]  merge? Yeah. If you go to tan stack.com slash merch, you can buy lots of stuff and it's all, it's a nonprofit swag shop. So it
[00:05:14]  doesn't mean it's like free. You have to pay for cotton bureau to print it and fulfill it, but I don't make any money off of it. So
[00:05:24] . Okay. That's, that's, that's cool. Um, I, that's, that's for good stuff. I'm not going to lie. Our funds
[00:05:31]  go back into our open, open collective. It's back into trying to find people to do cool fellowship stuff with solid, but. Cool. Yeah. Um, okay.
[00:05:42]  Yeah. Tan stacked on merch dev with the handy link. All right. All right. Cool. Cool. Cool. So, um, how, how should we start
[00:05:54]  today? Cause you've been doing a lot of stuff recently. Um, obviously, um, we have something to announce, um, which we, we should probably talk about
[00:06:03] . There's also been a lot of really cool stuff. I've seen around 10 text start. I've seen that whole narrative. I heard something about, uh, uh
[00:06:10] , CLI tool as a straight, um, replacement for create react app. I think there's been a lot of stuff, but I, before we muddy the conversation
[00:06:19]  with react, maybe we should, we should talk about something else. That's cool. And maybe, maybe not react. Yeah. Announcement. Announcement
[00:06:31] . Announcement. All right. Yeah. We can, we can start off with that. So. Yeah. Are people familiar with Burke? Burke's game. A
[00:06:44]  little bit. A little bit. I've been hyping because of the incredible work he's been doing on a solid start. Uh, yeah. So if, if
[00:06:51]  you don't know Burke, you should, cause he's great, but Burke. Yeah. He's been doing, he's, he's done. He's done
[00:06:57] . How much has he done with solid start? A lot. Cause the thing is I kind of left the project to, to focus on other things. And in terms of
[00:07:03]  like making sure that all the plugins update every new version of beat, he's the one who goes through and tests all the different versions of beat as they come out,
[00:07:11]  make sure that they work in the beats all plug and make them work in solid start. Um, make sure every like third party dependency stays up to date. It's like
[00:07:19]  nitro is something new. Yeah. Burke's on it. And Brindley. Is it Brindley? Yep. Yeah. So Burke and Brindley that
[00:07:27]  kind of like dynamic duo, right? Yeah. And Burke and Brindley are MVPs. Totally. All right. So I gotta, I gotta set this up because
[00:07:36]  I think it will make it even more impressive. So hold on, I'm going to go back to the beginning of this thread. Um, so we created this thread
[00:07:47]  in discord on January 27th. Okay. That wasn't that long ago. No, that's less than a month. Less than a month ago. Okay. I feel
[00:07:58]  like, I feel like until I streamed last Friday, I, I didn't do a stream from there. Like that's like the, the gap between one of my
[00:08:05]  streams. Okay. So we, this thread is created by Burke and he says, let's figure out 10 stack solid router. Less than a month ago. And I
[00:08:18]  was like, okay, let's do this. Let's do this. And, um, everybody just jumped in. Everybody. Burke and Bradley mostly. Uh, Manuel
[00:08:28] 's been in there and Sean have been in there like helping him out. And I was like, Oh, this is going to take a while. You know, uh,
[00:08:38]  this cause I tried to do it once. If you remember, like I tried to do this like a year ago and it was, it's some intense work. I
[00:08:47]  think, I think the code, the core code base is in such a better place now than it was that, um, it's done. It's done. Yeah
[00:08:56] . Yeah. No, it's, it's ready to use, which is crazy. So that's, that's the announcement. There's not much fanfare about it
[00:09:06] , but solid 10 stack solid router is there. Yeah. You can install it and it's ready to go, which is pretty crazy. Yeah. This is the first
[00:09:18]  non react, uh, framework to work with the 10 stack router. And for those who, for those who aren't familiar with it, um, it has type safety all
[00:09:29]  the way down to the, like the anchor tags. Like when you're like trying to fill out, you know, finish out a URL, it type checks the URLs for
[00:09:37]  you. Um, and that's just the start. Yeah. If you haven't used the router, like it's, it has a context system that lives outside of
[00:09:49]  the framework that you're using. It lives in the router. So there's like a, a context system that lives in the routes in the route tree. And it's
[00:09:58]  all type safe. And it has like its own life cycle middlewares that live outside of the framework. Um, they can do some really cool stuff. Yeah.
[00:10:11]  But so they, we have like 400 or something tests, 400 or so tests. And in like three, a little over three weeks, they basically three weeks, they took
[00:10:23]  it from zero to 400. So yeah, Burke, Burke and Brinley are, they really are MVPs. They deserve all of your attention for this. Cause
[00:10:37]  I couldn't have been more hands off. Yeah. Yeah. I, I admit I wasn't in there much myself. What the, I, I mean, I
[00:10:44]  guess people do deserve a bit more of a backstory of how everyone ended up in the same discord. Um, which we'll get to get to in a, in a
[00:10:52] , in a moment. But I just, I just wanted to like start with that straight out. Cause like, uh, you know what, while I'm not going to
[00:11:00]  run the, the, the, the working example here, we do have that basic query example. So I can just throw a little bit of code on screen so people
[00:11:09]  can get an idea of, of what's going on here. Let me just present my screen for a second, share a screen, entire screen, the screen. Okay,
[00:11:18]  cool. Okay. So this repo was, uh, shared with me and it looks like it was updated five hours ago. So what you can see here is just a basic
[00:11:28]  beat repo with a beat config, right? Define plugins, beat the plugin, solid, nothing too special here. Um, and then, you know, our classic
[00:11:37]  index, um, HTML. So this is like a client, um, app, just normal beat app. Um, but then you have the power of tan stack router in
[00:11:47]  here. Um, so this is a very simple example. Um, but just to get an idea, there's main TSX where they set up the router. And if
[00:11:54]  you've ever seen tan stack router, there's a bunch of these creation methods. And what these do for the routes is they let them link all the types together.
[00:12:03]  Right. So we have all these create route calls. As you can see, this is basically the same as doing, uh, 10 stack react router. If you, you
[00:12:10] , you've seen these before create route, get parent route, the, the loader mechanism, the query client, these, these things are all from an API surface side
[00:12:20] . This is the same. The, the only difference you're going to see is when you go inside the components, you might find something like create effect instead of use
[00:12:28]  effect, for example, or, uh, create query. Um, which for those who aren't familiar, create query is actually solid queries. So this particular example shows
[00:12:40]  the full 10 stack experience of using, uh, 10 stack query and 10 stack router together in something that like, I mean, I'm having a pretty hard time seeing any
[00:12:53]  difference here that much. There's subtle things. And I pointed them out right away when I would look at it, but, uh, for the most part, this
[00:13:00]  is the same experience you get when developing with react with these tools. Um, so, you know, just with the added benefit of solids performance and granular updates. Oh
[00:13:10] , I just realized we haven't merged the docs yet. Okay. Yeah. We need to merge those. I was just about to share it and I was like, Oh
[00:13:18]  wait, where's the documentation? Hold on. Let me hurry and merge that. So you just start a single flight mutation to preserve the new router. Um, single flight
[00:13:27]  mutation currently is only built into. Solid router, but it is, it's a protocol in our server functions that could be extended to other routers. I think if
[00:13:38]  you want to talk about this project, generally speaking, like there's stuff that solid router does that's very specific and very mechanical and things that, you know, I particularly
[00:13:48]  cared about, um, which we built up in solid router. Um, whereas conversely, this is like a straight port of, uh, 10 stack router, which has
[00:13:59]  all all the tan stack features, which are a lot of features that, um, we don't even have. There's, there's a lot of, there's
[00:14:07]  a lot of things that are jammed into 10 stack router, you know, better handling some, you know, scroll restoration or just various other, um, more advanced features
[00:14:17] . So no single flight isn't here. There's a few other, you know, things that I built specifically while building solid start, um, that, that are
[00:14:27]  not here, but there's, there's some interesting, um, potential here if we can find a good common base. But as I said, I built solid start to
[00:14:37]  be router agnostic, um, initially. And, um, my hope is that it will not take very much to be able to leverage those features and test tech
[00:14:46]  solid router as well. Yeah. Like we, we have plans for single flight mutations in the router in general that should work across frameworks as well. Um, some of
[00:14:58]  that is only around what we can control, right? So your single flight mutations would be around mutations that affect like your route loaders, for instance, um, because there
[00:15:11] 's a different single flight mutation approach for things that use like react query or solid query. And similarly, if you're just, if you're using like the async prim
[00:15:21] itives for solid, then we would need to integrate further. But I think all, I think that's all pretty possible. Yeah. Um, file based routing work.
[00:15:29]  And my understanding is you have a beat plugin to do 10 stack routers, file based routing. So as long as you have that beat plugin doing the processing, there is
[00:15:36]  a file system routing solution that comes with the router. Yeah. So, um, there's a baseline like code based routing solution, uh, that takes a little bit more
[00:15:49]  work to set up for like this. Like this, what you're looking at is the code based, um, setup. And there, there's a little bit of
[00:15:57]  work to set, like to hook everything together. Um, mostly to make sure you get good type safety. Um, as soon as you want things like code splitting, like
[00:16:06]  for better performance, um, I would just absolutely say use the file based router. use the file based routing. Because file based routing puts in just a little bit of
[00:16:16]  convention enough to where we can handle all of that for you for free. So like we will then, uh, code split all of your routes. We can even do extraction
[00:16:26]  to take your, your loaders and your components and rip them apart and make sure that they're like loaded in parallel, that kind of stuff. Yeah. I highly
[00:16:35]  suggest using the file based router. Huh. If it'd be feasible for future viewers 10 stack route to be able to handle react and solid routes in one app. I got
[00:16:42]  a react app itself. I mean, that would be pretty crazy. I mean, nothing is impossible. Yeah. I mean, that's with enough work. And I don
[00:16:51] 't know, I don't know how much work I'd be willing to put into that. Yeah. I mean, it's pretty tricky because even if you have sections
[00:17:00]  of the app that kind of render the context sharing is tricky and the biggest client side, I've actually figured out patterns to kind of make this injection work. It's a
[00:17:08] , it's a funny game you play because react doesn't understand DOM and solid doesn't understand V DOM. So there's like a, and, but routes are kind of
[00:17:16]  mostly separate, but you still have to worry about outlet injection and stuff. But the harder one is SSR I find because async, uh, impacts like how they
[00:17:26]  have almost completely different protocols in terms of how they like assemble. Right. Yeah. React makes like a bunch of V DOM nodes and then they figure out, you know,
[00:17:33]  how to stream that or like put that kind of lay it together. So it's like creating strings on the fly. I think SSR would be pretty hard to do.
[00:17:43]  Um, it just, it's a big, that's a big rabbit hole. When you start to expand it out. I don't know if that, but I
[00:17:55]  mean, there is a world in which I could see someone pulling up the CLI and get eventually getting to one where it's like install new tan stack start project and then
[00:18:05]  be like, do you want to use reactor? You want to use solid? I, yeah, absolutely. Absolutely. I mean, Alex brings up a really good point
[00:18:15]  because if you look at like really what it means to move between frameworks these days, um, a lot of them, a lot of frameworks have converged on very similar,
[00:18:27]  uh, concepts for like templating and components and code reuse. Right. Um, I would actually wager that there's more similarities between the frameworks. Um, then
[00:18:39]  there are the routers that those frameworks have. So the idea here for the, I have in mind is that like, if, if you can say, okay,
[00:18:49]  this is the router that we have chosen and it happens to work across all these different frameworks, then it's, it's very likely that you're not going to have to
[00:18:58]  change a lot of code to move between frameworks other than just, okay, now we just need to convert our components. You know, our rendering UI part of it into
[00:19:08]  a different framework. And I think, I feel like that's not as intense as say, oh, we have to switch frameworks and we have to switch out our router and
[00:19:20]  our data fetching and switch out our SSR approach and all this stuff. Like, no, it's just all that can stay the same. Yeah. I mean,
[00:19:28]  the thing is, I mean, I I'm, I'm kind of loving the double-edged sword that comes with saying you need a framework these days, because
[00:19:36]  like on one hand, you know, it's puts us higher overhead that you now need these pieces, you know, but react is like very much pushing you in that direction
[00:19:46] . I mean, we can talk about CRA and that whole debacle and maybe a bit later, but, but, but on the other hand, it means that people aren
[00:19:54] 't interfacing with the low-level stuff as much. They're interfacing with these abstractions. So like, you know, like the remix crowd, for example,
[00:20:01]  very famous for broadcasts. famous for saying like, I don't use, use state or use effect anymore. Right. Um, and I mean, obviously that's
[00:20:11]  been happening for a very long time when people have used query, because that it's the same, it's the same thing. Right. And to be fair and solid with
[00:20:19]  resources, you know, there's the same thing again, but yeah. But like resources and like derived stuff, like kind of don't need it. Right. But
[00:20:28]  on the other hand, like we're just taking the step like that much higher up to the point that like, it might be easier to, to swap things. I think
[00:20:38]  the interesting thing, and I think the challenge that we have to face with this and something I'm very conscious of is the core of those frameworks. Okay. API surface
[00:20:47] , very similar. So for developers switching conceptually, not that hard. They have the, the pieces are kind of known. And then when they, they, once they
[00:20:54]  decide, you know, I want to query or cache client and why I want this piece, you know, I want a router and they kind of, you know,
[00:21:02]  have those pieces together. Yeah. The, the underlying framework, um, doesn't matter as much, arguably from an API standpoint, but from a capability standpoint, it's
[00:21:11]  an interesting question because like, I don't know if anyone saw my stream last week with the async signals and stuff. When you start going down a path where the underlying
[00:21:19]  framework has, you know, these different capabilities, um, it's, it becomes different how the abstractions actually can perform their tasks. Sometimes maybe more optimally,
[00:21:28]  sometimes more streamlined. It might actually even possibly influence the shape of those, um, abstractions. And now the thing is with view, Svelte, solid, almost
[00:21:39]  all converging on the same and even angular, maybe eventually all converging on the, in the same zone. Then like, you can be like, okay, we can
[00:21:47]  build towards that future. But interestingly, React is the only one not on that path. So I do think for agnostic solutions, there's gonna be a turning
[00:21:56]  point in the future between them going, okay, React's a default. How do I account for the fact that solid exists to, uh, uh, switching default where we
[00:22:05] 're saying like these other signals based frameworks make certain things so much more streamlined and so much simpler. Um, maybe I can just gut all this stuff and, or, and
[00:22:11]  just move it to the react adapter or the react implementation. Cause they're, they make us jump through. Yeah. I mean, I'm just speaking hypothetically.
[00:22:18]  Like as I look at like, okay, how, how are actual client side front end frameworks progressing and innovating? Right. And like react, I know react and
[00:22:32]  I've spoken with the react core team recently. And, and I know that they very, very deeply care about the client and about, you know, client side performance
[00:22:41] . Um, they're just approaching it in a, in a very different way through a compiler. Right. And through different means. And I look at that as, you
[00:22:52]  know, they, they can figure that out and maybe they can follow where solid is going down the path so far, you know, and, and that would be great.
[00:23:01]  Um, but like, I look at a lot of the async stuff that you've been doing and like the patterns that it opens up and I'm like, well
[00:23:08] , I don't really know how I would even represent that in react today. So I see it as kind of like, um, in, in the same way that,
[00:23:16]  you know, we, Ryan, we always talked about down sampling signals into immutability, right? You'll almost have to do the same thing for these new as
[00:23:26] ync patterns. You'll have to like down sample the concepts into more coarse grained implementations in other frameworks. Um, we'll have to see how that shakes out.
[00:23:38]  I think it's possible. Yeah. You're just moving code into the adapter that needs to do a little bit more work, uh, for that framework to kind of implement
[00:23:48]  those, those patterns. So it'd almost be like you could get the same pattern. Like you could use the same pattern, um, as like the new async
[00:23:57]  primitives and solid in react. But it's like, it would be, it would be like down sampled or, or there might be tearing or there might be,
[00:24:06]  you know, little kind of gotchas, but at least you'd be able to have the same interface across all the adapters. Yeah. I mean, that's
[00:24:15]  the hope that the craziest thing is where I see when we built solid. I mentioned this last stream, I was like, okay, what can I do to be like react
[00:24:22] ? How can we prove that this is viable and do the same things react does with solid 2.0 and the stuff that I showed off last, it doesn't even fit
[00:24:29]  the react mental model. Like the idea of like self healing, uh, fine grained, like self healing error boundaries and stuff like where you, you can be like
[00:24:37] , Oh, I'm down here and I'm retrying. And because I know that the data dependencies and I know this is aired, I can just like refetch something
[00:24:43]  like these kinds of concepts make no sense in a run component model. And I think this is kind of part of the problem that like this do react compatible, like react
[00:24:52]  us solid. Like react compat is incredibly hard because people don't realize that the frameworks are so different. They are like night and day different to the point that like the,
[00:25:03]  the best way I could think of doing compat with react is just like basically write my own preact. And then say this component is a preact component inside solid.
[00:25:14]  Like, like, I, I, I have to basically invent the whole separate framework to pull that off. Um, so it's kind of like. It's almost like
[00:25:21]  a mixture too. You'd almost have to have a little bit of a compiler and, and a runtime framework thing. Hi, this is, this is live right now.
[00:25:32]  People can see you. Yeah. Say wave to everybody. Say hi. Yeah. Okay. Why do you think react doesn't convert? Yeah. Yeah. No problem
[00:25:45] . I'll, I'll take this one on. Cause this is one I can answer. Why do you think react isn't converging similar to other frameworks? I think
[00:25:50]  because react was always the different one. I mean, honestly, right from the beginning, their philosophy, their beliefs is something to be respected is that there's this kind of
[00:26:06]  immutable functional programming kind of mentality. Um, they're just a different place. The, when react came out, every other framework was different than them. And they
[00:26:14] 're like, you can do it a different way. And then other frameworks kind of copied bits of them, but they never, not all of them actually like fully adopted what
[00:26:21]  react is. So react abandoning its approach would wouldn't make any sense. Like they, their whole concept is components are the unit of change and it's re render
[00:26:31] , whatever, like you can optimize and memoize or whatever, but they're not going to, they're not like going to change the signals even unless they thought like they
[00:26:37]  could hide that fact. But what I'm actually kind of getting at is it's really interesting when you don't hide that fact. Like that's what enables what I
[00:26:45]  think the real power is in the future. So, um, I think react is exactly where it's supposed to be in that sense. I mean, there's,
[00:26:52]  we can argue about other aspects of them. Um, but yeah, I mean, it's, it's the longer you go on this path, especially the longer you fall
[00:27:02]  solid and fall of react. I think we're going to actually start seeing divergence here because up till now I was just trying to placate what everyone else expectation or how
[00:27:10]  you should work now. Um, thanks to the support and people like believing in what we're doing. Um, we're, we're, we're going to, we
[00:27:18] 're taking things beyond that to like a different place. Um, yeah. So, yeah, I mean, I guess we should talk a little bit about how everyone ended up
[00:27:28]  in the discord in the first place. Uh, what I was saying is, um, because I, if we should go like top down or bottom up, you know
[00:27:37] ? Um, I feel like, uh, I, okay. I feel like a lot of this started with 10 sex start. And I, when I, I was like
[00:27:50] , Hey, I'm going to build this framework. And obviously I reached out to you and I was like, okay, how did you do solid start? And you
[00:28:00] 're like, oh, well, okay. I, so we use this tool. Right. Um, and that's, that's bingy. Like everybody probably already
[00:28:08]  knows that now. So. Yeah. But to understand a bit about bingy is. Nikhil built solid start, like largely the core parts of the original solid
[00:28:18]  start. And then when we tried to expand it and we hit, we hit a bunch of shortcomings. And when we went to go update it, it becomes such a
[00:28:23]  mess that Nikhil was like, I need, let's write it over again. And we, we tried to do some stuff like on top of Astro, like
[00:28:29]  basically we're trying to find a deployment solution. And then what Vinci was like, he was finally like, okay, I think I figured out a way to use
[00:28:37]  VEAT in a way that's generic. That'll cause he was building react apps. He was building, he wanted to use server components. And as people know,
[00:28:42]  server components with VEAT hasn't been really a thing. Um, they, it wasn't really possible. So he came up with an approach, which is kind
[00:28:49]  of obvious, but also kind of, you know, awkward in that he's like, okay, well, we'll just make a separate VEAT processes for each environment
[00:28:57] , so to speak. And then we'll just wire them together. And then I'll like grab nitro over here and then we'll thing. And we'll have a
[00:29:03]  solution. The big, it was a hack together thing of the same sort of. Like of the original VEAT, which is like, uh, okay, well
[00:29:13]  I have roll up and then I have ES build and then I'm going to just kind of pull these things together. I wouldn't even call it a hack either, because
[00:29:21]  if the environment APIs hadn't come out in VEAT six, it would still be the best way to do it. You know? Yeah. Yeah. Unfortunately, sorry
[00:29:31] , very fortunately it did. And which will, um, which kind of changed the game considerably because we, we were kind of in this point because yeah, you're
[00:29:41]  right. It started with tan stack and us talking because for a while there Tanner, you didn't want to build a meta framework and you're like, but you really want
[00:29:49]  to push router. And then you, you know, we're talking about this and you're like, well, um, if people, the meta framework kind of comes with
[00:29:57]  the router and I'm like, it doesn't have to. Right. Yeah. There, there is a philosophical place where it doesn't have to, but you know
[00:30:03] , who cares? React router is remix next building their router. Like that is their framework, so to speak. Um, and you know, it was just kind of funny
[00:30:13]  cause we, we aligned so much on this stuff. Cause for me, for solid, we were in this interesting place where we didn't want to like make something new and
[00:30:21]  like split our ecosystem. Like you, you've seen what's been happening with react. There's like three ways to do things. Uh, Brian Florence did a great
[00:30:29] , uh, poll, uh, uh, that I'm probably going to show at some point. Actually, I could probably just show it right now if I really wanted to
[00:30:35] . Um, but he, basically the react community has no clue which way to go, um, when it comes to, to the, the server components versus loaders versus
[00:30:46]  like more spa-like patterns. And I, I wasn't willing to split the ecosystem. So what I did with solid start was come up with this approach, which
[00:30:53]  was like basically spa first, and then just use server functions as an additive way, add server functionality, even without SSR. Um, and then just build everything on the
[00:31:00]  single base and also try and do it to be agnostic. So like if someone new router came along like tan stack router, people could use that too. And
[00:31:07]  then I, I wouldn't have to like make these things. So because I wasn't interested in pushing a product. So I guess fortunately from your perspective is that means that
[00:31:18]  the common base that I needed to pull that off, um, was what you need was similar to what you would need to be like. I want to start a new
[00:31:26]  project and use my router because yeah, the stuff we built didn't care that much about which router you used. Yeah. And we, and we both, we, we
[00:31:34]  both care about the server and SSR and stuff, but that's definitely not like server first methodology. Like that's not where we came from. Um, so we
[00:31:43] , that we, we, we lined up on that where it's like, Hey, we really care about SPAs. We really care about client side performance. We're
[00:31:50]  going to start there and incrementally add things back. I mean, that's, that's what both of the starts really have in common is that they're like client first
[00:32:00]  opt into opt into the server as far back as you want, you know? Yeah. Right. Yeah. I let, yeah. I remember this one. Well,
[00:32:08]  it kind of moved around, but when I first saw the poll, there was literally like 15 people had voted and, um, yeah, I mean, it was kind of
[00:32:17]  funny because yeah, 15 people had voted and it was dead, even 30, 30, 30, basically. And yeah. And, um, and 10 and we, he
[00:32:27]  ended up getting another 2000 votes and it did not shift that much. the whole time. Um, so like, I think this poll is really interesting. Actually. There
[00:32:39] 's, there is some, there's some hidden, like self-deception happening here that people, I think people look at these and they think, well, you know
[00:32:49] , they're mutually exclusive and they're definitely not. Uh, I mean, okay. It's more of like a hierarchical thing, right? But if, if you
[00:33:00]  choose one of them, you can still have the others and I'll let you figure out which one that is. I mean, it's really difficult to save. So
[00:33:10]  let's go through like, if, if you're, if you have an SPA, you can still use loaders and actions. And in the very near future with
[00:33:19]  like react router seven, when they launch their RSCs. And when we launch ours, you'll be able to use RSCs too. Um, and, but
[00:33:27]  you know, that doesn't go the same. It doesn't feel the same direction when you're going from something like next, that's totally built on and around and
[00:33:37]  for RSC first experiences. And then it's, it's like the loader in action and the SPA kind of architecture styles. You can get similar functionality out
[00:33:49]  of it, but it's not the same developer experience at all. So I feel like that is what drove a lot of the answers here personally is it's like, it
[00:33:59] 's not, which tech do I want to be available to me? But more. What's the style of architecture that I prefer to build my apps in. Right.
[00:34:10]  And that's why I think you get this even split. Yeah, I think, I mean, and, and that's fair. I, the fact that these, and
[00:34:19]  that was my actual quote tweet. I said, the fact that these are distinct worlds in react, uh, if it remains even split, it speaks volumes. The fact that
[00:34:26]  these three distinct worlds is a problem with most solutions in react space. The fact that you can't mix and match the, the interesting thing though, to me, perception
[00:34:34]  wise is when I, I, I view a difference between like, he called it loader action. Cause that's what remix calls that. Yeah. That is in
[00:34:43]  a different category than the, what you call loaders in the router or what we call preload, um, in solid start writer or what Svelte used to do
[00:34:53] , um, in Sapper. And I believe, I think nuxt has something similar. In fact, react router three had an on something hook that was on,
[00:35:01]  that was on the same kind of vein. And then they removed it and they removed it in react router four. Um, so like the, the, that pattern,
[00:35:11]  I don't consider loaders. I still consider it like on the spa side of things. When I consider loaders is remixes loaders, like the specific, like
[00:35:20]  non granular, like server, like this is a server action loader. Yeah. And I consider, I know they have now client loaders and client actions that worked
[00:35:29]  it into like a billion splits, but, um, but I would have preferred different styles of like SSR basically like SPA, no SSR, uh, traditional,
[00:35:44]  like hydration based single pass SSR with hydration or like the incremental weaving. Of, you know, hydration and SSR, which I feel like these are the technologies that back
[00:35:59]  those three patterns. Right. Yeah. Cause, cause what I'm, what I'm kind of trying to say is like, this is get server side props, like from
[00:36:07]  my perspective, from an architectural standpoint, this is spa. Maybe it has isomorphic loaders or whatever the hell you want to call them. Yeah. Yeah.
[00:36:16]  And this is next app router. This is the RSC base, like, like RSC as a framework. Exactly. Right. Not just a serialization format, but
[00:36:28]  like as an architect, don't get me wrong. RC as a platform, like as an actual framework has distinct benefits that are hard to impossible to get by using them the
[00:36:42] , a different way. Like I get why it's a thing, but when you go here, you're actually saying, I kind of want an MPA, but
[00:36:50]  that does client routing. Like it's, it's, it's, it's a different architecture. So like for me, these are like his wording meant that you
[00:36:58]  could mix and match to a certain degree, but they are potentially distinctive approaches. Now those approaches could be swapped at a page route level. Um, conceptually, like you
[00:37:11]  could swap them out in a route section, like in a particular panel. Yeah, well, and like, so even like what I'm working on right now, I
[00:37:20] 'm working on SPA mode for 10 sec start. Right. And we would call SPA mode really what it is, is just like this flexible, uh, choice,
[00:37:29]  whether you want to say, Hey, I just want to do everything on the client for this route, or you can mix and match and say, I want to have some
[00:37:36]  of these clients, some of these, some of this route render only on the client, but some of it SSR. And then when you would get into RSC
[00:37:44] s, RSCs are just going to be another kind of like API endpoint that you can call and will happen to be able to SSR those. And you can do
[00:37:55]  RSCs from the SPA side of it all on the client, or you could do RSCs all on the server. And that's where you get into the
[00:38:03]  interweaving thing, but yeah, you need to be able to mix and match these. And I think you can in almost all the frameworks, but it's,
[00:38:11]  it's more about what they're prioritizing with the way their architecture is, is set up, right? The conventions that they have, um, what they're pushing you
[00:38:21]  towards. Yeah. Yeah. It's funny. Cause yeah, I just, I think it's, it's worth kind of thinking about, but it's like,
[00:38:31]  we got to walk back to where we actually got here, which was that we, we, we, you decided that because of the router, you basically needed to build a
[00:38:39]  framework. Um, and yeah, the router is like 90% of the framework. When people say like, Oh, the framework, I love this framework. I mean
[00:38:49] , if you take away the router, there's not there, there is some stuff left. Right. But there's not much. I don't really think. Right
[00:38:59] . So, okay. People might be aware of this part of the story. So fast forward, uh, several months, solid finishes testing all the pieces enough to get solid
[00:39:10]  start 1.0 out. We're happy about the API mechanically. We've shown off really cool stuff like single flight mutations and granular updates, server functions, all
[00:39:19] , all the great features that people should be aware of and should watch one of my previous streams about. And Tanner's now finally, it's funny. Cause we've been
[00:39:27]  like out of sync a little bit because you were working on router while I was working on start. And then you start working on start when I'm like, start working on
[00:39:34]  solid 2.0. Yeah. And we, so we, we've been, we just keep on missing running a relay. So, so you start working on start
[00:39:42]  and solid one point start 1.0 goes out. And as I said, technically very, very cool stuff, but we start seeing that like this difference when you have,
[00:39:54]  you know, X number of users versus, you know, 1.0 production number of users. We start finding bugs. Um, unsurprisingly, um, it's
[00:40:01]  not a problem with the API shape. It's not a problem with the design. It's literally just bugs, like things that. Edge cases, you know, that
[00:40:09]  you didn't. Yeah. So like, so we're sitting there and I, you know, we've been fixing them. I, uh, Nikhil, um,
[00:40:18]  who's basically one man show doing all that stuff, got really busy with his work. And it turns out the apps he was supporting were not even SSR apps that
[00:40:26]  he was using. It's like, he originally built it to support server components and server functions, all this stuff. And then he ended up building mostly client single page apps
[00:40:34] , you know, which is kind of funny and ironic, especially when you consider like the polls and all the conversation and the VE and the CRA. He, I
[00:40:41]  mean, he originally built it because he thought next JS was too slow with server components. And it was, and they, they fixed that. Um, their dev mode used
[00:40:47]  to be horrendously slow. So he's like, okay, I'm just going to build a framework. Yeah. Yeah. But he also then went off to do
[00:40:54]  his thing and we're stuck there and I'm in the repo trying to fix bugs. And we start forming on our side, like a bit of a solid start team because
[00:41:00]  I can't manage it. And people actually using the product, you know, people, um, you know, we've, we are saying we've got Burke already.
[00:41:06]  And then people like, uh, catch a, um, and, uh, there's a few others. People actually have projects actually built on solid start. And they're
[00:41:15]  like, there's bugs and these are real. And you start developing stuff and you're like, okay, I need to fix these bugs. And then you're just
[00:41:22]  like, okay. Um, well, yeah, Vinci there. I mean, I'm, I'm going to be very honest here. Vinci is like a very
[00:41:38] , very love, hate relationship with Vinci. Right. Vinci was when I came onto the scene to start, start, uh, like it took me from zero
[00:41:50]  to 90%, like really fast, which was amazing. I was like, oh my gosh. Like we have a framework, right? I mean, the full stack kind
[00:42:00]  of build system and framework. I'm like, this is great. Um, but like that last 10% was so difficult to, to get through. I mean,
[00:42:12]  even just to get it to like alpha. So that we could launch 10 stack.com using 10 sex start just to get there was a slog to get, you know,
[00:42:25]  to go from proof of concept to alpha. Um, but once we got there, like that's kind of when Nikhil, yeah, started to like pump the brakes
[00:42:32]  and just get busy with other stuff. And I feel like it was basically around the same time that you and I were like, okay, we, we want more control
[00:42:40] . We need, we need to get rid of these bugs. We have to fix these edge cases. And, um, I mean, the time, he just didn't
[00:42:48]  have the time, you know, I mean, and then there was one other absolutely momentous release that happened in November, which was beat six. Yeah, beat six
[00:42:57]  came out and I think that was kind of the nail in the coffin for, for Nikhil because before that he was kind of like, oh yeah, you know, we
[00:43:05] , like we can, he, he knew that he was filling a real, a true gap in the ecosystem. But when beat six was announced and started like when it came
[00:43:14]  out, I think he was kind of like, okay, all this stuff that I kind of did is going to yet officially superseded anyway. Um, and I think
[00:43:24]  he was, I mean, from my interactions with him, he's been more than okay to kind of say, yes, here's the reins, you know, you guys
[00:43:31]  do what you need to do. Um, there's no doubt that we wouldn't have been able to get both of the starts to where they are today without Vinci.
[00:43:40]  Um, but you know, his, his heart's not in it anymore for, I mean, for good reason, you know, and, uh, we just need more
[00:43:49]  control. Right. And, and that's when you came to me about a month after beat six came out, uh, uh, with, uh, in December around
[00:43:58]  Christmas time. And Tanner Tanner came to me and he was like, yeah, I'm going to build a new server functions plugin. Um, you know, let's see
[00:44:06]  if we can just start building separate V parts. Um, you know, like, like V plugins, cause it's funny. So we started as solid start just being
[00:44:14]  a V plugin, you know, um, and many others have gone that way since. Right. Svelte kit went from a thing to just a V plugin. Yeah
[00:44:21] . Uh, remix went from a thing to just a V plugin. We had gone to just, we'd started as just a V plugin before all that was all start,
[00:44:29]  but then we had the switch to Vinci to support the advanced features. Yeah. And, and then V six came out and Tanner's like, let's just go
[00:44:37]  back to being a V plugin. Um, and it's funny. You say that like right now, the branch I have checked out that I'm working on all morning is
[00:44:45]  called Da Vinci as in D Vinci. Um, and it, I'm literally converting everything that we have back to just a V plugin, but using nitro
[00:44:56]  two and some of the new nitro beta stuff that they have for three and V six environment. And I mean, I'm, and I'm, I'm, I
[00:45:05] 'm best friends right now with Brandon Roberts. I'm sure, you know, Brandon. Uh, but he, he built analog, right? Hey, Brandon's here,
[00:45:12]  dude. What's up, Brandon? Brandon. So I've been hitting Brandon up a ton and he'd been very, very nice to me. He's like,
[00:45:18]  uh, been more than nice to answer questions about how he's doing things. So, um, I think it's, it's going to go really well. And
[00:45:28]  I think the tech is all pretty much in place now to get what we want out of it. Yeah, there it is. D Vinci. Um, but I,
[00:45:37]  I'm really excited about it. So I think moving to just a V plugin back to just a V plugin, like it's, it's not going to be super,
[00:45:46]  it's not going to be super amazing. It just puts more work back on like us as framework developers to like put more logic into that V plugin. Um, but
[00:45:55]  at the end of the day, it's going to be much better, I think. Yeah. Yeah, no, exactly. I mean, uh, Brandon made the nit
[00:46:04] ro, uh, plugin for V because nitro also kind of took a lot of extra. And I, my understanding is when nitro version three, um, it
[00:46:14]  will be a V plugin because again, the environment API is what opens the door for this. So we're still in this awkward place where stuff is, is, is moving
[00:46:22]  pieces because like I have nitro three, isn't quite out yet. And then we're trying to build something that would be built on top of nitro three, hypoth
[00:46:31] etically. So yeah, it's, yeah, that's, that's the plan. I mean, from what Brandon's told me that, you know, the upgrade
[00:46:41]  to nitro three, isn't going to be that big of a deal compared to what I'm doing right now, which is going from Vinci to, to just like
[00:46:49]  straight nitro, which is a lot more of like, there's a lot more pain involved there. Um, I mean, there, there's a lot, there
[00:46:57] 's things around like, like, okay, actually, I think this is a good time to talk about where that, like where this took us, like what happened because of
[00:47:05]  this. So when Vinci, when Vinci was clearly, you know, it's like, okay, we need to long-term plan phase Vinci out and figure
[00:47:13]  out what we're doing. We knew that we were going to be working more together on the start projects. Um, and originally, so originally what I want to do
[00:47:25]  is just piece by piece kind of start ripping pieces out eventually just replace them with my own that were like agnostic. And the first one that I did was,
[00:47:34]  um, server functions, uh, specifically like use server directive. Um, and you know, there's not, not like the create server function that you get from 10 sec
[00:47:46]  start, but like just use server and directives and like file directives for a new server. So, um, that took a good two weeks, I think you
[00:47:55]  remember when I was doing that and I ripped all of it out of Vinci and I replaced it with just a VEAT plugin. It's actually three VEAT
[00:48:04]  plugins. You don't have to use them all, but there's like a client and SSR and a server version. And you just throw these VEAT plugins in
[00:48:12]  there. And all of a sudden you have server functions, you know, all of your environments, which was pretty crazy and it relies on nothing but VEAT.
[00:48:21]  Um, yeah. And, uh, I believe it was Brenly again, who, if you've seen the latest version of solid start uses that very server. Uh,
[00:48:30]  they already swapped it out, which was really cool. So yeah. Uh, yeah. But, and the, the, the, this happened all around, it's in
[00:48:36]  December ish, uh, around Christmas time. Um, what had happened was Tanner was going this way. We, we talked and Tanner was like, let's do this
[00:48:43] . And then I was like, okay, solid start team emergency meeting. Um, because, uh, this is kind of wasted and it was solid start team plus Tanner
[00:48:52] . Tanner. And in that meeting, we discussed this future where we were, you know, the devintification. And then we were, and the idea was that
[00:48:59]  we'd see ways to work more together. And in that meeting Tanner went and invited all the core maintainers to the solid start project into the tan stack start, um
[00:49:11] , collaborator discord where the specific maintainers are. So that, that pool of people has been together working together for the last month, which is again, why we
[00:49:21] 've already integrated the plugin. And also I think a big part of why stuff like solid, uh, tan stack router, um, came out so quickly. Cause everyone was
[00:49:31]  just working next to each other. Yep. And it's, it's wild to have everybody in the same room, to be honest. Cause there's, and we
[00:49:40] 're going to need more of it. Like, right. Like Manuel, Manuel has been working on, uh, Manuel Schiller. You don't guys don't know who
[00:49:47]  that is, but Manuel's awesome. So he's, he's been doing a lot of really core grueling, amazing work on router 10 stack router and start
[00:49:56] , but he has, he's been spearheading. Like, how are we going to do framework agnostic CSS, uh, like manifest extraction and, and loading
[00:50:08]  and unloading. And how do we make it work with a bunch of different routers? So that's coming, um, which is going to be crazy to figure out
[00:50:15] . We already kind of talked about that a little bit in that same channel that has everybody in there. So there's a lot of great minds in there. Um,
[00:50:24]  yeah. Solid starts running 10 sex server plugins since 1.0, 1.0. Yeah. Yeah. That's the version. Yeah. So, yeah, this is
[00:50:33]  just the beginning really is really what we need to put out there is that this is just the beginning. Um, like in the beginning, solid start was the one forging
[00:50:43]  ahead to figure out. How do we make Vinci work? And they did that. And then I kind of grabbed the baton now. And now I'm like
[00:50:50] , okay, how do we, now, how do we take it to the next level and get rid of Vinci? And we're going to port that stuff back to
[00:50:56]  solid start. Right. And it's probably going to ping pong for a while. I mean, this is definitely not like, we don't have like a, some three
[00:51:03]  or six month plan on like, we need to do this and this and this and this. It's just going to be very gradual and, you know, very long
[00:51:11]  term convergence on how do we share some of this stuff. Um, and no way. Brandon's using it too. That's awesome. Um, this is the kind
[00:51:22]  of stuff that I'm talking about. It's like, okay, if we could, if we can truly build stuff that's agnostic and everybody can just share it
[00:51:29] . Like it's really, really powerful. And I mean, my hope is that the stuff that I'm doing right now. I'm wait, 10 sec solid.
[00:51:38]  I missed the announcement. That was the announcement at the beginning. Yeah. My, my hope is, so I'm literally taking the code that Brandon has written right now and
[00:51:49]  porting it into 10 sec start. And I'm, you know, in both of us are finding it. He's like, oh, some of this stuff was just
[00:51:55]  for analog. And I'm like, and I'm going to need some of this stuff just for start. Start, but there's going to be a common ground there
[00:52:01] . And I think that it's going to happen again. Like we're going to find some common ground, some common, uh, you know, plugins and some things.
[00:52:10]  And I think some of them are already there that Brandon has already written. And then those are going to end up in solid start. You know, like we're all just
[00:52:18]  going to start. Yeah, exactly. And now, and now we need to put, you know, the same one, but we're looking at analog. Right
[00:52:30] , because this kind of funnels down the stream because I, which is what I was kind of going to get to is I think, ultimately, that it doesn't end
[00:52:42]  here with this because now that we've kind of cleared up those pieces. Vite's taken on some of the responsibility and we can return to Vite plugins streamlining
[00:52:50] . It's not just for us. It's actually for Nitro as well. I would not be surprised if there's conversations where we can streamline stuff more with Nitro
[00:52:57] , right? Brandon's our interface on how to do that, the plugin for now, but when Nitro three comes out and it's a plugin, we can start looking
[00:53:05]  at that. Cause I think one of the, our biggest challenges with Nitro over time was just that, I mean, it's, it's, it's kind
[00:53:11]  of like how Vinci was built with solid start originally in mind. Nitro was kind of built with Nuxt in mind. Yeah. So like there's certain patterns and
[00:53:20]  certain things and certain conventions, which will, would not necessarily sit with a reactor solid audience. Um, but, uh, I think that when we figure out from a
[00:53:31]  primitive standpoint and figure out what like those pieces are much more clearly, there'll be just like obvious places where to kind of move that stuff. I love, I love the
[00:53:42]  chat going off here. Angular start. What is truth? I know. I have no clue. Who knows? I saw somebody said tangular. Oh, it's,
[00:53:53]  it's a huge raid. Apparently we're that, that is what's going on. Oh, Oh, what is, is this, is this primogen to prim
[00:53:59] ogen just raid us with, with 1500 people on Twitch. I still don't know what, what ch root is though. So whatever. Yeah. Yeah, no, this
[00:54:11] , this is awesome. Um, I just got Tanner Lindsley here, critter tan stacked, um, react query, um, 10 stack router. And we're
[00:54:20]  here talking about 10 stack start the new meta framework. Meta framework. And we're talking about newly released today. Tan stack router for solid JS first other framework with
[00:54:30]  it. So you can get the full type safe, um, routing experience with solid JS. This is nuts. This is nuts. Yeah. This is what, this
[00:54:40]  is, this is what happens. Um, I don't know how he manages to see. I actually try and respond to people in chat. When you, when you,
[00:54:46]  when you become, you know, prime or Theo size that you can't just respond to people in chat anymore. I can't even scroll fast enough. Chat's just,
[00:54:54]  it's just dead. It's just become useless now. Does 10 stack router do input validation? Uh, input validation. I mean, the input that you get
[00:55:10]  on a router is the URL and yes, it does do validation on the URL. So yes. Is that what you're asking? Yeah. I would say you respond
[00:55:21]  pretty well. Prime. I just meant like, I literally answer every single person's question. That's where my streams get derailed to six hours. If I tried to
[00:55:28]  do that with a chat your size, I think I'd be like, we'd be here for several days. Um, yeah, serious. All right. Where were we
[00:55:37] ? What were we talking about? We were talking about, so, so we're going to converge. There's stuff being shared everywhere. Um, between, between 10
[00:55:45]  stack and solid and analog. Um, and it's just going to get, it's just going to get crazier. Like, I think that, uh, I think
[00:55:54]  that like analogs going to get stronger because of it. Uh, solid started obviously is going to get stronger. Um, honestly, now that we have solid router out,
[00:56:06]  um, I, I don't think it's out of the question that we see an angular router or a view router soon. Um, the, I think I'm
[00:56:16]  trying to think of the order that the other adapters kind of followed. And it's like, once you unlock one, there's like a natural order to the rest of
[00:56:24]  them. And I feel like that was the order is like one solid was done. It was kind of like a, an angular and a view tie to who can get
[00:56:32]  to the next adapter. I think now with the way things change, you're going to find that spell five is actually going to be your, the next one. It's
[00:56:42]  I've seen this already, like in zero, like that they do, like the replica guys are doing local first. Obviously solid was first after react and then felt was
[00:56:50]  the next one. Um, because felt and solid are so close that, um, now since they made that change to use fine-grained signals rendering, basically the same
[00:56:59]  approach we've been using solid for years. That, uh, that port is probably going to be the next easiest then view and then angular. Yeah. I saw somebody
[00:57:08]  talk about validation again. So you, you, you can validate in the router for your URL, but if you're talking about tan stack start, you can also get that
[00:57:17]  level of validation on your server function RPCs as well. So that that's what might be where there's some overlap that people, somebody said the chat's going like
[00:57:28]  zooming by. I, I, but I saw somebody mentioned that. Yeah, no. Yeah. People talking about ballot bot and Zod. Um, yeah, you
[00:57:36] , you can use anything that's standard schema. So like they came out with the standard it's what is it called standard schema? Is that what it's called? I
[00:57:43]  can't remember what it's called. Yeah. I know what you're talking about. And standardization between all the, the typescript validation libraries. So they pretty much
[00:57:51]  all of them conform to that standard schema now. And so you can use any of them and it just works. Yeah. Yeah. I, I, I, I,
[00:57:59]  I've, I've wondered about that. Cause ballot bots like selling point is it's so fricking small and so optimal. So it's like, does, does
[00:58:05]  that transformation actually slow it down and or make it larger? And I, you know, I'm, it's so funny cause it's like conflict of defeating the point,
[00:58:14]  but I get it. It's compatibility is better than being better. Um, I just like, I just like being better. So it's, it's like hard
[00:58:20]  for me sometimes. A lot of it, I think it depends if you're doing validation on the client too. Like a lot of people don't want to ship Zod
[00:58:27]  to the clients cause it's, it's chunky. It's like, it's, it's, it's, it's, it's pretty big, isn't it
[00:58:31] ? It's like, it's getting on. Like, it's not quite like Apollo client, but it's like, it's, it's something. I mean
[00:58:37] , I, I still ship it to the client cause I just, whatever. But, um, Ooh, a real question. Do things like router dev tools work with solid
[00:58:47]  now as well? Um, that's a good question. I think they should, they may, they may not, but here's, here's the cool thing.
[00:58:54]  So what we did with, um, what we did with 10 stack query is we rewrote the dev tools in solid actually. Um, and because solid is super small
[00:59:07]  and lightweight, we just, when you install react query dev tools, you're actually getting a solid app. I wish that counted towards our NPM downloads. I mean
[00:59:19] , it should, because it's installing solid. I don't know why it works, but you're, if you look at react, uh, query dev tools, you
[00:59:27]  guys get more downloads than solid. JS does like almost double or triple. It relies on solid. So like we, I mean, we're just passing like, I think
[00:59:37] , I think query client back and forth. I think it's cause it's an app. So you install it to, to make the app and then you build the app
[00:59:44] . And then the users of it don't actually install it. You can just add it as a dependency. We should. I don't know if it works like the
[00:59:54]  way, like, yeah. Anyway. Should we, we can growth hack that. Just add it as a dependency. And then we're good. Cause it's, I
[00:59:59]  saw that. And I was like, wow, that's depressing because the react query obviously is very popular. That's just how much bigger the ecosystem is. That a
[01:00:06]  tool in the react ecosystem was like triple or down to the hard MPM downloads. Yeah. But we'll, we will do the same thing for router most likely very soon
[01:00:15] . So I actually don't know if the dev, the dev tools probably don't work. They're probably not even available for the solid router yet. Um, but
[01:00:23]  that's probably what will happen. We will probably port them to solid. Except, and then, and then we'll back port them back to react. Yeah. React
[01:00:34]  router dev tool, like 10 stack, react router dev tools as a solid app. Yeah. Yeah. Like the, the dev tools are written. So that you use with
[01:00:42]  all the query clients, whether it's felt query. For all of the query. Yeah. Adapters. They're all solid. And I mean, nobody has any
[01:00:50]  idea. It's just an app. So who cares? So it's pretty cool. Hooray for solid. Yeah. I appreciate that. I'm glad that
[01:01:01]  your developers enjoy using solid. I'm glad. And I'm trying to remember who did that. Was it Aiden? No. Arian or Arian. Arian
[01:01:11] . Yeah. Yeah. Arian did that. He's going to school right now. He's kind of busy too. But yeah. Arian's a, he's
[01:01:19]  a genius. So he's very, very good at what he does. Maybe we'll have to ask him to come and moonlight that. For us and do it again
[01:01:26] . He was really good at it. Um, yeah. So like, let's, we can talk about what's coming. If you want. You can also, I
[01:01:36]  mean, I, how we talk about current affairs. Yeah. Like I was going to say, like, we can get the current affairs in a little bit. Let's
[01:01:42] , is there anything you want to show off to people about the latest stuff in, uh, uh, tan stack start or like, um, because you've been tweeting
[01:01:50]  stuff the last week about some like really cool functionality. Um, and I think it's, I mean. Yeah. And show off maybe. I mean, I'm in
[01:01:58]  a broken state right now and I don't feel like stashing and. But I will talk briefly about kind of some of the stuff we've added. So, um
[01:02:08] , I just need to go to Twitter and I can find your tweets probably where you were. Yeah. That's a, that's a great, that's a great way
[01:02:15]  to do it. So, um, recently, so what I did, I added something for server functions. So this is not like the use server directive stuff. This
[01:02:27]  is for create server function, which is our type safe abstraction over user. Um, we created a new flag, a new type of create server function that you can set to
[01:02:39]  static. And basically what that means is we, when you pre render your site, you're basically just running SSR on your machine. And when you have a server
[01:02:54]  function set to static, it will, you know, you'll call your server functions as normal during that pre render SSG phase. And if, if, if a service
[01:03:02]  function is static, it will cache the result of that server function and actually build it out as a static asset to, uh, like to an SSG site. And
[01:03:14]  I, if anybody ever used react static that I built five or six years ago, um, it's basically that. So it's fully static SSG, but all the
[01:03:24]  data is split to for each route is all like code split. And so as you navigate around the site, you're just, instead of calling server functions, it replaces those
[01:03:34]  server function calls with calls to static. JSON. What I think is interesting about this, that people aren't clicking on is some of the reasons people use RSCs
[01:03:43]  is cause of like the PPR thing and the static, like pre-gen of like stuff outside the suspense boundaries. What this approach proves or shows is that you can have
[01:03:52]  the same impact or like feel by simply caching the server functions. the server functions, right? You can RSCs are just a data format. So like,
[01:04:03]  okay, it's, it's JSX. You, if you just say at build time, run the server function and now it's JSON, your framework's always going
[01:04:10]  to be serializing that into the blob anyway. So you get that same, like from a CDN thing, like you're talking about a purely static scenario, but
[01:04:17]  you could also do the PPR thing and just go like, these ones are static and these ones will be fetched at runtimes and use this as a performance enhancement approach
[01:04:25]  and do it. but you don't need specific next architecture for it. You don't even need the edge. Although I do. I do approve of streaming from the
[01:04:35]  edge because you can get that initial response faster. As I was showing before a fast edge network with a static response, even from a worker. Um, while not quite as
[01:04:44]  fast as CDN won't have as big of an impact anyways. I, I did the whole PPR debunking, uh, episode a while ago and benchmark.
[01:04:51]  Um, but this is a mechanism. See, I never, I didn't take it further, so I couldn't really talk about it. This is a mechanism that
[01:04:58]  makes it possible to do something very PPR like, um, just in any single page app type thing. You can go all the way, like you said, and just
[01:05:06]  like, be like, look, it's pure CDN, but you can also split it with a streamed edge function approach, which I think is very, very cool
[01:05:13] . Yeah. And I think part, I think, well, what you brought up too, you bring up a really good point because like, if we talk about R
[01:05:21] SCs, right? The first thing that I always like to say when everybody brings up RSCs is that everyone's being educated about RSCs incorrectly. They,
[01:05:30]  everybody, everybody reasons about react server components as if they're like really, really magical. And, and most of that has to do with the way that next JS has implemented
[01:05:41]  RSCs. They are very, very abstracted and a black box in my opinion, like you call a server function in next. And if it returns an R
[01:05:53] SC, you get back an element essentially on the other side of that server function. Right. I, but do you know what I'm going to say? No,
[01:06:05]  but I was, you can continue. I just, Dev said something that really caught my eye. He's like this cat mechanism. We just described as completely framework agnost
[01:06:12] ics. That mechanism is RSCs are proprietary react. Yeah. Serializing a server function is not, it could work with solid. It could work with.
[01:06:22]  Yeah. That's exactly what I wanted to talk about. So RSCs, I don't like the way that they're implemented in next. And I don't like
[01:06:32]  the way that we talk about them in the react ecosystem because we talk about them as if they're proprietary. So the way that I have reframed RSCs for
[01:06:40]  people is to say, stop talking, stop saying RSCs. And let's just, let's just say readable streams of whatever we want. It's a readable
[01:06:51]  stream of text, right? And that text can be serialized anything. At that point, a readable stream of text could be a serialized react component. It could be
[01:07:02]  a serialized solid component. HTML, just HTML. It could be anything, right? As long as you have a way to bring it back to life. Once you get
[01:07:11]  that, it's just serialization and deserialization. And so everybody's really obsessing about RSCs right now. And I'm, and I'm
[01:07:18]  like, you know what? I would love to be able to obsess about RSCs, but that doesn't feel primitive enough. So what I'm doing is I'm
[01:07:25]  obsessing about, about streams, readable streams and incremental streams, async iterables, right? Because from a framework perspective, if I can unlock a really, really good
[01:07:39]  developer experience around readable streams as a primitive. Well, now you can do anything you want, right? RSCs are just one implementation of that. So that,
[01:07:50]  and that's what we've done in the router. And that's what we've done with solid or with tansec start is that when you're, when you're
[01:07:55]  sending these like RSC things around, really, we don't try and obfuscate any of that from you. You're going to get back a readable stream
[01:08:05] , and you can cache it, you could throw that stream into a JSON file, you could cache it into local storage, you can bring it back to life whenever you want
[01:08:14] , right? So that's how we need to start talking about this stuff. This proprietary language. I couldn't agree with you more. And a lot of the work
[01:08:24]  dev joined the solid core team specifically working in R&D in that area, because there's a commonality between that kind of thinking, I think, not just with the
[01:08:32]  server client communications, but even with stuff like local first and like different ways of kind of breathing in these like streams and events of data. So much to the point that
[01:08:41]  I'm actually gonna throw this up right here, I don't know if anyone noticed this last week when I was doing my stream, create async, which is like our
[01:08:48]  very, very basic async handler and solid, you're going to notice something here. The type for the for the computation function is promise of T, async iterable
[01:08:57]  of T, or T. Yeah, we are actually supporting async iterables, which means we're supporting readable streams, and even Rx observables at the most core
[01:09:06]  level of async in the framework. So like, this is this is in this way. I think that's pivotal. Yeah, it's pivotal. I mean,
[01:09:16]  so I'm full disclosure, like, we, me and Dominic TK Dodo, we've been, we've been talking about doing this for React query for 10
[01:09:26]  set query overall, is just supporting async iterables. When this stuff comes out, we're going to have the real interesting to talk about solid query because when what
[01:09:36]  the crazy part is, in in tan stack query, you guys make a really, really powerful primitive. And then at that point, when you say use query, you've
[01:09:44]  interfaced with react, you've exited out and you're like react. React, from this point on, you handle the rendering, you do the data, we
[01:09:50] 'll just make sure you get what you need to get. Here's all these states will communicate all that to you. But in a system that is built to handle
[01:09:58]  this, like I showed off in the last stream with solid, this async will probably be at the core of solid query. But every derived value, every memo,
[01:10:07]  every part of the rest of the reactive system propagates that asynchronously propagates that thinking. So the state isn't just like, okay, use now you're in
[01:10:17]  react land and you're out of query land. It's runs through the whole system, which means that the whole idea of like is fetching is pending is a native concept
[01:10:27]  to the framework in terms of any secrecy, which just, you know, like, we're going to have, we're going to have some talks. We're
[01:10:33]  going to have to figure out what that looks like, because it's, it's just goes beyond probably do is just let query focus on what it's supposed to be good
[01:10:42]  at, which is cash management and the value texture around cash management and invalidation. Yeah, instead of managing all of the asynchronicity and the behavior that that
[01:10:53]  we now have to manage today, like, and we'll have to keep managing that for a lot of the other frameworks, you know, but for something like this, we
[01:11:01]  could, we could just say, hey, you know what, solid. Solid covers this. Let's just push this down. You know? Yeah. Yeah. I
[01:11:07]  know that's a little solid pipe side thing. But this is this is what I'm paying attention to with the design of 2.0. So it's just another confirmation
[01:11:14]  of going the right direction in terms of thinking. Oh, yeah, Dev had a good call out here. He says the core maintainers of TRPC helped us build start
[01:11:24]  server functions, which they did. I reached out to the core TRPC team. And I was like, hey, we're building an RPC layer for start.
[01:11:32]  And I asked them, I was like, you guys know better than anybody else. Like, what's worked? What hasn't? What do you wish you had done
[01:11:39] ? You know, and they actually helped us design a lot of the very first versions of it. And from there, it's been a lot of me and like Christopher
[01:11:50]  Herob and Manuel Schiller just kind of going back and forth on how do we like how do we do context like middleware. Middleware is a really hot thing
[01:11:59]  we're working on right now. And it's a very complicated topic because, you know, you have this concept of middleware that can span client and server calls in kind
[01:12:10]  of its its middleware triangle. I like to call it where it's like going in and then coming back out. So, yeah, we used a lot of like
[01:12:20]  TRPC isms to figure that stuff out. Yeah, it's been very helpful. No, it makes a lot of sense because they have experience with the beyond like thing
[01:12:29] . Like I really only focused on the mechanics of like use server. But when you consider like validation, when you consider like middleware pieces that when people are building actual
[01:12:38]  API routes, there's a whole other mechanism layers of side. I could comment here just on a side saying something Apollo is the ultimate goal or like GraphQL type stuff.
[01:12:46]  And I actually think it's one of those funny things where I've said this many times on stream. I've even like drawn like the history of data fetching GraphQL
[01:12:54]  in a sense was the pinnacle of our capability on the client in terms of being able to manage this stuff. But like there's a reason react query came out
[01:13:03] , right? You did a whole write up when you first came out where you're like normalized versus document level caching. And funnily enough for the average developer document
[01:13:13]  level caching ended up being the winner and normalized cache probably just kind of drifted off into space. The thing is, yeah, there's a DX consideration. And
[01:13:22]  in terms of pattern thing that in a sense, GraphQL, what it does is so powerful. And it's got like, but then it was like, it's also
[01:13:32]  like, it's bigger than it's bigger than react on the client bundle. Like it's, it's, it's like this black hole that forces all this.
[01:13:39]  I think one of the biggest interesting parts is we are, we'd step back and then we're kind of approaching it again. But this time when we're approaching it,
[01:13:46]  it's in a way that doesn't feel hopefully as obtrusive. I, it's, it is a good point in your head to, to, to think
[01:13:54]  of GraphQL perhaps as the pinnacle of like a potential, at least local maxima of data fetching capability. But interestingly enough, it's an example where
[01:14:04]  because of everything else around it, as you said, like, you know, implementation aside or whatever, it, it, uh, ended up not like kind of fading out
[01:14:13]  of it and why TRPC got so popular and why server functions have gotten, um, so, so popular here. Yeah. Yeah. With like, with the rise
[01:14:22]  of, um, actually I think it was Ryan Florence who called it the, the backend for front end. Right. Or at least he popularized. I don't know
[01:14:31]  if he came up with it, but, um, yeah, Theo's right. I haven't bought with GraphQL since I started normalize caching the chaos scale.
[01:14:37]  Absolutely. Um, and you know, in, in my opinion, so let's touch on that first, like the normalized caching thing. Um, I never,
[01:14:46]  I never said that it wasn't valuable or important for some things. Like I use tweet deck every day and if they didn't have normalized caching, their UI would be
[01:14:56]  a mess. Right. Um, but I didn't want normalized caching to be a point of a touch point for developers because most, if not many or all developers and
[01:15:10]  say all developers suck at managing caches. Um, even I suck at managing caches, which is why I built software that I, that we can test and know
[01:15:17]  that it works well. Um, and so when I built react query, I wanted it to be a system where you could build a normalized cache on top of it. If
[01:15:29]  you want, as an, as an optimization and people have done that. If you look at, there's a project called normy, if you look at, there
[01:15:36] 's a project called normy, normy J S N O R M Y. I can't, I can't, I'm not exactly sure. But normy
[01:15:44]  J S you can just drop it on top of react query or, or, or RTK query. It's really impressive. Um, so I think that's the right
[01:15:54]  direction to go. Like if you need normalized caching, make it an optimization that you don't have to deal with. Um, Theo's got some good comments
[01:16:05]  here. I'm going to go back to what you said though, about, um, so I was saying back in for front end and graph QL. So back
[01:16:13]  in for front end popularized this potential, this idea that like between your back end and your front end, you can have some server code to help you do things that kind
[01:16:24]  of displaces a little bit of what we use graph QL for, right? It's like this staging area between your client and your server, where you can grab
[01:16:32]  things from a bunch of assets, pull them together, only send down the data that you need for that call. Sound a little familiar, like graph QL, right?
[01:16:39]  So there have been some, there have been some like shifts in the way that we, you know, that we architect things and deploy things that I think have lessened the
[01:16:49]  need for graph QL specifically. Um, but like normalized caching, it needs to be there for some things. I get it. Yeah. Yeah. Uh,
[01:17:00]  it, it is, it is, it is an interesting thing. Just, I mean, I guess that's like the scale, right? Cause people didn't even stop
[01:17:05]  at react query. If you think about it, um, remix is loaders and then RSCs at the far extreme is like that whole slide off the cliff. Cause
[01:17:15]  RSCs don't have that same kind of client cache. You, you, when you change like something on the page, you end up going back to the server for
[01:17:23]  the whole freaking page. Yes, you have server side caches to make up for it, but you have completely gone the opposite direction at that point. What do I
[01:17:32]  have here? This is what you're talking about or this is something even more than that. Um, and stack starts bar. Oh, this is something different. Uh
[01:17:43] , I didn't talk about this yet. So this isn't necessarily something new for like the ecosystem or a new idea, but it's something new for 10 sec start,
[01:17:53]  which I think is, is really cool. So, um, it's, it's, uh, it's basically opting out of SSR at any level of
[01:18:00]  your route matching. So, um, other than the route, right? The route route. So if you, if you have a, a bunch of nested routes
[01:18:10]  at any level in there, you can say, um, you know, hey, SSR false. And when we get to that point, we'll just kind of say
[01:18:19] , okay, everything that we've loaded up to this point, we'll stream down to the user HTML and everything. And then we'll just pick up client rendering again
[01:18:27]  when we get to the client for this specific route. Right. Okay. It's like our client only, but you're doing this on like a route definition level. Okay
[01:18:35] . Yeah. Like we, we have a client only component as well, where you can say, Hey, don't render this unless you're on the client. It uses
[01:18:42]  like a mounted type thing. Um, this takes that to the next level at the route level to say, um, we're also not going to run any loaders or
[01:18:52]  before load or any route loading. Life cycles for those routes going down, which is nice because client only component is nice. If you have logic that you're interacting with
[01:19:02]  the browser APIs and the DOM inside of a component. But what if you have a loader or, you know, like what if you have a loader that needs to
[01:19:10]  interact with local storage or something like that? It'd be really nice to just code fence that and say this whole loader, this whole route relies on the client being there
[01:19:20] . So we're just going to opt out the whole route, the loader, the before load, the component, everything right here so that we don't see any
[01:19:30]  bugs, any errors happening when we try to access browser stuff. Um, so, so actually to take that a step further, what's really cool is, is when
[01:19:39]  I built this, I was like, Oh, you know, as soon as we hit the first SSR false, we're just going to bail out entirely of all of
[01:19:46]  them underneath it. But then, but then I had a separate tweet, I think it's the next tweet that I made that was kind of a nouncy.
[01:19:53]  Um, I decided in, yes, so instead of opting out from there down, we were running all of the route, the route loaders and everything in parallel
[01:20:06]  anyway. So what I did was I made it so that you can opt out of SSR for rendering at any, at any point in the route tree, but you
[01:20:17]  can keep loading data for ones that are lower than that. So you may have a route that needs to render on the client, but you can take that opportunity while you
[01:20:31] 're on the server to fetch the data while you're close to the database, grab it and serialize that data down in the, in the, you know, HTML response
[01:20:41]  that it's sending down. So it's, it's SSR, but for only the data, you're like, which, which is half of the battle to
[01:20:49]  get single flight mutations to work because that's what they, that's exactly what we do. Right. You do the mutation and then you SSR the next page with only
[01:20:59]  the data. Yeah. Dev said, we're all approximating RSCs and SPAs. It's like, yeah, I mean, we're trying to get the
[01:21:05]  most that we can out of SPAs because they're extremely convenient and, and they're just so much easier to work with. There's no question about it. Um
[01:21:15] , so like the more that we can eke out of the SPA experience, the better. I think the big one is because of that granularness. Once you go
[01:21:23]  to RSCs, you lose that ability on the client. Cause you're giving that away. The farther we take the SPA thing, it's kind of like the
[01:21:30]  graph QL example or whatever we talked about. Uh, but not even to that thing you can be like, no, I only care about this data. I only need
[01:21:37]  this piece. So if you, there's something about the SPA model where mindset wise, well, it's, it's the react query model where you can invalid
[01:21:45] ate or revalidate specific pieces of data. Well, yeah. Um, you, if you, you can basically make only that as part of your request and
[01:21:53]  only do that part of the work with an SPA model, with an RC model, you, you can do that on the server, but essentially you have to.
[01:22:00]  Like you're sending the whole thing, you're doing the whole thing or re rendering the, you know, I think a lot of it, a lot of it comes back
[01:22:08]  to state management. We always talk about state management and it is a fact that the closer you get to your users keyboard and mouse, the more, you know, about their
[01:22:20] , about who they are, what they're doing, what their intentions are. The state that they have, right. As soon as you start leaving, the further away
[01:22:29]  you get from that keyboard and mouse, the less information you have about making optimization. So ideally the best place to make the call on an optimization would be on the client
[01:22:42] . You know, we can't always do that because you have to start somewhere on the server, right? But once you get down to the client, you have so much
[01:22:50]  information about the session and, and yeah, what happens with RSEs and server first methodologies is you end up trying to hoist all of that state up into the
[01:23:01]  server somehow. Cause now you need to know more to make the same optimizations on the server. Sorry. That's my daughter. If you can hear screaming in the
[01:23:08]  background, I'm getting doors on my office this week. Woo. Um, but the, the more, you know, you have to know more on the server for R
[01:23:18] SEs for that model to like, be able to make those same optimization calls, which is why you see people like, Oh, if I'm going to add RSE
[01:23:25] s, then I got to have caching. And if I'm going to do server caching, then it's got to be, you know, this weird function
[01:23:31]  caching thing that only, you know, there's flavors of it that only work on Vercel. Nitro has the same function caching thing as well.
[01:23:39]  And then you start getting into, well, do we start, do we spin up Redis and start throwing like user data into like this Redis session thing. And
[01:23:47]  that starts to blur the lines a lot with like local first and sync engines, right? It just seems like everything gets so complicated when you, when you move away from just
[01:23:59] , Hey, we're on the client. And we know basically everything there is to know. And if we don't know something, we can go to the server and figure
[01:24:06]  it out really quick. You know, so kids, kids are crying over hearing RSC. Yeah. I said RSC in my, in my one year old way
[01:24:16] . No, I mean, that works for me. You know, one of the, one of the challenges that, you know, been for solider signals is the fact
[01:24:27]  that it's, it's, it's the most granular approach, which means that it was never optimized for people resending the whole page. Right. You know,
[01:24:35]  in a sense is RSC is the new DB Mon benchmark. You know, Ryan Florence went on stage and showed everyone how fast he could plaster fresh new page over and over
[01:24:44]  again in a diff engine, like, like a diff, like how fast react could diff. But I I'm hoping that that's no one's real actual app, because
[01:24:52]  think about how much less data you could send. Think about how much, you know, less things you could update if you just like only sent what changed instead of like
[01:25:01]  smashing the whole page. Now that's an extreme, but sometimes sending the whole page is simpler. Like in a sense, RSCs are for people who want to use
[01:25:10]  Astro and then just haven't figured out Astro is good enough. I don't know. I don't know. Well, and I, I think it's
[01:25:18]  funny because I know that in the past I've been like, I don't know about RSCs. Like I don't like them or I, um, it
[01:25:24] 's funny because I have an immediate use case or RSCs. I run a documentation site. Tan stack.com is like a ton of just static content, which is
[01:25:35]  funny because like that is one of the best use cases for react server components where it's like, I, I mean, you don't, you don't get to avoid
[01:25:42]  the double data problem, but you get to reduce the amount of data that you are sending overall. Right. And that's where I'm like, Hey, it would
[01:25:50]  be wonderful if I could take, you know, all this markdown that we're generating and turn it into a react server component instead of having to shift the whole runtime down
[01:25:59]  to do this thing. Like we would just ship the RSC. It makes perfect sense. But to me, I just see that as like, it's just this little
[01:26:06]  tool, this little optimization tool that you have that you can use anywhere. You could use it in an SPA, you could use it with react query, you could
[01:26:15]  use it with SSR, you could use it statically, like we were talking about earlier. The thing with your documentation site, though, on the other side,
[01:26:23]  I think I don't know how much of it needs to be react specifically or whatever, but like, on the other hand, conceptually, that kind of app doesn't
[01:26:30]  need to share much state between pages. Like each page is its own universe, which means that actually Astro plus client routing is basically does solve the double data problem does
[01:26:45]  basically do it is fast. And you get the client side routing. The problem with Astro is when you start trying to share state or trying to make an app, it
[01:26:51]  doesn't, it can't scale up that way. But for something that will never be an app, like, there's a very narrow space where like, right,
[01:27:00]  like the RC. Our first architecture between those with is really difficult, though, I feel like when you have a static site with Astro, right, you'll get into
[01:27:13]  the situation maybe first, we're like, oh, we have a dashboard where it's a specific part of the site that's like, okay, we get really client heavy
[01:27:21]  here. Um, but I mean, I imagine if you went down the road a year or two building an Astro site, and all of a sudden, it's
[01:27:28]  like, oh, you know what, we actually need the whole site to be more app like. Um, I look for like, I look for those tells of like,
[01:27:36]  when is it going to be a rewrite? When, when is it going to mean we got to rewrite something? And that's one of those moments that you cross that threshold
[01:27:45] . And that's a big threshold to cross kind of sucks, too. I, I, I think it's would suck. And except for anybody, even if you
[01:27:53]  like WordPress, you know, it's like, oh, we have this great big WordPress site and it's super cool. Have you ever tried like shoehorning application like
[01:28:00]  stuff into a WordPress site? It's terrible. I mean, it'd be much easier in an Astro site because it's more modern. But, um, yeah
[01:28:08] , I just, there is a really big chasm, uncomfortable chasm between the two. And I mean, I guess you really need to know what your like two
[01:28:18]  year, three year plan is for a project to say, this is going to be an Astro project, or this is going to be an app. And, you know
[01:28:28] , I think it's impressive that Astro can dip into the app area a little bit, you know, and it gets a little uncomfortable. Um, I think that
[01:28:38]  it's more impressive for apps that are now getting to dip back into the static realm of things. And I would wager that like using RSCs in a system
[01:28:49]  that let you mimic a static site is probably less uncomfortable than something like Astro trying to push hard into the application space. But we'll see. I know Astro's
[01:29:03]  kind of like almost like resentfully interested in kind of the client side. You know, they, they dabble with it every now and then I, we talked to,
[01:29:12]  we talked to Fred all the time. Fred all the time. Yeah. We do this. We not stay true to the brand, you know? So, um,
[01:29:18]  and clearly there's no, there's no resentment on the application side. Everybody's like, let's take over the world. Right. Let's have apps take over everything
[01:29:28] . So it's interesting, but that's, that's really the last chasm. I think that is going to exist for a while is like the chasm between purely
[01:29:39]  static and having an application. That makes sense. Yeah. It's, it's, it's interesting because, uh, we've been, I was very concerned about
[01:29:48]  that app walking back to static up from an optimization standpoint. And, um, it's, it's funny because if RSCs had been more successful from a performance standpoint
[01:30:00] , then I might've had something to actually worry about. Instead, what we've found is that, you know, the same thing Svelte has found that the
[01:30:07]  smaller frameworks will scale on those basic use cases to not be a problem long enough. So that like, like, you know, like in a sense, it's better
[01:30:17]  to use Astro, but on the other hand, like their JavaScript load time, hydration time is not going to be a huge impact on that small site anyway. So
[01:30:28]  if there's any potential value scaling past that and you might as well just start there, as long as you're not starting with react, you're kind of okay.
[01:30:34]  You know? So, yeah. Let's see. Data sharing across pages. Yeah. I mean, there's some questions in here. Like where, where is Astro
[01:30:40] ? Like where would it fall short? I mean, Astro you're, you know, there's no client side router. So every single time you you're clicking on
[01:30:43]  a link or going somewhere new, you you're more or less blowing things away. Right. It's really fast. And you have like, you know, transition,
[01:31:02]  like the new wet, like web transition APIs and stuff that doesn't, it makes it feel like you're not blowing everything away, but you are. Um, and to
[01:31:11] , to stop that from happening in Astro you at that point, you're, they would say you're swimming upstream or kicking against the bricks. Right. So, right
[01:31:21] . Yeah. Yeah. And the, where the trickiest part about it is where, um, shared preserve state exists between these places, because, um, basically if
[01:31:34]  client state updates, and then you have the server render the next page in the next section, it will not have those client state updates, which basically breaks hydration just straight up
[01:31:42] . So what RSCs do for you automatically is never render a client component on the server after the initial, um, render. But that's why context is such
[01:31:52]  a weird shape in RSCs and all this kind of stuff. There's like a whole consideration off to the client and then it's all client from their own out.
[01:31:57]  So like, even if it goes back to the server to render server components, the client components will no longer render on the server. So there's like this kind of
[01:32:05]  like, um, like there's a whole bunch of like other complexity. All them isomorphic components. Cause they're not client components. They're isomorphic components
[01:32:11] . Right. Right. But yeah, there's this whole other level of complexity that comes like if you could make Astro do what RSCs do, but then you
[01:32:20] 're like building an RSC like solution. I I've, I've been there that that's what the kind of approach I took with solids, uh, starts Island
[01:32:27]  experimental islands router. I basically built something similar to the view transition stuff. And then, you know, like three years ago before view transitions came out. And then I basically
[01:32:36]  tried to do something smarter that was RSC like, and then kind of put it together. But there was lots of bugs in edge cases, especially trying to figure out streaming
[01:32:44]  and async and knowing what is like trying to solve the double data problem that I was just like, this is a lot of stuff. This is a lot of effort
[01:32:51] . Yeah. Very, very little gain. So I feel like a lot of it comes back to that double data problem too. Yeah. Yeah. You know, I mean
[01:33:01] , it's, it's so, it's so deceptively simple on the surface to say, why, why can't we just send the HTML and serialize the
[01:33:09]  data we need in there and, and then be done. But, you know, so much of it comes back to like diffing and like hydration. And I don
[01:33:18] 't know. I know that you've dabbled a lot in that area and, you know, I mean, we're, we're getting better. Like we
[01:33:25] 're circling the drain, so to speak on like, how can we reduce the data? You know, how can we do it more like partially or incrementally?
[01:33:35]  But it's like, at the end of the day, can you, can you really get rid of double data? Yeah. I mean, if you're hydrating
[01:33:43] . And the tricky part about it is like, from what I've seen, these aspects make a much bigger impact than even resumability from quick and like all these other
[01:33:53]  things we're doing and the less JavaScript code that react is saving. You know, it just, it, it, it, it's, if you're not solving
[01:34:00]  it, then like, maybe we just have to rethink it slightly. Sorry. Some people in the chat were talking about Astro having client side routing. Tanner knows that when
[01:34:08]  he, when he says it's not real, he means that like, generally speaking, they unmount and replace. And I, and yes, there's use transition pers
[01:34:14] ists, but this actually, anyone who really wants to get into the details should watch my stream with Matthew Phillips when they did the Astro three release, even with persist.
[01:34:25]  Um, now you're sharing components, but components that aren't shared have this problem that there is a real estate tearing problem. I actually also covered in my talk,
[01:34:34]  uh, uh, facing front ends, existential crisis. Like this is not something like made up, like there, there is a fundamental gap here. Um, that again,
[01:34:45]  you could kind of build a framework on top of Astro to solve, but there's a whole bunch of specific considerations. Most people building Astro sites won't hit this
[01:34:52] . They're building the dock site. So they won't care. And they're just like, what are you talking about? This stuff works great. Well, I
[01:34:59]  can break it in about 10 seconds. And I did that on stream by kind of accident. I was like, wait, does this work? And then it was like,
[01:35:04]  no, it doesn't. And it's a fundamental problem. Um, so yeah, it's, it's one of those kinds of things where it's like, it
[01:35:14] 's okay. It's okay because that's not what Astro is built for, but it is definitely consideration when you have to look across the spectrum. So what's
[01:35:24]  next? Okay. Yeah. I mean, what, what should we do next? I mean, is that current 10 stack start or, or is there future stuff?
[01:35:31]  Like, should we talk about what's coming or what, where do you want to go? I mean, the main thing that, I mean, we talked about ripping Vin
[01:35:38] ci out, right? Um, the main reason, the, the biggest reason I'm excited about that is because I, I'm looking to do some really, uh
[01:35:47] , low level, like SPA mode type stuff. So the one thing that's difficult to do right now, it's not impossible, but it's just not a happy
[01:35:54]  path is, um, the, the model where you can render out. So you, you have SSR it's, it's an SSR enabled framework, but
[01:36:04]  what you do is, is you render out either a single fallback, like an index.html. And you just say the whole app is an SPA. Right
[01:36:13] . From, and you just load a single index.html to mount your whole app. Yeah. But then on top of that, you still have access to server functions
[01:36:22] , API routes. Like, so there's still a server aspect to it where like, you know, you're, you're redirecting all 404s to this
[01:36:29]  index.html, except for like slash API or slash whatever that you've set up running a server on. Oh, you guys haven't done that yet. Uh,
[01:36:39]  no. Okay. I mean, it is, like I said, it's possible, but it's, there's not a happy path for it. Oh, I see
[01:36:46] . Yeah. That SSR true false actually only refers to the server rendering. That's like, so when you say SSR false, you still get all the server
[01:36:54]  functions and get, get all the. Ours does too, but. Yeah. And the index.html, what's the difference? But if you don't go
[01:37:03]  and pre-render the index, you won't have an index.html. Oh, right. So we did that in our config to automatically pre-render the index
[01:37:10] . Yeah. Okay. I have a branch that does some of that and hacking way, and I just want more better control over the whole experience. So that's one
[01:37:20]  reason why I just, I'm excited to get into nitro and be directly. Um, the other one that is a little more tricky is where you you're doing pre
[01:37:29] -rendering. So you pre-render all of your pages, you pre-render all of your pages, but then you might have some pages that you don't
[01:37:41]  pre-render and your index.html might actually be your static homepage that you don't want to use as a fallback for everything. So we want to have
[01:37:51]  this mode where you can make, make a shell and have all of the 404s go to a shell file, like an underscore shell.html instead of going to
[01:38:00]  index.html. So there's just some advanced pre-rendering patterns and things to do there. Yeah. And I could shoehorn it all into Vinci
[01:38:10] . And, and I might have to duck out for a few minutes, but, um, like we could shoehorn it into Vinci, but I just decided I didn
[01:38:19] 't want to do that if we're just going to end up moving. So yeah, I'll be back in like two minutes. Okay. That's fine. Tanner.
[01:38:26]  Yeah, no, it's, it's fair. It's, I think this is, I'm, I'm particularly interested in this area because as, as Tanner mentioned
[01:38:32]  earlier, he is the original author of, uh, react static or whatever. And, um, like that was kind of this interesting merger of these approaches. But for
[01:38:46]  me personally, I have not looked into this. I've been very much more on the mechanical side. So I know I like, I, I, to this day,
[01:38:53]  I have no clue what Gatsby did. So like, you know, I don't know what these static pieces work. And I feel like this is an area
[01:39:01]  that there's a lot of nuance because a lot of people do have these sites that are basically marketing sites. plus their apps. Right. Right now, when people come
[01:39:10]  to me with that on the solid side, I'm just like, uh, use Astro. No, that's my default for a lot of things, but I think
[01:39:15]  it's, it would be interesting to have a baseline of the framework that could actually like know this sort of thing and like, be able to like work in those kinds of
[01:39:25]  modes. Uh, quite possibly, uh, you, you helped migrate a project from react static to Gatsby. Yeah. That would have been definitely interesting time
[01:39:39] . Yeah. I mean, it happens. Yeah. I mean, I think what, I think what Tanner is saying is that you would have a 200 or 400 or 44
[01:39:51]  HTML page, like from the pre-rendering. Um, my suspicion is that like, he wants more granular control, which I believe you can do through the nitro
[01:40:02]  settings, and then it will serve the rest of the pages. Um, that aren't, I believe there are settings built in to nitro to actually completely handle that
[01:40:10]  use case. But I think it's about deciding how he wants to expose them and see if he can like, instead of running it from a config, that's like central
[01:40:18] , um, you know, like the nitro config or whatever to run it from like his almost like route configuration, which is interesting. Cause when you start trying to approach
[01:40:28]  how to generalize this, these things, it becomes harder to do that. Um, perhaps. Hey, Tanner. Hey, Tanner. Hey, I've just got
[01:40:37] , I have company now. It's all good. I, I wasn't, I didn't ever actually checked with you how long you could, uh, you could,
[01:40:42]  you could stay. Um, well, I mean, it's, it's totally fine. I actually, I was planning on the whole time. I'm, my
[01:40:50]  wife had to step out for something unexpected. So as one does, when you work from home, you just, you know, you do, you do the hard things.
[01:41:02]  Yeah. So that's all right. You know, I honestly, I get to spend, so I get to spend like every waking moment with my kids now, other
[01:41:13]  than when they're at school and I wouldn't have it any other way. So that sounds awesome. Yeah. All right. So the future, I mean, we
[01:41:21] 're getting rid of Vinci SPA stuff for sure. I'm really excited about the SPA stuff and the SSG stuff. Like I want to be able to
[01:41:30]  have a purely SSG site that's code split and data split, like basically react static from back in the day. Um, but I want to be able to morph all
[01:41:40]  of that together in one. So like, if you want to have a route that is SSG with static data, but then when you navigate to another route, it
[01:41:51]  calls a react server component and renders on the server and comes back to you. You know, like I want you to be able to mix all that stuff together really easily
[01:42:00] . And I think we have the right primitives in place today to do that other than just figuring out the react server component environment. And I'm, I'll be
[01:42:11]  honest, I'm just waiting for, I've been waiting for like react router to figure that out. And I, you might be interested to know, I think this actually
[01:42:20]  might lead us to our next topic. If we want to go there. Um, the whole CRA VIT thing has actually suggested that Evan, you, Evan, you actually
[01:42:28]  reached out and it was like, Hey guys, official react VIT migration guide. Like, let's do this. Let's figure out how to make this happen.
[01:42:40]  How to make this happen. And the react team was like, we want the official guide to use RSCs. Um, so like. Hopefully that's hopefully that means
[01:42:49]  that there's going to be more movement there because I mean, unfortunately, it's sad that a lot of this responsibility has landed on the heads of like react router team.
[01:42:57]  Yeah. You know, uh, Jacob, Abby and, and just a lot of the people that react, right. Or they've been, they've been like
[01:43:06]  really. Uh, I, I don't know. It seems strained that they're like trying to push the, like the VIT RSC. integration and environment
[01:43:15]  stuff forward. Um, when there doesn't seem to be a lot of other people who are really wanting that other than me. And I'm like, Hey, I'm
[01:43:25]  still catching up. What you guys can do. Like, I don't have time to just derail everything I'm doing right now to go focus on this.
[01:43:33]  Well, I mean, the only person who's actually kind of done it actually previously was Nikhil. He built RC capabilities into Vinci and he actually went to the react
[01:43:41]  team and was like here. V plug into like, here's how you do RSCs in, in VIT. And then they were like, Oh no, that
[01:43:48] 's not the way we want to do it. And it's fair. Like we're not ready to do that. We haven't figured that out. Um, but yeah
[01:43:54] , I, I just thought, yeah, I don't know if this is relevant or you have any opinions about, about this kind of stuff. But based on what
[01:44:02]  I gathered, it feels react teams hasn't to beat and build tools is how it lines with the vision of react RCs being the recommended pair and how much influence connection they
[01:44:07]  have. So tools to make sure the duration works is designed and can adapt to these iterations. If this is correct, even for the record, the VIT team and void
[01:44:13]  zero, it's a hundred percent opens to establishing an official collaborative relationship with the react team, both in Meta and Vercel to figure out the ideal alignment between V
[01:44:21] IT rolldown and RSCs. The door is open. Also from a conflict of interest in part as author view, I have decided that RSCs are not the
[01:44:27]  direction view wants to go to just wants to make it clear update something. It's update. Someone from the react team has reached out to me, say I'm in
[01:44:33]  gruegously wrong. I apologize if this is not what the react team is thinking. Um, but it, but it's my honest guess because I'm puzzled
[01:44:41]  why as many react users that took so long to beat to be better acknowledged and recommend to it regardless still open proposal collaboration should believe the ecosystem. And then something got deleted
[01:44:49]  that, that, that, you know, that's scratching the surface of like that whole current events thing that, I mean, we don't need to go too deep into
[01:44:58]  that. If you don't want to, it's been very well covered by even people who are in the comments on the stream. Um, but like, I think
[01:45:05]  that, I think that Evan you is like, he, he really cares. He cares about V and he cares about his users being able to do what they want to do
[01:45:15]  with his tools. And so I, it's a difficult place to be in because there needs to be, there does need to be better cooperation there. You know
[01:45:25] , there's obviously people working on next JS for RSCs, but they're using turbo and there, you know, who's going to be the champion for VE
[01:45:36] AT. And I don't think that should unfairly land on, you know, a couple of people from the react router team who are slogging through it likely without a
[01:45:46]  lot of help from react core or from VEAT. Maybe, I don't know, but I, I think I welcome this kind of like interaction for sure,
[01:45:56]  because I think that it's going to hopefully, hopefully just kind of like clear out some of the pathway for this stuff to happen easier. Uh, it's quite possible people
[01:46:07]  have covered it. I haven't covered it. So that's why I'm, I, I am sort of leveraging a little bit of the chance to have you on stream
[01:46:14]  and talk about. We should cover this. I was mostly referring to the, the CRM application docs. Yeah. Yeah. Explosion. But yeah, the opinion
[01:46:26] ated official way to integrate seats, a V coverage in a scope to RSCs. Let the potential opportunity Avenue and VEAT team to work together. VEAT
[01:46:33]  this PR is for a shared package that would support building RSCs with VEAT in its current state. RSCs involve integrating internals react, blah,
[01:46:40]  blah, blah, bundler. Yeah. Cause you use like web pack thing. Very excited. This will potential frameworks to use VEAT like react router seven and Red
[01:46:46] wood to use the same RSC VEAT integration. Each of the, instead of each building their own. Yeah. Thank God. I haven't seen this yet.
[01:46:52]  I'm sorry, but why? Yeah. Never, nevermind. I was about to say something that I'm not going to say anymore. It's fine. I
[01:47:01]  don't want to put you on the spot too much. I haven't actually seen this yet. No, I, I, this is actually, I wasn't, I
[01:47:11]  was mostly just nitpicking what Matt said. I just, yeah. I mean, it is an interesting position. Um, uh, you could tell that there is a
[01:47:22] , like a lot of tension and upset about this stuff. Like the, the CRA thing. Um, I got a bunch of flags on the, on the, uh
[01:47:31] , on the updated thing because they added me, you know, in the GitHub issue and I was reading through and quoting my stuff. And, you know, like if we
[01:47:40] 're so out of touch and blah, blah, blah, like you could tell that people were upset by what I said. Um, and, but the, the updates looked
[01:47:48]  mostly good, except for something about like, if you have a unique, they said something along the lines. Like if you have a unique scenario that would require you to
[01:47:55]  just use beat on its own, you can use beat. But I'm like, this still sounds a little bit, you know, maybe, maybe I pull that up.
[01:48:01]  It's not too important, but you can understand that there's like, there is some sort of tension. And I think a lot of the community doesn't understand why it
[01:48:11]  exists. It exists. Yeah. I think they've been, they've been working through it just like the rest of the ecosystem has. I mean, I, I
[01:48:19] , I made a tweet that was apparently reckless, um, because I made it on a Friday. Uh, that I mean, so Joe Savona, he, he
[01:48:29]  called me and we had a really good chat privately for a, for a good little while. And we, we see eye to eye now on a lot of, on a
[01:48:37]  lot of the things, you know, and, um, but I'm convinced that, uh, like a lot of the stuff that has happened, gotten better with like a
[01:48:45]  lot of this marketing material has happened because we spoke up. Right. Um, at the end of the day, I think that react core team, you know, they
[01:48:56]  have a very, very specific vision for where they want to take things in the future. And for them, that vision is very much all or like not all or nothing.
[01:49:06]  It has to be all RSC compatible. It has to support RSCs and it has to support, you know, the react compiler and it has to support where they
[01:49:18] 're going. Because that's, they're staking everything on that. So why wouldn't they? So I'm not, I can't disagree with them on where
[01:49:26]  their vision lies. Cause I have the same convictions about my visions, right? But at the same time there, there's always something to be said about the way you intend
[01:49:37]  for people to use something and the way they're actually using it. And if you don't listen to the way that people are actually using your tools and you choose to
[01:49:48]  ignore that or worst case scenario, you choose to like isolate them or down talk them, like sound like they're idiots. You better be prepared for churn. That
[01:50:00] 's what happens. If we're talking about, you know, a product, product management, running your own business. If you have a product that's being used by
[01:50:08]  50% of the people, the way that you don't want it to be used and you ignore them or isolate them, you're going to churn 50% of your
[01:50:17]  customers. If that's something you're willing to do, then by all means isolate them and, and, you know, cut dead weight, you know, but I
[01:50:27]  think that would be reckless, which is why people like me and Mark Erickson and many other people in the community are saying, don't do this. You know
[01:50:36] , like don't, don't, don't, don't isolate, you know, the people who may not be using your product the way that you want them to be
[01:50:45]  using it now or even five years from now. Like, just don't do that because one of the greatest strengths that react has going for it. And we talk about this
[01:50:54]  all the time is ecosystem. It's just, it's a big ship to turn, but the fact that the ship is big is what makes it strong. Right.
[01:51:02]  And if there's anything you don't want to do is take a big ship and chop the chop half of it off. Yeah. It's, it's largely why I
[01:51:12]  started being like, maybe I should just shut up, you know, like, like if react is already going somewhere else and leaving, like, why do I have to like
[01:51:19] , you know, kick the door on the way out? I can just kind of let, let react go do its thing. It is, it is, it is
[01:51:27]  kind of a tricky thing because like, I understand like their positions justifiable. And that's why I was saying like, I think a lot of the community were like,
[01:51:36]  why wasn't this the doc today? We're definitely creating create react app for new apps and encouraging existing apps to migrate to beat. It's a create react app,
[01:51:42]  but faster than migration using it. If you're using reactor with create react app, beat provides a clear upper path to using new react 19 side feature, server side of features
[01:51:52]  with reactor, or you can migrate to other frameworks, but that's more work. See, that's a little bit strong, but the react team is almost giving the exact
[01:51:59]  same attitude about not using a framework and probably not worth it. If you're happy with your current reacts single page app thing. I don't know. I mean,
[01:52:09]  that's the opposite extreme. Yeah. I don't know why it's not so easy. Because if it was me, I feel like I would be able to have a
[01:52:18]  vision of this is how this is where I want to go in the future a year from now, two years from now, whatever. But you know, why, why
[01:52:25] , why would I force that on, on people? I mean, the closest thing that I've ever done with something like that is maybe like with making tan stack table head
[01:52:35] less. I took the component version and I very much just decided to like, I made the conscious decision to say, I'm going to chop this in half. There
[01:52:47] 's going to be a lot of people that follow me down this headless route. And there's going to be some people who are like, give me my component back
[01:52:54]  and they're going to get mad and they're going to leave and churn. And I approached it very, very sensibly. I think I just said, you
[01:53:01]  know what, you can keep using the old one if you want. This is the direction we're going. At least I was upfront about it. And maybe that's what
[01:53:08]  they're doing here in a way. But I know from speaking to some of the core team now that every single one of them means well for the React ecosystem. And
[01:53:20]  all of them care very, very deeply about every single person who's using React, no matter how they use it. I just think that there's, there's some balance
[01:53:31]  to be had between the vision that they have for the future and the marketing material that they're putting out. In fact, most of this seems to be a marketing problem.
[01:53:39]  And I mean, I feel like there's, there's companies and projects. Oh, I'm sorry. There's companies and projects in our ecosystem that do marketing better
[01:53:56]  than everybody else. And from talking to the React core team, the stuff that they care about and the stuff that they're working on needs to be marketed better. Like
[01:54:08]  their obsession over the compiler and over the client and making the client faster, you know, like, it was just cool to see Joe Savona talk about it in a way
[01:54:20]  where he's like, we care even more about the client right now than we ever have. Like RSCs are kind of done, like they haven't done anything
[01:54:28]  with RSCs for a while. So hearing him be very passionate about the client and about the same things that I'm passionate about. I was like, well, then
[01:54:37]  this is just a marketing problem, right? Like you just need to let the people know where you guys stand better and update them on your terms instead of everybody else updating themselves
[01:54:50]  with what they want to be true or what they believe is true. I mean, I wonder if there is a bit of a conflict there, because I have talked to
[01:54:56]  the React core team and I get the sense to like the compiler is for the client. It's not for server rendering. And maybe Vercel has better, better marketing
[01:55:05]  capability or like better push on their reach, which is. Oh, yeah. Vercel is like they're marketing geniuses. That's one of the reasons that
[01:55:14]  Vercel, you know, is so successful is because they have wonderful branding and they have really good documentation. Yeah, like they have a really, really great marketing
[01:55:27] , you know, and with that marketing power, they're able to push their narrative and their narrative is obviously RSCs, RSCs, right? Right. So
[01:55:38]  in a way, if React doesn't market what they care about to the public, somebody else will like that vacuum and somebody going to fill that vacuum. But the create
[01:55:49]  React app whole debacle beat debacle feels like it's not that clean. Like someone is like there is a whole thing where Joe's like, no, it's not
[01:56:00]  about RSCs. And then Matt Carroll's like, yeah, it is about RSCs. Like there is a there is like a bit of a reconciliation to
[01:56:08]  be had internally. I think so. You know, yeah. And I think there's also just a mismatch of like it looks like it looks like there's some
[01:56:21]  people who are speaking really loudly for React and doing a lot of the work when in reality there's a lot of people. There's a lot of unsung heroes and
[01:56:29]  contributors to React that you wouldn't even think, oh, wow, they contributed the most code to React last year. You know, so I just think that internally they
[01:56:40]  need to align on marketing and they need to be more proactive about it to avoid that vacuum. I get anybody who runs marketing or know or runs a business knows that if
[01:56:52]  you don't. Yeah, the video says, I think the pilot is inherently hard to build. Yeah, it is like it's hard to market that it's hard to
[01:57:01]  market the compiler. The funniest thing is that was I wonder about this. Maybe it's hard to market it to a React audience felt that is literally felt three. Like
[01:57:13]  that was like the whole thing felt three whole marketing was the compiler. That was literally the whole thing. It was like, look how easy you can just write this. You
[01:57:20]  don't need any crazy hooks. You just do it. So it's like it's it's an interesting thing. Maybe like the people who care would care about that have
[01:57:29]  already moved to Svelte or something and it's like just a small niche part of the market. I don't know. I it is surprising more people aren't
[01:57:35]  using it. It's one of those things that is kind of like a quiet unsung hero. It's interesting. Yeah, the compiler again, a lot of it is
[01:57:45]  marketing, right? So I just think that I don't know. I look at the way that hooks were executed with react and the marketing around hooks was really, really good
[01:58:00] . You know, it was it was so good. I bought it and I migrated and it was amazing. And I just haven't felt the same way about some of
[01:58:11]  the other things, even though they're technically impressive or even more impressive. So I don't know at this at this point like I have I've said my piece on
[01:58:23]  what I care about with react and I care that react can continue to be a very fast implementation of a very popular framework. And and that's really it because the minute
[01:58:42]  the minute that reacts isn't popular enough to hold, you know, to hold its own against other ecosystems. The speed is definitely not something that is, you know,
[01:58:52]  keeping me in react. A lot of it is is just, you know, the ecosystem and the wide sweeping normalization of react components and and hooks and everything like the
[01:59:08]  ecosystem what's holding reacts together, which is why I said 10 minutes ago, like the last thing react wants to do is alienate anybody from its ecosystem. Because react
[01:59:19]  is not the fastest and its ergonomics are not the best, you know, but it but it just has but it has it has a history of success and stability.
[01:59:32]  So, yeah, something caught me in my end chat and I know it has nothing to do with anything. I just want to understand. So like react if you saw compiled
[01:59:40]  vapor. I sorry, I what what is this vapor as a compile target to be interesting. I don't I don't I don't I don't quite get that.
[01:59:49]  Oh, do you know what I think he means? It's funny because solid and felt already compiled to something that's basically vapor, but he's I think what they're
[01:59:59]  suggesting is they could take any syntax and compile it. And compile it down, which is actually what I showed when I created DOM expressions five years ago. If you go
[02:00:07]  on the JS framework benchmark, I have view solid. I have Mobex solid. I have knockout solid. They're actually all. Oh, Theo had a good
[02:00:18]  comment back at 3:00 PM. Yeah, I'll grab that two seconds. I just want to finish this one quick thing just to get it up there on the
[02:00:27]  screen. Just the under. I think people in the view ecosystem aren't just familiar with with my work. But if you look here, here's solid and felt. But
[02:00:35]  if you scroll back a little bit here in the US, this is view using solves compiler. I first released this four or five years ago. Um, this is,
[02:00:44]  uh, knockout using solids compiler. This is Mobex using it. I also made a Preact signals version using it. So like basically view vapor mode is view
[02:00:55]  compiling down to the same stuff that solid's doing. So I guess it makes sense that they can show, look how we can all compile this up to vapor because
[02:01:04]  that's basically what I showed five years ago. Yeah. Interesting. Yeah. I mean, I think it ties into kind of what Theo said in his comment. I don
[02:01:15] 't know if you can highlight or not. I can get up to it. Yeah. Generally speaking, I think the dev world doesn't care as much about perf as we
[02:01:22]  all do. And I think I agree. But I think I generally agree across the board. And then I think there's individual camps inside of there that, that are
[02:01:35]  even more interesting to look at where like, I have traditionally cared a lot about client side performance because I've built really heavy client side apps with data viz and a lot
[02:01:47]  of moving parts. And I mean, definitely not like a linear or anything like that. Right. But as far as you would want to go with dashboards and having
[02:01:55]  a bajillion widgets on the screen at once, that's where I've been. And so client side performance, very, very important to me. I mean, server
[02:02:03]  side performance meant like for the last 10 years is like if I as long as I can get those static files to my user, who cares? Right. But then there's
[02:02:13]  people who live there that are really obsessive about performance there where it's like, oh, I got a lighthouse scores and I got to distribute everything to the edge.
[02:02:20]  Got to get workers involved and I got to cut down, you know, it's very like SSR static server performance. But I think I generally agree with Theo that
[02:02:33]  most engineers, unless you're working on a really intense product or working for a really sophisticated enterprise company, most engineers are happy just getting something out there that works. And
[02:02:48]  if it's too slow or if it gets slow for some people, then who cares? Yeah, no, I mean, definitely. You ought to be pragmatic and the proper
[02:02:56]  solution will have better velocity of more developers familiar and you'll get it working. I think the like the interesting question is how long do you stay on a certain implementation, a
[02:03:05]  certain paradigm for like how long do you sit there and go? Yeah, sure. Generally speaking, devs don't care much about performance, but like at what point do
[02:03:13]  you go? Okay, it's been a decade, there's better ways to do things. Arguably, maybe we should look at that. It's been two decades
[02:03:21] . Like for me now, personally, it's kind of been a decade. I first started on like my experiments that would lead to the first version of SOLID that I
[02:03:31]  did internally in 2016, but it was around now, maybe a little bit later in the year, but it was 2015. So like for me, it has been a
[02:03:41]  decade at a certain point, I'm just like, sure, you don't have to care about performance, but like things over time need to should consider moving forward.
[02:03:51]  Right. I know this is a crazy, another little aside and I'm just fencing chat. Everyone, this is like the new, you know, before we had solid
[02:04:03]  start and you know, these new options would like react ecosystem libraries. Everyone's like, you need like a next JS. And then we built that. Now everyone's like
[02:04:09] , you need native. Now everyone's like, you need native. I, I probably need to understand why everyone's so hyped about react native versus say like Tori
[02:04:15]  or native script or something. I did two streams. People are building mobile apps with solid. I, people are building VR apps with solid and AR and what a vision pro
[02:04:27]  and all, all that stuff. There's a, I did a stream on this, uh, about a year and three months ago. Anyone can check it out,
[02:04:34]  but it comes up every single stream. I just wanted to say, sorry, just we'll get back to the chat. It was just every single stream. Someone's like
[02:04:40] , I would use solid if there's mobile. And it's like every time, like, yeah, there's mobile. Um, I don't think that's the real
[02:04:47]  reason you're not using solid. Uh, I think you were running out of excuses pretty quickly though. So I, yeah, I think a lot of it just comes
[02:04:55]  back to fear of, Hey, what if I get there and I don't have what I have here? Right. I think a lot of it just comes down to that
[02:05:03] . Um, it's, I mean, it's, it's faster, it's familiar and simpler, simple enough, like to react like similar enough to react that it
[02:05:13]  shouldn't be difficult for anybody to grasp. It has a few little things that are gotchas with like destructuring and stuff. But other than that, I think
[02:05:21]  a lot of it just comes back to, well, what if I go there and I don't have this UI library that I'm familiar with or this tool that I'm
[02:05:28]  familiar with, or how do I do X in solid? You know, I, I think that's just a lot of it has to do with that. And I mean
[02:05:34] , personally, so I'm going to plug tan stack a little bit here. Like that's one of the reasons that a couple of years ago I decided like tan stack
[02:05:42]  needs to become completely agnostic. Um, because I, not only do I want to be able to bring that value to other frameworks. Uh, but I, I
[02:05:53] 'm also just trying to future proof, uh, tan stack against what I think is inevitable. And you, we could talk about inevitability and, and what AI has
[02:06:03] , has to do with that, but I don't think that react is the last framework. Definitely not. And I think that thinking that, I mean, this is
[02:06:14]  going to open up a huge can of worms here, but I think. I know you're, you, you have to leave soon. So if people have questions for Tanner
[02:06:19] . Okay. I will open it up and then I'll leave you guys for it. But like people say that react is the last framework because of AI. And I
[02:06:26]  think that that's stupid because like, I'm not satisfied with react, the current state of react and I'm not satisfied with reacts performance. And I'm also slightly uns
[02:06:39] atisfied with, you know, like the marketing direction and like the, the priority where it's being done and like the compiler. So if I'm it, me,
[02:06:47]  a human is not happy with that. Why, why would an LLM that is even incrementally smarter than what we have today? Why would it be happy with that
[02:06:57] ? I mean, I think any sufficiently intelligent system would be able to say, Oh, you know what? React is good for this and not for this, and also be
[02:07:07]  able to pick the right tools to do the thing. Right? So I don't know if that's what we're working towards is like really intelligent agents and AI.
[02:07:17]  Like think through things and like actually make educated decisions. If it's not far off for me and other people. Yeah. Ellens are having more data, not better answers
[02:07:28] . Exactly. And I think the idea in the future is that they start, you start to stray away towards the other side of that. Right. Um, which is
[02:07:36]  why today it's just like, Oh, react is there. It's plentiful. And next JS is there and it's plentiful. And shad CN is
[02:07:43]  just there and it's plentiful. Um, and there's entire models V zero that are trained on the thing. Right. And I don't know. I just
[02:07:52]  think that eventually we might not, that might not be the case. And AI still to this point is still in control of developers who care enough about those topics to push
[02:08:05]  it forward. Right. There was, there had to be a developer somewhere who cared enough about, you know, V zero to say, these are the opinions I'm going
[02:08:15]  to instill into this developer. Like, if I could somehow grab the base prompt for V zero and say, Hey, you know what, prefer react query over SW
[02:08:24] R. What the heck, you know, all of a sudden, it's like, okay, the data can be there. But you can still inject your own opinions into
[02:08:32]  it. So I don't know, that's gonna open a big can of worms. I just I don't think that react is the last framework at all. Um
[02:08:40] , I know Theo has a lot of thoughts on this, but he hasn't, he hasn't released the video yet. I love how we, we, we start talking
[02:08:47]  about things that have like, kind of behind the scenes, but he did stream it. So it's, it's, it's fine, but he hasn't, he
[02:08:53]  hasn't released the video. I, I, I pay attention to Theo's video drops. Nice. Well, Hey, before, before I have to go, let me
[02:09:00]  just, let me wrap up really quick. Um, so if you weren't here when we announced it, there's tan stack solid router is available now. Now I
[02:09:09]  just merged the docs for it. It's good to go, go try it out. I'm sure we'll find some edge cases, but it looks really good and it
[02:09:15]  functions well, which also means that coming out, uh, probably soon. Well, we'll probably be working on 10 stack start solid support because 90% of it is the
[02:09:27]  router and now it works for solid. Um, we're going to be doing a lot of work on getting rid of Vinci backporting that to solid start for
[02:09:37] , you know, taking a bunch of code from analog that Brandon is, has donated, uh, to make the world a better place. So I, I think the
[02:09:47]  future is really bright. Um, and I'm, I'm really excited about 10 stack. Obviously I'm, I'm full time on it now. I have been for
[02:09:56]  about eight months now and yeah, I just, I just really am excited about the openness and, um, just the general vibe. Um, about 10 stack start and
[02:10:09]  10 stack router. I just think that they, they have some really good core values that, uh, have taken a long time. It's been about three or four years
[02:10:17]  since I started R and D for start and, and router as like type safe things. So please go try them out. And, um, Theo has so many unreleased
[02:10:27]  vids, I'm sure. So yeah, go try them out. And if you're interested, if you're watching and you're interested in doing like an adapter
[02:10:34]  for view or angular or Svelte for the router, come join us in 10 stack discord. We can help you get started. We have a testing suite that can help
[02:10:44]  you get going. Um, but I don't know, Ryan, what, uh, I want to hear your, before I go, I want to hear your predictions for
[02:10:52] , for 10 stack based on what you've seen so far. Uh, in, in, in, in specific to what, uh, let's say before, let
[02:11:02] 's say by the end of 2025, what are you hoping to see out of it? I mean, I think tan stack, we already, we didn't talk about this
[02:11:09] , but the way you did the really easy migration from create react app, obviously react router has a edge edge there. But I think, uh, create TS router package
[02:11:19] . Yeah. Yeah. I'm, I think that we are in a place where a lot of people want to see something like tan stack succeed in the react ecosystem. So
[02:11:30]  I'm hoping, I don't know, this is a David and Goliath story. I almost made that the cover of the stream. Um, you know,
[02:11:37]  I mean, I also, I made a lot of things, almost the cover of the stream. I think one of the, I, I almost made, uh, this
[02:11:46] , the cover of the stream. Um, this, you know, do like a Theo style Twitter card cover. Uh, but I figured that was a little bit of
[02:11:56]  too atrocious, but like, I think you've shown with the stuff in tan stack that there's a lot of interest and capability in having this kind of modern types
[02:12:06] cript centric, uh, stack. And this is the, the kind of refinement that tan stack brings to this, uh, is evident in the react ecosystem adoption
[02:12:15]  of the tools and for solid, which doesn't have stuff like that, where it's like, you know, such a big push into that zone. I think it's
[02:12:23] , it's, it's a game changer. I'm, I, I am very much hoping for a future in which, um, a lot of these efforts can
[02:12:30] , can, can merge even further. Cause while stuff like solid start exists so that there's a mechanical mechanism to show off the technologies and being able to have a starter template
[02:12:40] , almost like create beat app essentially, but with SSR. I think that what you have with tan stack started is a, of a product. It's an actual thing
[02:12:48]  that something, you know, that could go up against a remix or next GS, maybe not. It's interesting because you have the Shopify and Bursell backing and as
[02:12:56]  I said, David versus Goliath. But I think, uh, 10 stacks really in touch with where the people and the developers are. And I think that, uh
[02:13:04] , in terms of. What that means for solid is when we. Have that kind of product to go along with the type of innovation, you know, the stuff that I
[02:13:13]  showed off on last stream, we're going to have. Incredible experience. Um, because you can, you're going to have a situation where people can go, okay,
[02:13:19]  I'm going to build my react apps. And I'm going to do this. And because I, I generally like the experience of building on tan stack. And then
[02:13:26]  you're going to have people at a certain point go. Maybe. I don't know. I'm going to try solid. And then. They're going to be like
[02:13:33] , like their minds just going to be blown at that point because they'll have everything that they expect. And then they'll have that just that bit extra, that,
[02:13:41]  that kind of thing. They're like, Oh, I don't have to do this. It just works. What what's going on. Right. I think it's
[02:13:47]  important to like one of the reasons. So interestingly enough, I, I've been approached over the years, many times to raise money and to build products and to do
[02:13:59]  something around tan stack. Um, and I've said no every time just because I think that's a misalignment of incentives for what tan stack could and should represent
[02:14:10]  is I want it to be I'm trying to make it a place where, you know, there's no doubt in the community's mind about who is making the decisions for
[02:14:20]  where we go. The decisions should be made by its users and by the people that care about the product. Um, and obviously leadership as well. Right. But,
[02:14:29]  um, I'm, I'm trying to like, I'm trying to build tan stack in a way that will be able to support me and handful of core maintainers and
[02:14:38]  anybody else who wants to significantly help out. Um, but completely stay away from this whole, you know, we are VC funded or owned by a company with agenda or whatever
[02:14:49] . Like, as long as our incentives are aligned appropriately, we shouldn't be working on anything that isn't directly wanted or asked for by the people that use the product
[02:15:00] . And I think we've done a really good job so far of doing that. And, uh, I'm, I'm living a good, happy life right now.
[02:15:07]  And I think, uh, I'm working, I think I'm already well on my way to making sure that my contributors are doing the same. So, um,
[02:15:16]  that's tough. Yeah. Maybe I doubt it, but yeah, that's kind of what I'd end on is just like, I want hand sack to be the,
[02:15:25]  the people's, the people's tech. Um, almost, uh, unapologetically. And if it's ever not, then it means we're doing something
[02:15:34]  wrong. So that's, that's what's going to allow us to pursue things like, Hey, you know what? We want to go down the road of signals and
[02:15:43]  like, we want to adopt solid 2.0. So we're, and we're going to do it. Why not? You know, we, we control our
[02:15:51]  own destiny and there's, we're not beholden to anybody on the direction we need to go. So let's just do it. Yeah. That's a very positive
[02:15:59]  outlook way to end the end this on. So I'm pretty, I'm pretty stoked with that. Um, I am continuing the stream after Tanner has to go, but
[02:16:07] , uh, um, we should all thank Tanner for joining us today. Um, and I got to duck out. So yeah, if there's any last shout outs
[02:16:15]  you want to give, um, go for it Tanner. Um, uh, yeah, everybody who worked on solid start, uh, or solid, solid router. Um,
[02:16:24]  so it's mostly Burke and, uh, Burke and Brea. I can't remember his name name. It's I see his screen name all the time in my discord
[02:16:33] . Brent Brenly or friendly. It's like Bren's L or something. The Burke and Burke and Brenly. Like they're the MVPs of solid router 10
[02:16:43]  sex, solid router for sure. And then just, if you don't know the rest of the team working on start and router, uh, you should go get to know
[02:16:50]  them. So Manuel Schiller and, um, Sean, uh, Cassieri, these, and, uh, Christopher Robin, who is the smartest typescript person on the
[02:17:00]  planet. So go follow them and check them out. Uh, that's my last shout out. And then I got, I gotta go. Awesome. Thanks so much
[02:17:09]  for joining us. Yeah. See ya. See you guys. The next time. All right. Very cool. Very cool. I don't know if Tanner realizes he's
[02:17:19]  probably still going to be streaming this stream. It looks like, I don't know how it happened, but somehow he linked his Twitter and YouTube to this and it's like
[02:17:28]  still going. So great, great on that. Um, what was I going to say? I was thinking more about Theo's comment, obviously the PNPM thing
[02:17:36] . He's like, sorry for distracting you as always. Right. But I get it. I think this is part of the move that's happening. React is trying
[02:17:45]  to be the more general solution. They're, they're at that point in the curve, you know, like they're looking at WordPress more than they're looking at whatever
[02:17:54] , you know, the current single page app group is looking at solely. They're looking at much wider range of things, which means that, you know, TAN
[02:18:03]  stack becomes the option for those in the know. I think that's basically what the PNPM comment means. I'm, I'm, I'm obviously going to be
[02:18:12]  optimistic because even if we've seen this already with TAN stack query and, you know, all the other, you know, Tanner's libraries, even in a fraction of
[02:18:20]  reactive ecosystem, it's still is much bigger than pretty much most other frameworks out there. Um, so I think it's very interesting to see a competitor or, you
[02:18:30]  know, a different option, at least in, in the zone that, you know, could potentially provide people what they're, you know, what, what they're looking
[02:18:40]  for, you know? So I'm, I'm very excited. All right. How's everyone doing? Oh yeah. Jack was here too. What do you know?
[02:18:51]  Will solid router be based on TAN stacks? Uh, if you didn't catch the announcement, there is a TAN stack, uh, solid router specifically. It
[02:19:04] 's a different architecture. It's built on TAN stack router. Solid router is interesting in that I built it with every consideration of future proofing and where solid's heading
[02:19:12] . TAN stack solid router won't, doesn't have that today. It might change over time as it fits it, but it's, it's more of like
[02:19:18]  aligning with what TAN stack router already does and just making it work for solid. So like for at least the time being, you're going to see the split simply
[02:19:27]  because TAN stack router has a bunch of features and a bunch of things that developers find important. And solid router has every mechanical thing that I see that's necessary for
[02:19:36]  today and the future. So until we can reconcile those differences, we're not going to be able to like get rid of one project or the other. You know, there
[02:19:46] 's, there's, there's a lot of unfortunately pros and cons between the different, uh, choices today. Right. Um, but that's something I'm definitely interested
[02:19:54]  in learning from and seeing where we can do it. I I've approached stuff in an agnostic enough way. And so it's Tanner that there's a lot
[02:20:00]  of ways this can go, can go in the future. You, you're wondering when to use solid star versus Astro plus solid or when to use TAN stack or
[02:20:17]  whatever. Honestly, uh, I think if you're, if, if, if your pay, if your site is conceptually like an MPA where you have pages
[02:20:25]  and you like, like a documentation site or something like that. Um, I would consider using Astro. Like if you're like, Hey, I'm going like,
[02:20:34]  you'll know the pages. Like if you're building a Twitter clone or blue sky, use solid start. Um, if you're using, um, if you're
[02:20:43] , if, if you're like generally just navigating between like, I don't know, some content pages. Astro just has tools set up for you, you know?
[02:20:52]  So I, I think people, I think the choice should be fairly straightforward. Um, like if you're aware of Astro, you probably understand where to use Ast
[02:21:02] ro solid starts, you know, it's like most other meta firms felt kit, Nux, whatever. You can use it to go all the way back to that fully
[02:21:12]  static kind of scenario, but like Astro is good at what Astro does. So, I mean, I definitely give it a consideration. Um, yeah, uh
[02:21:22] , we, yeah, Vinci, there's a devintification going on. As we go back further in the stream, we talk about it, how it, how
[02:21:30]  it impacts both solid start and Tanstack start. I think this is an interesting question. Um, just to address right off, uh, Tanstack router has very
[02:21:42]  specific, uh, needs. We made a general FS router capability that I would say would work for majority of routers in the ecosystem. In fact, the thing that
[02:21:51] , uh, Nikhil did with Vinci, he actually showed the routing conventions of next app directory, next pages directory, remix, solid, even, uh, even something
[02:22:03]  with Tanstack. He basically made all of them work with the same file system routing system that we have in Vinci. However, Tanstack, um, is
[02:22:09]  doing more because of TypeScript and the chicken and the egg problem. Um, he needs to generate like the stub in order to get the types packed so that you,
[02:22:19]  things can type while you're creating the route instead of after you're like saved, saved it. So, uh, the file system routing in Tanstack, um,
[02:22:28]  router is a little bit more sophisticated and specific compared to the general case, which means that, um, those are probably separate things. Good. I'm, I'm
[02:22:42]  still hyped for signals 2.0 too. I've been still making more and more progress on that. Care to touch on that? Well, so what's the easy
[02:22:53]  way to spin a fast solid JS project? Create, uh, you can use our CLI, um, create solid, um, which will give you a beat project.
[02:23:02]  Like it's, it's basically the same project as you also, if you use create beat, um, app and choose solid, both of those are almost identical.
[02:23:09]  They're probably the fastest way to do it. Um, solid start, obviously if you want SSR capability, um, technically you can do solid start without an SSR
[02:23:18] , but I think if you, if you just want to keep it like as simple as possible, you just use the. Because talking about my headphones, uh, whether it
[02:23:27] 's CCA, but. Uh, hypermedia htmax. Yeah. I don't have much to say about it. Um, I, they, they
[02:23:44] , they swap in HTML. Hard to say, uh, I I'm hoping that, that we can bridge the gap. And so tan stack router can do stuff.
[02:23:57]  Uh, there's an interesting question here. Cause it's like how much of the stuff is in design the way it is for 10 stack router because of types versus mechanics,
[02:24:06]  like solid router. Like perfect example, outlet versus props.children. There's actually an important part of that. And we're going to see how Tanner approaches RSCs
[02:24:13] . But I think props to children is better than outlet mechanically. Um, when you consider, um, injection for RSCs and, and the component model,
[02:24:23]  there's like, I was thinking of a future where I would use RSCs in the router when I made that decision. And it has to do with the fact that
[02:24:31] , um, an outlet component can be rendered anywhere, client or server component. Like it's just a component. So you could like stick it anywhere in the tree and you
[02:24:38]  get weird results. Whereas props.children. Props.children. Um, uh, basically it forces the projection through. I, I, it, it, it
[02:24:48] , yeah, I, I think, I mean, that's one, uh, also anchor tag delegation as being the mechanical way. That way you can basically collect anchor stuff
[02:24:58]  on parts of the page that aren't hydrated. I think there's like a lot of mechanical stuff that I took a lot of consideration for in solid router, especially like
[02:25:07]  even the way query and actions work in solid and the single flight mutations, like every piece of solid router was knowing where solid 2.0 was going. So it's
[02:25:16]  like, it's hard to say that this is, um, today, like the, uh, something that we could just say swap in or that you should necessarily switch to
[02:25:24]  tan stack router. Um, and like, um, like long run. I mean, I like that there are multiple options. I also like that, like, if
[02:25:36]  they can converge, this could, you know, streamline things for us, you know, react team doesn't manage react router. So like, I like that potential,
[02:25:47]  but you know, cause there's a lot of features that tan stack router has. It would be tricky for, you know, to implement, but on the other hand,
[02:25:55]  it goes both ways. Um, if you drink every time you sleep, I consider using Astro. Yeah. I'm a big fan of Astro. Do I
[02:26:12]  have a stream? Yes. On mobile. I have two streams. Uh, uh, let's see if I can pull them up really quickly. Uh, YouTube. Sorry
[02:26:25] . Just give me two seconds. See if I can do, if I can get to it. Um, this is a good time to like and subscribe. Be on
[02:26:35]  Twitch or YouTube. Let's, let's get that. It'll help views in the future. Um, like quickly take a look here and see if I can find the
[02:26:46] , the stream. Where is it? Just in case people want to see it. Um, yeah, it was right around. I did a stream with Tanner about a year
[02:26:57]  ago, the future of routing and then dive into native script. Um, let's do that one. Um, and we also have, um, where's the other
[02:27:15]  one? It was right beside it. I did them two weeks in a row. It was helpful because also, uh, Tori, um, members of the solid
[02:27:26] , like ecosystem team docs team also work with Tori, um, Achilla. So very cool too. This talks about Tori, which has the mobile option as well
[02:27:37] . Um, so yeah, I mean, it's been some really cool stuff. Every time we do a hackathon, the native script guys come out and show us
[02:27:45]  a really cool demo too. So yeah. Yeah. Okay. Um, yeah, I mean, you can, you can always, you can use all these things just
[02:28:04]  reading, catching up with chat now. Yeah, we have a universal, uh, render. We there's, there is a solid three, um, fiber.
[02:28:20]  Uh, I don't know how maintained it is these days. Yeah. It's in solid community. So that it's maintained, although it looks like it hasn't been
[02:28:32]  updated, but my understanding is because the way the tags work, I've seen projects built in it. Um, we do have universal rendering on, um, so like,
[02:28:38]  yeah, most things you can do with react. You can do with solid in terms of that, you know, like where you can have custom renders and stuff.
[02:28:44]  We have, uh, we have like solid ink, which is does terminal or is it, or PDFs and, uh, a bunch of, a bunch of those.
[02:29:06]  Um, apparently solid are already work. Yeah. I mean, we haven't tried. I, I wonder if SSR would work. It'd be interesting. Oh
[02:29:20] , someone already. Is this a PR? Did Burke already sneak this in on me? Okay. Okay. Okay. Okay. I, I, I have to see this
[02:29:29] . Give me, give me a second. Okay. All right. What's, what's going on here? What's going on here? All right. App.
[02:29:37] config. Do you have to do anything special here? Plugin, tan stack, the router, solid target, solid. And then what did they do? Source
[02:30:02] . Did they put it in routes? Oh, crazy. And it's not using solids. It is using, it's using solids route convention here. I guess the
[02:30:23]  export construct. Although this underscore underscore is not how we run. Is this the, this must be the file convention. It's tanners took a very similar file convention to
[02:30:38]  us then. Yes. That that's, that's what it is. This is actually using their transform. This isn't this exported. It's exported this way.
[02:30:44]  But the idea of using like the route is the, as the, as the symbol is identical to solid start. So route convention. There you go. That's, that
[02:30:55] 's cool. Look at, look how clean this is. Bang. Living up to the promise. Router agnostic meta framework. That is so cool. It makes
[02:31:08]  me happy that we've accomplished this. I always like. Sketch that this would be possible. But this is what I meant about the shape of frameworks to come. I
[02:31:18] 'm hoping. See. In my ideal world. The base stuff that we use for solid start. Could be the base stuff for the tan stack stuff. And we could share
[02:31:26]  it. And then like, we can keep this low level. And, you know, Tanner can produce his product. And we can keep this kind of low level piece
[02:31:33]  going for, you know, starter templates. And maybe eventually melt it down to, you know, it's more core places, more things into nitro or pieces.
[02:31:41]  But this makes me very happy that the vision that I talked about, you know, two or three years ago at the VConf when I first explained how I thought meta frameworks
[02:31:53]  could work is actually realized today. And I am not saying that today is the real solid start 1.0 release, but man, it's really cool to see separate
[02:32:06]  pieces come together in the ecosystem and just do the thing. Catching up. Yeah, this is a loaded question. It's just a different architecture that personally I feel
[02:32:41]  is more forward thinking. But I mean, to be fair, it existed before React, too. So it's just a different perspective. It's a, it's
[02:32:48]  a, it's a, it's a, it's where your components aren't the whole world. We don't re-render components. We, we have declarative
[02:32:55]  data. It's, it's, yeah, it's pretty hard. I mean, obviously there's benefits, speed, performance, even kind of capabilities, but yeah,
[02:33:06]  I don't think I can summarize it pretty quickly. So I was like, that's an interesting take. Um, we'll see the, the, the, the
[02:33:27]  conceptual win of server components is if you do it the way next.js does. Their implementation doesn't leverage it, but like, if you do it fully the Ast
[02:33:34] ro way, you actually get the benefits. When you put it in loaders or server functions that you get like a micro version, but you don't actually get the,
[02:33:40]  like, it's, it's so tricky. Like it's the reason why I'm not a big fan of lakes versus islands. Although I wrote a whole thing on
[02:33:48]  this and I don't think I ever covered it on stream. Did I? Um, which let me just see here. Following over the react hierarchical scheduling, buying reference
[02:33:59] , swapping stores, are lakes real? I think I actually might've shared this with Jack at some point. Cause it was in a Tanner channel. Um, did
[02:34:08]  I publish this one? Yeah. Just for me, but did I publish it completely? Let's, let's publish it. So everyone can see it. Server components without
[02:34:19]  use clients. This is like a crazy idea I had, how you could reverse, like make lakes performant the same way as server components. And this would fit much
[02:34:30]  better in the thing. You wouldn't get the benefit that I'm talking about in terms of solving double data. But since React hasn't solved double data, like maybe who
[02:34:36]  cares? Yeah, I don't know. Maybe I'll get back to this. I don't know. I've published it now at least, so people want to read
[02:34:44]  my craziness. We do have some time today, probably. I'm just catching up with chat. There's so many of you. Oh, yeah, yeah.
[02:34:57]  We should mention it. Yeah, sorry. I don't even know why I didn't even think about it. I did a whole stream with Lightning.js built on Solid
[02:35:03] , which one of the biggest uses of Solid outside of the web is on TV apps. That's where there's interest from the Netflix team. I don't know. I
[02:35:10] 'm gathering that just didn't end up going to production. But Comcast uses Solid.js for television apps, which is also using custom renders. Yeah, TV
[02:35:20]  apps is one of the biggest places because our memory. Why are you able to edit? You shouldn't be able to edit. Right, only me. Someone messing with
[02:35:42]  me. I don't know. I could give a quick rundown of this in a minute, but let's see here. Moving V6 and Nitro and
[02:36:08]  Nitro VPro are also in dev. I'm hoping that we can get Nitro in dev. That was one of the pieces. Our problem was we couldn't have
[02:36:15]  a single Vite setup because of the way we did server components, which meant that we kind of managed our own dev server with Vinchy. I'm hoping that
[02:36:27]  if we have the environments API and Nitro supports the environments API and we have a single plugin that we'll be able to use Nitro in dev as well, which will
[02:36:33]  open up a huge thing for us in terms of like extra functionality that's available only today in Nitro. We just we couldn't go that way because of the technology that
[02:36:41]  we had. What's my opinion on alien signals in V6.346? I haven't really looked at it very closely, honestly. I've been working on
[02:36:50] , if you've seen my last stream, like a completely different mechanical way of looking at signals in terms of handling the async boundary. So like my understanding is alien signals
[02:37:03]  is very performant. Honestly, my experience so far is that we've hit a point, at least right now, with the performance of the reactivity and that it
[02:37:14] 's not like denting anything outside of like crazy micro benchmarks that have no real world application. So I don't know how important. Obviously, if there's something very efficient
[02:37:25]  there, I'm very interested in it. But for me, I've kind of I don't really I haven't been focusing on the very low level pieces like switching
[02:37:32]  to reactively was faster than solid enough, right? Like it's funny because solid 2.0 is in those benchmarks. No one realizes it's called X reactivity.
[02:37:41]  That's actually solid 2.0, which means it's not as fast as felt or alien signals and that. But also when you pull into like, say, a DOM
[02:37:50]  benchmark or something, not measuring just like how fast you can do like this reactive updates. If it like actually renders the page, you'll see that like solid 2
[02:38:00] .0 is no slower than view vapor with the new stuff or no, not that different than felt five or whatever. You know what I mean? Like, so I don
[02:38:08] 't know. It's interesting that people are making performance improvements, but it's also. I haven't really had the worry about performance and signals for like seven or eight years
[02:38:16] . Like it's just not something I'm really cared about. Like even solid 1.0's performance has been good enough that it hasn't been a detriment. Not,
[02:38:22]  you know, that that was seven or eight years ago. Last time we really touched that, but I'm always open for improvement. People are talking about ecosystem is
[02:38:51]  a number of people solving barriers, substitute problems, running libraries and in common specific use cases. Yeah. What would be depth? They have support for other interesting things like fr
[02:39:01] on jobs, I think. And there's just more features that the, that the Nitro does. Um, uh, they have some web socket stuff. They have,
[02:39:11]  they have like a, there's a bunch of like server features that are, that are just specific to Nitro. Like if you, we, you want to build
[02:39:20]  out a fully fleshed server side framework. There's pieces that go beyond rendering the client on the server. Um, but potentially, uh, but as I said,
[02:39:40]  like, um, it's just, it, it hasn't been like, you, you have to ask always what benchmarks are showing or what they're doing. Um,
[02:39:48]  I think, I think that is interesting. It will be interesting to see if that actually makes any sort of difference. I think it's good that it is faster.
[02:39:59]  I, I, I am very interested to see specifically how it's faster, how it does it, because I'm hoping that it is faster and then, you know,
[02:40:08]  others can adopt that approach. But like, I basically had to completely mess probably even with the performance of the underlying signals to get async stuff working. It's still
[02:40:17]  fast enough to not be noticeable different from solid 1.0, but like, like I, I do wonder if there's a certain class of optimization that won't work because
[02:40:29]  of, because of where I'm, because of like how I've had to change things in order to support the new paradigm. So it's, it's, it
[02:40:37] 's, it's interesting that things are faster. It's unclear if it actually like what the impact of that is. Basic questions, built soldiers from ground up on pure JavaScript
[02:40:58]  directly. I, I mean, I don't know what the mean isn't everything built up from JavaScript. I, I'm not sure. I, I don't
[02:41:08]  sell JS on CoffeeScript originally. It's hard to compare something like Flash and a DOM renderer. Uh, we're only as fast as the DOM can update.
[02:41:41]  And obviously we're a slight overhead on the DOM updates. Um, but the DOM also has, you know, accessibility when you're comparing to stuff like people doing direct canvas
[02:41:51]  with Flutter or whatever, then like, like it's kind of apples to oranges. Okay. I, I, you guys can come up with some more questions in
[02:42:03]  chat. I'm going to do a quick, quick, uh, theoretical thing. Cause I'm pretty sure I haven't covered this on stream before. Um, Tanner inspired
[02:42:10]  me to look at this three months ago. Cause he wanted to know how to do server components and react without all the ugliness. So I was like, okay
[02:42:17] , hypothetical, this is how you could do server components in, in TanStack in the like server functions of the routers without having to use, use client. Let
[02:42:27] 's go. You know, like hypothetical there's because if you get rid of use client, you also, you've only got use server for the server functions. And then
[02:42:34]  you assume everything is client. Now this is not using reacts mechanism, but this is a theoretical, a way of how to point it. The salt support streaming UI.
[02:42:42]  Yes. We had it since before reacted, um, 2020 because a big influence too. I got to mention it. Thank you. Marco, um, Marco pioneered a
[02:42:53]  lot of the stuff in the JavaScript ecosystem around streaming as early as 2014. I worked with a great team at eBay and, uh, I knew that I needed to have
[02:43:04]  in solid. I started that work around 2019 and it delayed solid 1.0 by two years. Cause I wanted to make sure that we had SSR and streaming carried.
[02:43:12]  So thank you for giving me an excuse to mention Marco. Yeah. Okay. Okay. So I'm just going to give this one a quick one. Cause I know
[02:43:26]  you guys probably get impatient with, uh, with going too far on this, but the idea here is that if you're familiar with server components, they kind of weave and
[02:43:36]  you, you can put, you can put client components in server components, but you can't put server components and client components. You have to make the tree connect on the
[02:43:46]  server side, but not on the client side. And what I mean by that is like, um, I mean really simplistic way of looking at this is that like,
[02:43:58]  if you have, if you're starting here and you're like, I'm on the server, right? So like I'm on the server, the top level is a
[02:44:04]  server. So I'm just gonna make this like my comp. Right. And then if you are here, so I'm on the server. Right. And then I
[02:44:13]  have a component. Now this component. Could be server or client. At this point, we don't know where it came from, but if I'm in here. I
[02:44:25] 'm still on the server, right? Cause I'm in this context, right? What I'm talking about here is the concept of projections. So the, the power
[02:44:37]  of, of server, like we can pretend that this is a child component the, or sorry, client component, client component, but the power of, of, of this
[02:44:48]  kind of pattern here is that we can nest these as deeply and as many as we want, but be a projection. The server tree is still connected because here I am again
[02:45:04] , still on the server. So like through this mechanism, this is a connected tree, um, on the server. You, you're aware of all the client components
[02:45:14] , which means that if you were say doing data fetching out here and you know, if you were doing, you know, maybe there's another server component wrapping here,
[02:45:24]  let's, let's go server component. What you're going to see is it is possible from, from, from looking at any given server component. There we go
[02:45:42] . Like starting from this to start point to basically do everything without water falling, like not going back and forth in the client, because I'm still on the server here.
[02:45:51]  Even though this is being passed to a client component, as long as I like start on this outer context, everything I see here, this could be a placeholder essentially
[02:46:01] . But everything I see here is on the server, even though like the implementation of the client component here is on the client. Everything's on the server, which means that
[02:46:10]  as I said, if this updates, like some state or whatever, like I could like, there's no waterfall between this updating and going to the client and then this
[02:46:20]  updating. If, if, if, if, if, if it was the other way around and this was a client component, right? And now this is a server component
[02:46:31] . So now I'm still on the client. And then this is going to be a client component. So I'm just switching these around and this is a server component
[02:46:55] . Like if you were able to import. Yeah. Still on the client. If, if you were able to import server components into client components, then you have this
[02:47:09]  inherent waterfall potential because if this updates and the server component decides whether or not to render its children, like you basically have this cascading thing, like we're not showing
[02:47:29]  it, but like where you can cause inherent, you can cause waterfalls in inherently. This is why react server components are the way they are. They, they aren
[02:47:39] 't reversed. Even though we'd love to think everything in the client is because it's innately waterfall incurring to switch the, the, the, the, the thing
[02:47:48] . It's funny. There's a lot of similarities between the light dom and the, and the shadow dom with the web components. Um, but this is like, this
[02:47:56]  is why it fundamentally this way. It's the same thing with Astro, right? You can't put Astro components inside react components. Like it, obviously that
[02:48:04] 's a different file function. React doesn't understand what Astro is. Right. Yeah. Yeah. Yeah. This, this, this, this is what I'm missing
[02:48:12]  in the example, right? Like if I have the server component, have some kind of state, like show children, you know, it's based on like some kind
[02:48:24]  of state here. Show, you know, like this inversion is why it's, it's possible that like, what if this client component does some update that impacts the
[02:48:39]  server component, like you're in the beautiful thing about server components is because it's all part of that continuous unbroken tree, you can resolve the whole unbroken tree and
[02:48:50]  send it in a single chunk. Like, there will never be a waterfall. Whereas the inverse is not true. The, the, um, yeah. Is the cascade
[02:49:02]  really bad? It can't be. Well, you don't want the client to go like, okay. Like pretend it's like a page load. Usually you could
[02:49:14]  probably solve this with hoisting or maybe not, but pretend it's a page load, like pretend like you're like, okay, I'm loading data. Now I
[02:49:20] 'm waiting for this. And then I go like, so, I mean, do I have to do a, an Excalibur on network diagram here? Um,
[02:49:28]  but like, like, have I done this network diagram before? Like, if I go back far enough, will I have already done this one? Like, is this
[02:49:38]  a version of it? Um, no, this is server islands. But like, what I'm getting at is like, if you, you go to the server, you
[02:49:50]  get the HTML back, which has a JS tag, which go to the client and you go back to the server to request that JS, get to the, now you're
[02:50:00]  the client with the JavaScript. And then now you're rendering it and you go, I need some server data. So you go, okay, I'm going to go
[02:50:09]  to the server. And then the server responds. And then you're like, okay, I can render some more. And they're like, I need to go to the
[02:50:14]  server again. That's cool. Like you, you're just cascading the whole thing down. It's the worst kind of waterfall you can imagine because it's,
[02:50:22]  you're doing, you're paying the full net network request. server points flip that on the head. So like now you're doing all the data fetching in a
[02:50:29]  single go. And even if there's a render cascade, you know, that all the data is, is going to be in a single thing. And this is not true
[02:50:37]  just of initial rendering, but on, um, update. Now you can do this other ways. You can hoist the routing to a level in which, you know,
[02:50:44]  all the changes are happening with like in a client side router or stuff. But generally speaking, just purely the pattern of doing server components, the opposite direction would be terrible
[02:50:55] . Like just the worst possible thing. Like, it's just like, there's no way anyone could recommend this as an architecture. Um, it just doesn't work.
[02:51:04]  In fact, most people who've done this opposite approach don't let you go back to client components. Essentially they have server components, but that's where the buck stops.
[02:51:13]  You don't get to put client components back into it because it's, it's just an inherent waterfall. I think Waku tried to do this originally and the React
[02:51:20]  team was like, no, no, no, no. Don't do this. This is craziness. And like, oh, well maybe the develop, like you can
[02:51:27]  avoid it in certain way cases, but generally speaking, this would be like the biggest foot gun React could ever release if the rules were different. So there is a very good
[02:51:36]  reason that server components are the way they are. So like with that kind of basis in mind, um, I'm like, okay, can we actually make this backwards
[02:51:56]  approach work? Because the thing I didn't show you in, in this, in this backwards approach is like when you're in a client component, you get props about children
[02:52:05] , right? That's kind of like the secret. Like when, when you're in a, when you like, when you're in the initial thing, the props
[02:52:13]  of children, you get sent in from the, from the server, you know, in your client component or any prop you get, it's just serialized and React just
[02:52:23]  inserts it. Like you, you don't have to introspect it. The fact that it's not imported, the fact that it like, it lets it keep the tree
[02:52:29]  because, because it's not like the, the fact that the, it's a prop, I'm doing such a terrible job of explaining this, um, means that
[02:52:40]  it's, it's, it's, it's, it's part of this continuation. Um, so can, can we invert this? Okay. We have four things
[02:52:51]  working for the client is persistent. We don't actually need to serialize everything to communicate it. Lakes don't require the same level of compiler gymnastics. Server functions are
[02:52:59]  sufficient while we don't have to solve serialization, duplication, client routing just works without a special order. Okay. That's attractive. Solves JSX on the
[02:53:06]  server, already outputs HTML, blah, blah, blah. Okay. So what's the concept here? What if there's no use client only use server, but via wrapper
[02:53:13] , certain server functions can be denoted as components. So this is, this is kind of, um, this is something I was talking to Tanner about, right? Where
[02:53:23]  you could basically like, say like, I mean, it could be used component or something, but it's the idea is that you could say that a server function is
[02:53:31] , is a component, right? This API is not set in stone. I just did this as a wrapper. Tanner likes wrappers, but generally speaking, it could also
[02:53:40]  be just use, I use component, but it's, it's, it's, it's basically a use server call. Um, use cache from react got me,
[02:53:48]  you know, thinking about this a little bit, but the idea is, you know, you'd fetch your data and then instead of returning, um, JSON, you
[02:53:56]  return the server component. So this is like a loader conceptually. It's a server function, but it's a loader conceptually. Yeah. So the question
[02:54:08]  you see here is what the hell is props dot children in, in this, in this component, right? Cause this component takes props, right? So there is,
[02:54:19]  there is that. And then here's an, in your client, you would get this back, this component, the server function, and then you would just, I don
[02:54:26] 't know, stick it in here. And then I'm taking this data and I'm using as a render prop here. So we're kind of acknowledging that the client
[02:54:36]  is going to render whatever you do with this thing. Like I could have rendered more here, but the idea is the props dot header and the props dot children are actually client
[02:54:45]  components, um, coming in. And the only thing being rendered on the server here is the div and we're calling the thing. I know it's, it's kind
[02:54:54]  of crazy, but keep in mind, um, there's no use, everything's client in this model. Right. So, and then here are the IDs props ID
[02:55:04]  this year. And then we're using a render function. You serialize all the normal arguments. JSX would be, uh, named placeholder and, and function would
[02:55:12]  be serialized as a placeholder of sorts. So what I'm suggesting here is what these props are. Like when you serialize this, like when you call the server
[02:55:20]  function by rendering it, essentially, um, what, what these props are, um, are, uh, how should I put it? They're like props to a
[02:55:30]  header just needs to be a marker. It doesn't need to actually be the rendered header component. It's just like some kind of silly marker. That's like, that
[02:55:38] 's like, this is header just because you need to know from the outputted. HTML where to actually go and replace and insert the client rendered header at the end. Cause
[02:55:49]  this could be here. It could be not rendered. It could be somewhere else. What's cool about this, as I said, is the server can decide which client
[02:55:54]  components get rendered. Essentially. Um, this is, this is crazy backwards, but on the server placeholder would remain opaque. Functions would be a function that serialized
[02:56:06]  the arguments passed to it and return a placeholder. Whenever an ID or header changed, it would trigger upon return to do the appropriate place to place, uh, placeholders
[02:56:14]  and call backs on initial SSR. The component would be treated as async. Sort of like a lazy component. It could trigger suspense, handle streaming. There might
[02:56:21]  be a few extra placeholder elements in the markup. Props could be inserted as many times as desired. Um, so, you know, yeah, I'm just
[02:56:28]  showing more examples. Where things are fun is nesting. Certain waterfalls are unavoidable. Um, always, right? So if you have some server data and you
[02:56:37]  pass it in and then the client renders, uh, another server thing from it. However, if all data is available above, like from the URL, that wouldn
[02:56:48] 't be a constraint. Like if the dependency is purely a layout. And what I was showing here is that, um, what am I showing here? I basically got rid
[02:56:56]  of the render, the second render function. Did I know? What did I show here? However, the, I wrote this a long ago. I can't remember.
[02:57:07]  If the data is available, like you wrote, you wouldn't be constrained though. Oh, I'm saying that. Yeah. This one's depending on this data,
[02:57:18]  data, data ID. Where this one isn't depending on the user data. It's actually only depending on something that's kind of known here. So these are two
[02:57:35]  different server components nested inside a client. Yeah. I mean, seeing this stuff visibly is always tricky. I think it's even hard with RSCs to understand
[02:57:45]  like, which is which. Like it's, but it's the same idea. You, you have to actually look like where the component is like, oh, is
[02:57:54]  that a used client over there? Is this a server component over there? Using render props probably had it for waterfalls, but it means that, but it's a means
[02:58:00]  of injecting data. I mean, you could always hoist yourself. I'm just showing examples of where you could say like, put the server component up here and then
[02:58:07]  insert it later here. So now they're, they can be parallel. They're not nested. Without render props, if someone did something like nesting server points
[02:58:17] , they could be parallelized. Right. That is true. Nothing. Because the server can, because the server cannot be an input to this component. It would be possible
[02:58:32]  even if the server renders it children 10 times for the client to run this code exactly once and just replace it 10 times. Yes. Basically because the server can't
[02:58:43]  provide any props into this when you have this transclusion. It's not perfect because server still decides overall visibility, but it might be acceptable. The bit like when you ho
[02:58:51] ist data fetching, you might never need it, but you can do it because it can be parallelized. So what I'm saying is the server might over render stuff
[02:58:58]  that doesn't get shown, but technically speaking, there's no waterfall. So then I was like, okay, can we solve hacker news with this thing? Because could
[02:59:08]  this work and save on double data? Well, let's focus on the first part. Just because we moved the client components on the server. For those who aren't familiar
[02:59:14] , if you've never seen a hacker news demo, hacker news. Do I have any on here? It's been so long since I've looked at them. They're
[02:59:25]  not like shortcutted anymore. Hacker news. I'm just going to jump to here and I'm sure one of these will be fine. View it here. This
[02:59:39]  is the original client side one. Okay. It doesn't matter. I can show what I want to show. The idea of the hacker news demos, this is all static
[02:59:46] . It doesn't need to be duplicated and the only interactivity are these collapsing comments, which is a pain in the ass because if you want to like, um
[02:59:52] , they're recursive. So it's not easy to like shrink the page down because they they're like, it's kind of annoying to have these interactive parts.
[03:00:02]  These are like islands and islands and islands. You can't cheat this. So I took, you know, a story and said, okay, let's pretend that each story
[03:00:13]  is a server component, right? So you have to get the story by ID and then it gets the ID from the client and it gets the children. And then what
[03:00:23]  did I do here? So this is the main story. So we are, yeah, this is react like syntax. I'm doing your story dot comments. If there are
[03:00:30]  children, comments map each comment. And then inside the comments, if the comments have comments, map them here. And again, I'm passing down essentially children, which
[03:00:44]  is the client's children, which is so crazy to kind of think about how this like inception works. But the, this children becomes this children here that gets called as a
[03:01:00]  function. um, this is all to get down to the actual client component, which is the toggle, which actually wraps these server components. So, um, yeah,
[03:01:15]  it's taught what I'm showing here is a story and the children is a render function that takes the comments and passes the client toggle to it. Right? So essentially this
[03:01:26]  children gets used multiple times to wrap the toggle around each of these server components. So each comment gets mapped to like each grouping gets mapped to the children. So this children
[03:01:38]  function gets called potentially multiple times, even though it's passed here. And this injects wraps the client component around the server combined stuff. Well, the, the thing
[03:01:54]  is every component is assumed a client component, unless it is created with this annotation on the, it, but the point is with this inversion, I mean, it could be
[03:02:06]  used server component. It's basically saying that the only thing you annotate are the server components. You don't annotate the client components because everything's assumed to be a
[03:02:13]  client component, unless it otherwise. So technically this works, it's worth pointing out to get fine grained rendering. We'd probably need to talk in proxy object,
[03:02:24]  like in solids, all the callback functions, return proxies that were data diffed, I suppose. Okay. Yeah. I'm getting ahead of myself.
[03:02:29]  So I started talking about like how you would serialize this. These are the placeholders. And it kind of shows that like, essentially like ID one refers to this
[03:02:40]  ID. So like you, you'd put toggle ID one. And then like, this is probably too advanced for most people to go through. But I think the hardest part
[03:02:55]  of this is recognize props required for re-render versus not or props for cache keys or stuff. Things like JSX or those render functions aren't really props as much as
[03:03:02]  pass-through projections so that they can probably be ignored if the assumptions they aren't inspectable. Like we don't care if header changes, maybe. Right. And
[03:03:11] , and, and this is where you start getting to the crux of the problem here. Like this is purely layout consideration. This, this gets passed through to the server
[03:03:21]  function, but the server function may or may not decide like to change it or introspect it. Like, do you, every time you change this gets changed, do
[03:03:33]  we need it? But then I was like, wait, no, if header on the whole page, we could care. Like a fine grained update. It doesn't
[03:03:40]  matter. Maybe that's fine. Blah, blah, blah. I'm talking myself a bit, but. But without having prop types, we can't make any assumptions
[03:03:47]  on a runtime. The optimist is preload because JSX types, even if you didn't have JSX to pass in, you need to pass something to do
[03:03:53]  it at runtime. Preload is a thing here because you can cause waterfalls and you have multiple server functions through your app, sort of like API. So it's,
[03:04:03]  it's, it's a little weird. I'm okay with that, but complexity. Okay. I don't even know what I was saying here anymore. I think
[03:04:08]  I was just trying to show people pre using preloads with these server functions. Okay. So the real question here, does this fix anything? Does this solve double data
[03:04:20] ? Not on the surface, but look back to our to do example. Everything passed to our render prop from the server needs to serialize all the comments. And we avoid
[03:04:29]  duplicating that in the HTML. Well, unless we don't, I guess the same considerations apply reversing the template around rendered HTML. One thing that can be done
[03:04:36]  is reconstruction only from serialization and not as part of the HTML. This would need more code up front, officer doing things. But to be fair, lakes are silent here
[03:04:44] , make no difference. This is the same mechanical issue, which brings it to me too. Honestly, this is just a different API for the same thing. So the positive
[03:04:50]  is it isn't really all that different from the work Nikhil, Alexis, and I've done in the past and talked about doing more in the future. Tanner inspired me
[03:04:56]  to look into this. And after sharing my thoughts, he seems more excited by the result than I am. It's cool that there's no need for use client and that
[03:05:02]  something nice about just basically making any old solid or react components server components simply by running it on the server in a server function, truthfully, because it can be made
[03:05:10]  granular. You can have four different server functions being called in a route section and preload. But so you could say invalidate one of them similar to the way we use
[03:05:19]  like react query, like we could get granular updating server functions this way. Unlike like the all in RSC thing where you're like re-render the page. But
[03:05:28]  in reality, you often want to weave the rendering like I showed in the hacker news. So is this power that important? I don't know. Honestly, I need to
[03:05:35]  make more sense of why I want server components at all. This approach is the least obtrusive. Nothing really core mechanism I thought of so far. So it leaves room
[03:05:44]  to experiment, but it isn't long before you hit the same problems again. And I think I have a more important things to think about right now. So yeah,
[03:05:53]  this is old news. But I do think if someone wanted to pursue this, it is possible to to essentially because the client never goes away. This is the opposite on the
[03:06:08]  server. Each request is unique. So like you could do persistence, but generally you treat it like each request is independent. This approach leverages the fact that it can
[03:06:18]  kind of use the fact that the client's singular to basically serialize functions. This is something that you can't do very easily with server functions. And Quick had this crazy
[03:06:28]  thing they were doing where they were like lazy loading the code and doing all the stuff for serializing it. This is serializing functions like the render callbacks that I was
[03:06:36]  showing here, simply because the function's already on the client. So like, and it never goes away. So this is actually very easy. You don't actually need
[03:06:45]  to worry about like crazy closure extraction or anything. This actually just works. So the magic is that you can basically build this whole mechanism off the ability to serialize functions.
[03:06:55]  But on the other hand, it doesn't solve any of the fundamental problems. So I don't know. I'm sure I lost most of the audience with that crazy offs
[03:07:02] hoot here. So I apologize if it's not your cup of tea, but there is a world where you can, could denote only server functions, or sorry, server
[03:07:15]  components and not, and keep everything client and basically get the benefits of the system. I just, I'm, I'm still kind of a bit lost on it. Tanner
[03:07:28]  did, as I said, he's interested because he's, there's things that we can do with HTML and like other serialization formats that are kind of interesting.
[03:07:38]  But this seems like a lot of work. This seems like something that someone would really have to invest their time in. But I like at least theoretically putting it out there.
[03:07:47]  It's interesting. Well, I mean, Tanner, Tanner, uh, was excited. He still was thinking that this might be an approach we wanted, we would want
[03:08:11]  to do. Only discipline appointment. I don't like the reactive scripting. There's certain problems that are just really, really hard. And as much as we want them
[03:08:21]  to be solved, they're not easily solved. Like all of those, there's a whole chat on the 2.0 stream where people are trying to convince me to
[03:08:28]  change solid into Svelte 5. And I'm just like, guys, like no one's solved this. And as long as JavaScript exists, no one, and it
[03:08:37] 's the language you use and it doesn't change. No one's probably going to solve this. You know, it's just a bunch of calculated trade-offs. That
[03:08:44] 's why I get excited about the things I can solve. Like the stuff I showed last stream about async signals and, uh, you know, healing error boundaries and
[03:08:54]  all that stuff. That stuff is truly exciting. Um, and it's solvable. This stuff? Maybe not. Whoa, whoa, whoa. Is this actually happening?
[03:09:17]  Oh man. We're finally able to ship observables in Chrome. It's been a long time. Thanks in the community. Okay. This is interesting. Cause they
[03:09:26] , they didn't get in through. TC 39. So they ended up getting in through like, what, what is it now called WICG or like whatever the web
[03:09:35]  thing is. So instead of being a JavaScript standard, they got in through DOM APIs, which is so funny because it's, it makes sense because events are events.
[03:09:44]  So representing them as event streams is, is like it may, it matches. And I'm, it's funny when we did the signal stuff, everyone's like, oh
[03:10:00] , now we can put signals in the DOM. Like, like next level, like maybe, you know, events coming out or maybe just wire it straight to signals. And
[03:10:08]  then everything just auto updates. It's, I mean, it's an interesting potential feature. I just, you got to caution people about the implications of it. It
[03:10:17] 's very weird for me for observable API to come in through the DOM rather through TC 39, but it's something they've been trying to get in for ages. So
[03:10:24]  maybe this is the best way through, um, because this has implications. Cause if it's in the DOM, it's likely that people want it in regular JavaScript.
[03:10:33]  It just doesn't feel like it's the right place to come in. But I mean, I think they'll take anything at this point. Yeah. I mean, if
[03:10:45]  you have no reason to switch frameworks, don't switch frameworks. On the other hand, I mean, we're getting to this like crazy zone where it's like all the
[03:10:54]  major frameworks have been around for like seven years and the dial hasn't really pushed on them. Like at least like views over 10 years old at this point as well reacts
[03:11:03]  over 10 years old. Obviously it was at least first in 2013, uh, view was first released, I think the end of 2014 or beginning of 2015. So view just
[03:11:12]  hit its 10 years. Like it's, it's not a concern about like the frameworks, like disappearing, like in that kind of time range, you know, but on
[03:11:21]  the other hand, if you have no reason to keep switching, you don't have to keep on switching, you know? I mean, there's always new innovations and
[03:11:29]  stuff. Some are ahead of others. Just pay attention to, to things, places that are doing interesting stuff. And if you want to play around with it, play with
[03:11:37]  it. But generally just do what you do. PHP. Yeah. I used to use PHP 20 years ago. Yeah. Abort signal think growth didn't win.
[03:12:07]  Yeah. Which is why it's in fetch, which is also why it's so weird because you can't like abort promises. You can only abort certain things, which is
[03:12:15]  why I don't, it's almost why I don't like, I can cancel stuff in the framework. And by the time you've sent something off, it's hard
[03:12:21]  for abort. Like there's a lot of power in abort signals, but there's also like, because of the way it came in, it doesn't, it's
[03:12:27]  not general enough. It makes it hard to approach it from like a framework standpoint. Like if you assume everyone's using fetch or using like specific like DOM APIs, that's
[03:12:36]  fine. But then it's like, not universal. Like you can make your own canceller in a sense and manage it yourself. But then at that point, it's
[03:12:43]  like, you could just manage it yourself. So yeah, it's very, it's tricky. Yeah. Views 11 years. Yeah. 10 years last year.
[03:13:02]  Yeah. That makes sense. But I mean, we're getting it. So, I mean, that's exciting on its own. I think there's, as
[03:13:27]  I said, I think there's a lot of value in having streams. And part of, I showed earlier, create async, taking async iterables. Async
[03:13:34]  iterables to observables is a straight path. I don't think we'll need stuff like the from helper or whatever in the future, because it'll just be part
[03:13:40]  of our model just to naturally accept these things. So set up for it, you know, we've designed the primitives. I think we're in a very different place
[03:13:48]  now from like 10 years ago when people like were proposing this stuff. We've actually have standardized on some other primitives and the interop is existing. And so like,
[03:13:56]  there's a good story there. I mean, they are general enough. I mean, I've been using, I remember when there was the TC 39 observables proposal
[03:14:15] , I actually built solid on that at one point. I was like, I had signals kind of like knockout style. And then I was like, I was like,
[03:14:23]  oh, everyone's gonna use observables. So maybe I could see if I can use that. And then I was like, okay, wait, this is not the right
[03:14:27]  fit for the problem. But I had to actually go through that. Like one of the, I had a stream where I showed the history of solid. I showed the commits
[03:14:34]  before open source it. I showed the two years before anyone got to see it, like in my private repo and show code snippets. And there were observables in
[03:14:43]  there, one of my experiments. Yeah, I don't have as much today. I mean, so, and unfortunately, I think I covered a lot of this week in
[03:14:55]  JavaScript topic, but we can, we can, we can, we can switch, we can switch over here. This week, been short week for me because I've been
[03:15:02]  working so hard on the signals, API stuff. Anyone who knows the Discord chat has been off the hook. Everyone was really excited by the last stream. Everyone had ideas
[03:15:11] . People had questions. They wanted to know. Everyone was trying to sell me on their own API for create effect. You know, like trying to convince me that stuff thing
[03:15:22] . I actually worth throwing out here. I already showed this. Maybe for this week in JavaScript, I should just do a quick cover of this. It's kind of
[03:15:36]  a follow up for last stream. And this is specifically on the, on the concept of basic effects and events for solid 2.0. So, but let's talk
[03:15:47]  about it briefly. I know this is probably not everyone's topic, especially if you didn't see the last stream. But I think it's pretty cool because we're talking
[03:15:57]  about a world where signals are async and can throw in execution without completely throwing away your UI. And in the case of stuff erroring, we can pick up the
[03:16:10]  threads, retry things all automatically, just simply because of how the graph is wired. I showed this demo last week, I will show it again. Very quickly, just
[03:16:22]  so people have a basis. I've made some changes, you know, since then that aren't in here. But I think it's fine for us for what I'm
[03:16:23]  showing. What this example has is it has an app that renders an error boundary, top level, and then it has this phrase counter. This phrase counter fetches
[03:16:44]  two pieces of async data. One is just general like page loading data, which is just hello. It's just the greeting. The other one is a counter that's
[03:16:54]  triggered by the signal and it gets a new phrase. And then I also added this upper phrase, which is like a derived signal, just to kind of illustrate how, how
[03:17:07]  this works. And so technically this, you see this phrase to uppercase. If this phrase was undefined, this would error out because there's no two
[03:17:17]  uppercase of undefined. So essentially, this is, if you look at the types here, even though this is async, it's not there originally,
[03:17:24]  you're getting an access or a string, not an access or string undefined. And the reason is because we're using throwing to guard kind of like react, except
[03:17:31]  it doesn't throw away the whole component. It throws inside the specific binding that uses it. So down here, well, phrase is used in upper phrase. So this
[03:17:41]  can throw and this can catch it. But this also, it's not done yet until it finds a sync. So technically this gets raised here, which can be thrown and
[03:17:51]  caught. And then this can be also in here, which is where we display our actual message, which can be thrown and caught by this inner suspense. Which is why
[03:17:59]  when we load, we're going to see two suspense boundaries, initial phrase, and then this one. This can also error though, because dev made it go on random that
[03:18:09]  half the time we do this, it's going to error. But essentially you'll see double loading, loading, loading, it's loading, loading. 50% time means
[03:18:18]  lots of errors. There we go. Didn't error. Okay. Right. So why does this example matter? Well, I was trying a new model for suspense where
[03:18:34]  it only goes to the suspense boundary initially. And then we can use stuff like this as stale check to give affordances like graying this out and whatnot while we change
[03:18:45]  stuff. So nothing too fancy here. The thing you have to understand though, is this is solid. So when I say console logging rendering phrase counter, or when I say
[03:18:54]  console log rendering message, it's only going to run once even with the suspense and the update. And the reason is because we could just render the stuff off screen and
[03:19:01]  then insert it when the ace, when the everything async resolves. So we never have to re-render this p tag, even though we're changing the text.
[03:19:08]  Initially, we might throw in here in the side, this render effect, but we don't have to re-render any of this. So when we go and I
[03:19:13]  look at the console here, what you're going to see is render, rendering phrase counter, rendering message. And even though, okay. I mean, this one aired out
[03:19:21] , but even come on, don't air out. Sorry. Hex it. You know what? I'm going to, I'm going to turn off the airing
[03:19:29]  out for a minute so that I can actually show what I'm trying to show. We'll get back to the errors. Okay. So refresh again. Okay. See phrase
[03:19:36]  counter. Hello, phrase, even though it kind of loaded in, it only called rendering once. Um, and it being classic solid, if you click it to update
[03:19:43] , it's still not going to call render again. Cause it, it's just, it's just the way we work now, obviously this is, this is fairly straightforward
[03:19:52]  stuff, but what was cool about this example is that when we added the errors, this example does two things that are special. First of all, um, the more obvious
[03:20:04]  one is if there's an error and you click the fetch new data, it can automatically, I mean, it's actually airing again over and over again. We
[03:20:14] 're just like rolling the dice really badly. It can actually replace the error boundary, um, automatically without you clearing it. Now, if this was react, you'd be
[03:20:24]  like, no kidding. It can do that because you're updating something up here and the error boundary is down there. It's below it. You're re-rendering
[03:20:33] . Well, again, if we look here, you, this whole set, you will never see rendering message again, because we, we are actually never re-rend
[03:20:42] ering. So actually this trick isn't based on us re-rendering more that when the error defects under an error boundary realize that they're no longer error, they
[03:20:53]  can clear themselves and, and then change their state without re-rendering any components. So yes, react can do this technically speaking, but we're doing it without
[03:21:05]  re-rendering. We're, we're, it's just the, when we do that state, it's no longer aired. But I think the more,
[03:21:14]  the part that got people more excited about this example is that, um, let me see. Cancel. Don't save. Yeah, I'm not. Okay. Okay
[03:21:24] . Well, people got people more excited about this example is that if I click this retry button, which is down, down, down, down. Let's clear this
[03:21:35]  out. If I click this retry button, which is down here above, you know, the message here. Remember the fetching is up here. It will actually
[03:21:46]  refetch the data. And the reason for that is it knows again, which effects under here are aired. And it just will go, okay, well, I'm ret
[03:21:56] rying this bounds. I'm going to take those aired effects that I collected before. And I'm just going to say retry them and it pulls back through the graph.
[03:22:04]  And if it sees stuff that's aired, it's like, okay, I'm going to, I shouldn't be in an aired state. I'm going to just
[03:22:09]  try. And eventually it gets back to the create async, which goes, okay, you're I'm aired. I'm going to try refetch. So even though
[03:22:16] , uh, yeah, essentially, even though like you, as unsurprisingly, there was no re-rendering of any components, no direct linkage. This error boundary
[03:22:29]  down here was able, because it knew that a dependency further down, like inside this component here, aired out, was able to actually refetch the async data automatically
[03:22:38] . That's the demo that I did at the two hour point. It's not re-rendering, but what it's actually doing just to scratch a small change of
[03:22:52]  the listener and does it rescue a small part of the code. Exactly. And then insert and reinsert the DOM nodes as, as needed. These kind of details make
[03:22:59]  backend views. Hey, front end. Yeah. I mean, I saw some crazy post where someone was talking about it, but like, uh, I don't, I
[03:23:11]  think people should actually try the problem before they, they judge it. No, uh, solid does not have, uh, resumability. I think one of the
[03:23:24]  challenges again, is what Theo was saying earlier about how no one cares about performance generally on the dev side and the challenge, because resumability, it's a very,
[03:23:32]  very cool technology. Um, but there's a cost in terms of DX, in terms of like accomplishing and complexity in terms of compilers. So you need
[03:23:43]  signals. And I think there's a lot of potential there, you know, potentially to look into this, but I haven't prioritized. I want to make sure I
[03:23:49]  got the async stuff, right? Because resumability at its core is, is handling of async signals. And to be fair, QUIC had a very specific
[03:23:57]  solve for their async, but I think if we generalize it, we might actually have a basis at some point. Being the only front end team back, it sucks
[03:24:05] . But I, I, yeah, I, back to this, I want, I mean, it'd be interesting to think about how to solve this, you know
[03:24:19] , I, I mean, there's a, there's a simple solution, just re-render all the HTML, but like, that's never going to be the best
[03:24:26]  solution. React takes it, makes it maybe a little easier for you to understand where they're like, look, we'll re-render something and then we'll handle the
[03:24:32]  diff of the HTML. So it's like, not as expensive. This is putting it kind of back in the developer's hands, but it's incredibly powerful, right?
[03:24:40]  I mean, yeah, I mean, yeah. Yeah. It's just a hard problem and we can keep passing the bag back and forth, but like someone's eventually
[03:24:52]  got to deal with it. And I'm very happy to deal with state management on solid side, because I think we've got really cool, powerful solutions. Yeah. Which
[03:24:58]  brings me back to my article, because you'll notice things like, is stale in here and affordances? And like, what if an event happens above the suspense
[03:25:08]  that leads it? So yeah, let's talk about this. So we have a seemingly category of issue when looking at colorless async. That's what I call
[03:25:18]  this. Because if you look at my example that I was showing here, this is colorless async. The fact that this phrase is async or just a normal
[03:25:28]  signal does not end up mattering pretty much the rest of this app. This component here was built without realizing async even existed for the most part. Uh, I
[03:25:38]  guess I have a props about stale here that I'm, that I'm doing. So I guess it was built with a loading indicator, but it could have done that
[03:25:47]  itself by someone just toggling like a true is loading. But generally speaking, like when I switched this to async or not, I didn't need to change the props
[03:25:56] . I didn't need to change the types. I'm not passing a promise around. This is colorless, um, async. So like this, this is
[03:26:22]  an interesting zone, these concepts. Okay. So what did I say? Functions that have dependencies that don't know until they run them, but fall at the edge
[03:26:28]  of our system. Um, okay. These concepts are both similar in the sense that they are non-tracked callbacks that have dependencies, but also very different where they
[03:26:36]  sit. Effects tend to be exiting the system where events tend to be entering. So what I'm talking about is comparing effects to events, right? Events are like DOM events
[03:26:45] , effects are like create effect, right? I, I, I did note that there's an exception. Some effects are used to read the DOM to write back into
[03:26:54]  the system. I should actually copy this in so people can follow along. I mean, it doesn't differ that much. It has to be able to, the reason
[03:27:11]  we don't just use create memo, though, is because, um, they need to be scheduled, um, because we need to prevent, um, diamond problem.
[03:27:21]  If you, if you're memos or computers are, are lazy, but if, if, if async was lazy, you'd have this terrible problem that I drew
[03:27:30]  over here. Um, where, like, if you waited to read to fetch, you could have this throw before this red and you'd cause a waterfall because you're in
[03:27:42]  D and you're like, oh, I'm reading B throws. You don't get to see, it doesn't fetch. And then you get to see, and
[03:27:47]  then you fetch, and this is, it becomes a waterfall. Whereas if you eagerly schedule this, they will both run and then D will get them as it gets it
[03:27:56] . So that's the main difference. Yeah, I mean, if it expects a promise back or an async iterable, so you can use a wait in it
[03:28:07] . That's the only place where that's where the async is. So you, I've decoupled the, the, like the, how you use it,
[03:28:17]  where you fetch. Like, so like the biggest problem is you want to fetch high, but use the block low. That's generally the, the constraint. So to do
[03:28:25]  so in react is a little bit tricky because you've got to pass promises through. Like the react gave everyone use, but they didn't tell you where to fetch the
[03:28:33]  promise. And unfortunately you can't just use memo under a suspense because if you fetch under suspense with use memo, it will actually throw it away in case. So you actually
[03:28:42]  have to invent, add your own caching system to actually make this work. So like you're kind of push to push stuff up, but then you have to change your
[03:28:51] , your API all the way through to down to get back to where you want to block. Cause if you don't and you use right at the top, well, guess
[03:28:57]  what? You're blocking the whole rest of the component tree. There's another example I showed at the beginning of the last stream where I showed how solid could nest components
[03:29:04]  and not block. So like what this does is it moves the question of fetch versus read completely out of the equation and makes components, not a consideration again, which has generally
[03:29:17]  always been my goal. you know, there's the world beyond components, right? So it's like the new pattern of promises and without waiting. Yes. And it
[03:29:38]  doesn't re-render components. So, and it can self feel like this is, this is very, very cool stuff, but there's trade-offs. Because
[03:29:46]  when react, when you eventually do get to use it, you, you actually hold the whole component. So like, even though it's very not granular, react is like
[03:29:56]  you use, use. And then at that point, that whole thing is suspended. There's impacts of us being so fine grained here. Anyways. So where is the
[03:30:04]  thing? Some effects use the read DOM right back into the system, more event-like, and some have effects that funnel to events that would funnel back to the system.
[03:30:09]  However, both of these don't end up changing what I'm talking about. OK, so let's continue. And for this reason, they tend to get built up
[03:30:15]  differently. Effects tend to be defined in a single location, either co-located where the source of data is coming from for things that truly live outside or nearest to where
[03:30:22]  the effect impacts for things like the DOM. If you want more effects, you just write another one and its sources will ensure it happens. What I mean is people either,
[03:30:31]  like if you're fetching data and then, you know, doing something and then like writing to an external system, you're probably going to put that effect near where
[03:30:37]  you're fetching data, probably. But if you're or you're going to put it somewhere, like if you have some data coming in, some props or whatever,
[03:30:46]  and then you're like doing animation, the DOM, you're going to put your effect probably close to where those DOM elements are if you're using it to like do something
[03:30:54]  down there, right? Where events tend to be singularly like a single trigger outside of the system. And those who participate have to jump on. What I mean is
[03:31:03]  natively this involves bubbling for us, that usually means composition where like essentially if a component has a prop and the child has like on something, you might want to call the
[03:31:12]  parent props on something, then do your own thing. You end up just layering these things on. It's a little bit different, right? When you need another effect,
[03:31:20]  anybody can listen to that signal or state change. You can do it like all over the place, but there's only one event. So you can jump on with bubbling
[03:31:30]  up the tree or like this, but you're all jumping on the exact same thread, which makes kind of effects and events different. Even though they both involve what I call
[03:31:40]  non-reactive callbacks, because with effects, I've been talking about splitting the effects between the tracking part and the effectful part. Events are like an effect,
[03:31:49]  a non-tracking callback themselves. They're like, this doesn't rerun. It reruns when you do something. It doesn't rerun reactively.
[03:31:55]  If you read a signal in here, you're not rerunning the event, right? I chose to make them always derived, but yes, you could have the signal
[03:32:21]  reflect that state. Technically, it's just a flag that I'm using in the reactive system. Like I was debating, I mean, it's kind of funny,
[03:32:28]  but internally, if signal had set error on it and then you set it with the loading error, you could have a signal that basically triggered suspense on read without having it drive
[03:32:39] . You could like manually do it. You could also like technically write a normal memo and have it throw the unready error and also basically simulate the same behavior, you know
[03:32:49] ? That's not a setter. What does a wait setter mean? I guess technically the special type of error, I guess, but yeah. So,
[03:33:12]  okay. What I'm trying to say is we're dealing different beats. Unlike effects at the point of consuming an event, we are quite likely to have no idea what it
[03:33:18]  depends on. What I'm getting on is here at props dot on something. We have no clue if there's any reactivity in there. Like, like, like
[03:33:28]  what it reads from where with effects. We always know, like you have the dependency array right next to it. You, you have the tracking things you see in scope,
[03:33:36]  or you see their parent that calls something else in scope. Like, like they call something else, but you have a direct trace where you can go say like, this thing
[03:33:44]  depends on this thing. Events have no clue what you're doing in this event handler. Okay. So different. See, so if last stream, people are very unhappy
[03:34:00]  with my proposed split effect API, which was to suggest that we track one half and then do the effect on the other side. Okay. And I just formalized this in
[03:34:11]  a, in a write up here. This is like watch and view, if you're familiar with view. Um, but it's also people commented. That's like
[03:34:21]  a reactive Hennessy array. This does not have to be an array. It can be a single value. It can be an object. It can be whatever the hell
[03:34:25]  you want, but it is there. It shares similarities with the reactive Hennessy array. But my whole argument here was that even if you, if you, as soon
[03:34:34]  as you have async, even if you know that it will always resolve to like three different strings, ABC, there's no predictable way with a single effect body to know
[03:34:41]  what this will lock because async is async and it can happen a thing. I asked this answer in chat a while back and you know, what does this log
[03:34:49] ? And first people thought there was an answer. And then they realized there was not an answer because this could log. Well, it can log any of these four things.
[03:34:59]  A, B, C. You can look A, A, B, C, A, B, A, B, A, B, C, or A, A
[03:35:02] , B, A, B, B, C. Basically there's four different things. It's like, as I said, and I can, this is just with these
[03:35:08]  three things. I could picture, you know, it feels like a math equation. You're solving for the roots of your quadratic equation here when you look at this.
[03:35:17]  Whereas if you split the effects, like I showed us a moment ago, you are guaranteed to only get A, B, C, and once. So there, there is
[03:35:24]  a benefit from a synchronization external system standpoint to, to, to this API. Right. And more importantly, when you don't know what's happening, like you
[03:35:34]  don't know if these are async or not, then it's important that you enforce this API. As I was trying to show in this example over here, this component
[03:35:43]  doesn't really know if anything's going to be async. So we don't really have a choice, but to guard against this. If we, because if someone
[03:35:52]  writes stuff, expecting a certain type of behavior, and then you throw an async and it acts differently, that, that is not acceptable. So it, you have to
[03:36:00]  be able to make sure that people are writing in a way that's guarded to protect against that reality, because the creator of some child component doesn't know how people are
[03:36:11]  going to pass props in that's the caveat with colorless, right? Yes. Which is exactly what this is reading all of them first and then using it. If you
[03:36:26]  do it in a single function, it's not enforced. How do people know that they have to do that? What if they accidentally don't? I mean, Type
[03:36:52] Script would be pretty angry at you. You can't just set TypeScript on a specific zone and say, do it here, do it somewhere else. TypeScript pretty much
[03:37:01] . It's funny. I was talking to Dev about this and I was like, we could like mechanically, we know ownership context at runtime. I could do this
[03:37:07] , but we could never make TypeScript happy. TypeScript as usual is the bane of our, our, our existence. That being said, this is still a better
[03:37:17]  pattern because even if you made it undefined, like this, we, we can do this and have it like be wait for everything. We can have it say only
[03:37:30]  wait for things that haven't loaded yet. Like there's a latest wrapper. Like we have a lot of control of how we read this. There's is stale
[03:37:37] . We can control that behavior where it's undefined is just some arbitrary symbol that we decided. How would you possibly get a, b, c? Yeah. A
[03:37:47] , b, c would happen if, um, let me think. It's if b finished first and then, no, sorry. It's if a finished first,
[03:38:04]  then c finished. Let me think. Actually, can we get. Yeah. Am I wrong here? You're right. I think, I think you're right.
[03:38:22]  I don't think all the possibilities are possible. Because a would finish. Like they're not all possible on initial run, but they could be possible. After the fact
[03:38:37] . Because of dependencies that already exist from previous runs. Like on initial run, I think there is actually only so many different possibilities. Depending. Can't the compiler inline
[03:38:50]  it? That would require the compiler knowing what these things are. Like, so in a sense, first of all, we don't compile JavaScript like this. React with
[03:39:02]  their compiler don't even try and compile dependencies. Even with the crazy compiler they have. They do not try to compile the dependencies for create effect. Because this doesn't have
[03:39:12]  to be a signal. This could be a function. This could be any, you know what I mean? A, b, c is only if b throws, right?
[03:39:27]  Yeah. Because then, but I guess the question is, if only b throws, c hasn't been made a dependency yet. So you get a, b throws,
[03:39:43]  and then, oh yeah, then c completes, and then b completes. Sorry, I'm just being dumb. Yeah. Exactly, yeah. If it resolves a,
[03:39:54]  c, b, that's what you get. So, moving along. I was also pointing out, like, this. Things you don't know, right?
[03:40:37]  This is a store, right? Which is just, like, a random thing that you could be reading. And you could be doing some process where you're reading random properties
[03:40:44]  you don't even know. This case, though, is interesting. Because, like, runtime reactivity, like, this works. You don't know what this is
[03:40:55]  gonna access. The latter is interesting because it could bail at any point in the middle, and it isn't particularly clear. Render effects must be split in our model of
[03:41:03]  work. But user effects could avoid this if we were okay with it. So, some might consider this catering to the 1% case. But the problem is,
[03:41:11]  as soon as something goes async, sync to async, it travels all the way down the line into code you might not control. If it's something you imported from
[03:41:17]  a third-party library, they need to write the code in a safe way for your code to be safe. Yeah, I mean, generally speaking, a lot of
[03:41:39]  the conditional logic should be happening on the front half side. We also, like, nested reactivity happens on the left-hand side. Like, if you create
[03:41:48]  effects and effects and memos and effects, it happens on the left-hand side. Um, like, that's how the rendering works in the 2.0 renderer
[03:41:55] . It's, it's, it flattens or resolves the whole left-hand side while scheduling. It's, it's, it's kind of funny
[03:42:03]  that it's, you can view it almost a bit like a React component render. Because, like, the effect callbacks that are, like, registered, but you're
[03:42:11] , you're building stuff nested all on the pure side. And then you're, except instead of building a VDOM, we're building a reactivity graph.
[03:42:23]  And instead of rerunning everything, everything is, uh, granularly triggerable by, by signals. Generally speaking, people probably shouldn't be making crazily complicated effects
[03:42:45]  and breaking them into more separate effects. Is your best bet. Anyway, uh, where was I going? Uh, now the trade-off of splitting is that at
[03:43:01]  minimum you need to traverse things if you want to, you want to access twice so that you can track them before you do the thing. This often involves resolving the value before
[03:43:09]  you do the side effect. Whether that is creating an array of dependencies or structured cloning an object. The problem here is that dependencies become more fixed. They aren't
[03:43:15]  necessarily fixed, but it becomes harder to write things that fall on multiple paths because you need to do it twice. And often the effect itself decides that. It is a fundamental
[03:43:23]  problem because we can't control the nature of the execution outside of our responsibility, the effect. But we can't, also can't provide guarantees unless we're given the opportunity
[03:43:31]  to resolve ourselves first. To our benefit, in a multi-path situation, the effect would be doing some sort of dipping, decision based on what has changed. So the
[03:43:39]  fact that a blind traversal oversubscribes is probably lessened. What I'm getting at is if this is like apply settings, the fact that like this has
[03:43:47]  to compare with previous settings or what like, like is probably a saving grace here. But then again, if one was using a store to update an external data source, I
[03:43:56]  hope it wouldn't be directly referencing it since that would be unable to diff the change anyway. And if we were to clone into its internals, a structure clone up
[03:44:04]  front may not be very different. Yeah. So I do see that there is one gap here, which is, which is that like these split effects I've already built throughout
[03:44:14]  solids rendering because like, like spreads, I have to spread over the object on the left side before applying the effects on the right side, like actually updating the DOM elements.
[03:44:25]  So in a sense we go through and resolve all the, all the key value properties into a resolved object before luck, you know, there, there are situ that is
[03:44:36]  kind of the situation here. Yeah. I made an API called resolve, uh, that, that does that you just resolve an expression, like pass it to function and everything
[03:44:48] . It will, it returns a promise you can await and then it will resolve of the, whatever value from that expression, sync, async, whatever it'll,
[03:44:55]  it'll resolve it. So people had a lot of solutions after the stream. So, uh, I w I wanted to talk about a couple of them or some other thoughts
[03:45:07] . One is potential solution closure effects. I'm going to call them another, you know, some people thought, wouldn't it be cool if you could like get the variables
[03:45:15]  up here and then return a function, right? This is, this is one of the most common suggested things. The benefit is you aren't creating the array and locally
[03:45:23]  scoping variables. However, the close over variables, maybe create, uh, being created, aren't saving you anything compared to the array. Um, what I'm saying
[03:45:33]  is you're creating a closure each time. So you like memory wise, you're not actually winning that much. One is passing the thing directly through one is creating a closure
[03:45:42] . It's effectively the same thing. You can pretend like there's an array of these to live in that closure. Um, this doesn't matter for user effects,
[03:45:50]  but it does for render effect performance. There's a few other mechanical considerations. What if people don't return the function? Will they be tempted just to do their effects in
[03:45:58]  the top half? I mean, TypeScript could shout at them and say, you have to return a function, right? How do you pass the previous value if it
[03:46:06]  returns a function? It's interesting because in solid today, our previous value is what we like, what we return from, like, arguably the second function. Um, whereas
[03:46:16]  in the new split API, it's what we return from the front half and the last half is, is run. And it's interesting because it simplified a bunch of
[03:46:25]  logic and rendering and DOM expressions to, to do that split because then we're diffing the pure parts and applying, applying it against the DOM. Again, this is sounds
[03:46:35]  V DOM ish, except it's, there's no virtual DOM. It's just the, it's just the prop objects. You know, we, we met
[03:46:41]  along the way. So like it, it does make it cleaner, um, in terms of separation, but arguably, you know, there's that on one hand, this
[03:46:53]  accounts for the front running multiple times. Yes. Um, when like a sink or suspense, you know, or under transition, but we could, but we could return it
[03:47:03]  from the nested function. However, this leads to how do we manage cleanups in the non-track context on cleanup hooks into the current ownership graph, but split
[03:47:10]  effects technically have two cleanups, one for the left half for the reactive side that runs over and over again, which is basically on cleanup and one for the right side.
[03:47:19]  And these are different life cycles because they can run multiple times. Now, obviously, if this is one effect, then you wouldn't have to worry about that. But given
[03:47:25]  that split, you know, there is this challenge. This leads me to doing the react style return function approach to the back half of split effects. So basically I didn
[03:47:37] 't show it here, but these effects would return the cleanup function, um, conceptually. So basically people probably wouldn't use on cleanup very much anymore. It still exists
[03:47:48]  because it's useful on like the front half. But for a lot of people, it'll just be on mount return cleanup, which is better from a scoping standpoint
[03:47:56] , because a lot of people just do like, either they do stuff top level the component, which means it'll run even when it's suspended or off screen. And
[03:48:01]  the second thing that people often do is put them parallel, like they'll be on mount on cleanup, when really like, which is weird for things like SSR, which
[03:48:08]  don't run effects that don't run on mount, it's be better to actually nest them. So the cleanup is from the effect. So there's benefits to this.
[03:48:21]  So generally my, my gut is okay. How do we manage errors? Try, yeah, this is the fun one too. So cleanups are tricky. Try putting
[03:48:29]  a try catch in a nest effect function makes sense. But if, what if the source errors, are we going to try to write, try catch there as well and re
[03:48:36] throw, not ready errors and for async. And there's catch error helper, but I don't, basically what I was saying is if, if you have this
[03:48:42]  return approach, if you have something async here and it errors, you're going to need to handle it. And if error, you know, handle error, which
[03:48:52]  might be different than doing the effect that you return, like essentially, and then your effect itself might also have a try catch. Whereas with split, essentially the source errors could
[03:49:04]  be handled by an error handler. And this is the API that I was showing on the stream here, where I actually have phrase console log error. I'm not sure that
[03:49:14]  I'm going to do one, two, three like this. Ultimately, in the end, there might be like an object or something, but conceptually, you,
[03:49:22]  you can see that it leaves the user code to worry, to worrying about the errors and the stuff that they have in their own code, if they need to. And the
[03:49:30]  process of worrying about async dependencies and tracking and retrying and all that kind of stuff can get basically buried by the API. It can't be the only thing because
[03:49:48]  the pure side creates things like other reactive primitives, so you might need a way to undo something on the reactive side. But for end users who aren't like worried
[03:49:58]  about that kind of stuff, for the most part, you create a, your user code is limited to here. So yeah, you do your stuff, you return your error
[03:50:05]  function, it's all within your scope, you don't have to worry about that. I think, I think this, one of the biggest things that I've been
[03:50:11]  noticing about these APIs and the approach I've been taking is there's, it feels like there's less primitives in solid, which it sometimes is a lot for people.
[03:50:21]  We got ready to create computed and they're like, what's the difference to this? Most people aren't worried about render effects. So for most people, it's
[03:50:25]  gonna be like, they're not gonna care about projections and some of those crazy stuff. It's, it becomes create signal, create store, create memo, and create as
[03:50:38] ync. You know, like that's, that's basically what you're dealing with for the most part. Yes. And dev reminds me this literally every single day.
[03:50:51]  Um, it's, it's, it's, it's not quite, it's, it's not value, right? It's like, uh, it's like
[03:50:57] , uh, error next and like done or complete. So there is some talk that the second argument could just be the normal effect function, or it could be an option object
[03:51:09]  that basically is, as you said, like next pending error. And people can do, you know, more advanced stuff personally. Yeah, whatever. We'll figure it
[03:51:19]  out. There's a, there is a semantic difference here with what RX stuff does and what we do in that, like we contain a single value, not a stream of
[03:51:35]  value. So what the meaning is of things like error and next is actually different. It doesn't quite align. If it worked perfectly, I would be all for it
[03:51:41] . But like when cleanups happen is different, right? We clean up on every rerun of next. It's, it's a, there's like a different,
[03:51:50]  you know, and returning cleanup functions is not something that the standard RSJS, um, implication has. So these are similar, but different. Anyways, uh, let
[03:51:59] 's continue. Not that one, this one. Oh yeah. And I should mention that the split approach still doesn't solve the deep tracking, like you need to double
[03:52:12]  trace things. So basically what I'm getting at is if we split the current API that I've shown with the split effects is probably the one that we want. If we
[03:52:21]  don't split, I don't know how we just don't split. It seems kind of like, like craziness. I, I, this, this is,
[03:52:29]  there are mechanisms as always with solid that if someone wants to bring back the old effect API, they can just like they can make data binding. There's low level enough
[03:52:40]  APIs that's all gives you enough control that someone could do that. It's just like, I'm, I might even be, be convinced in the legacy packages to make
[03:52:53]  like a create legacy effect. Um, but I, I really don't think it's a good idea. I don't, I think this is the one breaking change
[03:53:02]  that just has to happen. Um, react was right about this particular thing. You know, we were right that you don't need dependency arrays from memos, derived values
[03:53:13] , all that kind of stuff, you know, use callback. But they were right about effect dependencies. And I'm sorry that upsets people, but it's
[03:53:22]  kind of a reality. But this is a perfect example, right? Where I'm changing the mechanisms. Does alien signals account for that? You know what I mean? Like
[03:53:33]  this, this is why I haven't been looking too much on that because the performance difference is almost meaningless for, for what I'm doing. But the implications of the
[03:53:42]  mechanical stuff here is significant. Okay. Let's talk about events now. So I think I, that's what I wanted to talk about effects. Events. Luckily, the
[03:53:52]  fact that events are from the DOM or rendering means that in many cases consistently, we don't need to worry about their dependencies. While it's tempting with colors async to
[03:53:58]  pretend like nothing is async, the reality is we still need to show affordances. Manage enablement of certain behaviors is still very much real. Like you still have
[03:54:05]  to be like, oh, this is loading. This is doing something. This is something even with colorless, you still have to like, from a design standpoint,
[03:54:11]  you're like, okay, when this loads, I need to show loading. Like it's part of your language. Often the thing you need to attach the event to will
[03:54:17]  be near where you're rendering the data that is needed. If you have an async counter, the increment button will likely be close to it. You don't want to
[03:54:25]  show the UI until it's usable. So you can have suspense guarding and that will be it. Once it's available, then the value will be available. So here,
[03:54:32]  you know, does something async. You do this, you do this. And what will happen, you know, this reads from this. It's fine because suspense
[03:54:40]  will count, catch it. And by the time you click on the event, this will be resolved because it's caught by suspense. Oh, oh, yeah, I
[03:54:59]  was thinking about this. Do you think do you think this would cause people? Sorry, this was a funny thought I had. And tell me if this is just craziness
[03:55:10] . Do you think people would want like a log reactive like a or, you know, whatever message you want. You can be like it's basically console log and you
[03:55:25]  just go like the value is a or it doesn't matter. But you see, this is this is just a funny thing in that this is just the front half.
[03:55:37]  And then the console dot log is the back half. But it started occurring to me that if you identified some of the common scenarios of, you know, people would almost never
[03:55:49]  use create effect. But anyways, it's just I don't know if this is what you meant. It's just. Yeah, I'm not familiar with Svel
[03:55:57] te's dollar sign inspect. Dollar sign inspect. Let's just try food. Yeah, it's exactly what I'm saying. Okay. Yeah, that yeah, yeah
[03:56:31] , the fact that it it basically gets tree shaken out of. Svelte probably removes it at a compiler level, which we couldn't do we could. What we could
[03:56:42]  do is make the function never call, but the function call would just be like we couldn't make this disappear completely. Unfortunately, what would happen is like what would happen
[03:56:58]  is we would not use the function. So the tree shaker would essentially change the code to this. And then this would be like function log. This. So the best
[03:57:12]  we could do is leave this in, I think. And this, I don't know if if there's a way with like. Yeah. Yeah, that's what
[03:57:29]  I'm saying. Like the best we could do is compile it down to this. We couldn't get rid of it completely. Yeah, if it might be smart enough
[03:57:43]  to get rid of it on its own, but we could without a compiler trick. This is the best that hopefully it would be smart enough to realize that this is like a
[03:57:51]  nothing function and then it could get rid of it. I'm just trying to show. You're getting to exactly the problem. I was trying to show that it was
[03:58:07]  just doing something with this like function of double because. Because most of the time, this is the case and you're fine. But if you don't render this, then
[03:58:16]  there's no way for this component to know to suspend. This is the crutch of the event problem, which is why I want to talk about it. Yeah,
[03:58:25]  I mean, that's literally what I just showed. I'm just saying that we couldn't. We might not be able to completely remove it from the production bundle.
[03:58:43]  Is all that I was saying. Even outside the bench, you might still not want to let people say click buttons when the async is in flight. I was showing this
[03:58:55]  is stale kind of scenario, right? But simply the affordance required will lead people to build the right patterns is what I'm trying to get at. It's
[03:59:06]  like I'm hoping because like this. This also would trigger suspense. Potentially, or is still handles the error like. I'll talk about this at the end. I
[03:59:21]  actually have a new API here. I've already replaced this stale with something else. I think as I said, we're moving quick, which I'll talk about in
[03:59:28]  a minute. But my point is most of the time when you're thinking about affordances, when you have to add disabled loading states, you're going to write code
[03:59:35]  in such a way that it will guard the event because you don't want the button that accesses. Think about it today. If you have something async and forget about
[03:59:44]  suspense. You just have something async and you have a button on your page and you're clicking it to update something with that. You're going to either wrap it in
[03:59:52]  a show. That's like, hey, don't show this or you're going to do disable. You're going to write some kind of code that guards against like
[03:59:58] , hey, this thing can't be interacted with until the stuff's there. I know it's not nullable, but I from a UI standpoint, you're going to
[04:00:10]  do this. Right. Something the affordance requiring will lead people to build the stuff. Now, there is a point of debate here. It still only checks for as
[04:00:34] ync after initial load. Should it have a mode to check for initial load as well? Or should it still throw to suspense initially? I actually think yes, but I answer
[04:00:41]  my own question later. But the latter would encourage suspense boundaries would wrap these sort of checks, but it wouldn't be very helpful as guards inside of the event itself where
[04:00:49]  no one is catching. Of course, we could just catch these errors since we attach the event handler and wrap them, but there would be no visible affordance. So what
[04:00:56]  buttons would effectively be disabled until the data was ready? To be fair, it is worse than that. If it's the effect hearing problem over again, someone might do part
[04:01:05]  of an event before bailing. Console log always, maybe possibly async. So you can't just handle it neatly. You know, this is like, okay.
[04:01:14]  Right. And I'm going to show why I don't think this matters, which I'm getting at, in a moment, and how to solve this. Because,
[04:01:33]  as I said, the majority case is going to be handled mostly by the fact that you're either going to use that data near it, or you're going to need to
[04:01:44]  show some kind of affordance. Maybe it's above in the parent or something like you if something's loading or something needs to be disabled conceptually. Like, yes
[04:01:53] , the lowest button might not know about it. And that's the thing that actually does the click handler, which was like my problem before at the very beginning, where I
[04:02:01]  showed that example, where I was like, I was like, you know, this guy has no freaking clue what it's getting into. But the location at which you
[04:02:11]  write that event handler, you might know what it's doing. So, yeah, let me continue to get where I'm going to get it. So, essentially,
[04:02:21]  solution one, we talked about suspend on. In the same way, split effects technically solve the problem, but could be less ergonomic. Some cases are some mechanical force
[04:02:29]  solutions, which isn't, if above, isn't sufficient. The first process, essentially, is suspend on hook. Think of it like use action. The idea is it
[04:02:35]  registers an async depth and tricks suspense about it. This is a very React-like solution. The idea is, like, now you're just reading the async.
[04:02:45]  Like, obviously, I put in the same component, but it doesn't have to be. You could somewhere, you know, be like, this is where we hold the
[04:02:51]  line. You only need this if it isn't rendered. But presumably, you're in a case where you're like, this is where the event handler is. And
[04:02:59]  you're like, and you're like, as I said, the problem with this approach is people aren't going to know to do this here. They're going to know
[04:03:09]  to do this somewhere above, right? Like, so, unless you, like, it's not even enough to know if the callback is defined. Like, this
[04:03:22] , as I said, this has no idea to know what to spend on. Though it's at least these to spend on to attempt to go higher in the tree than desired
[04:03:29] . It might be fine since you said the handler owns a state which converged to change. But there is a drawback, right? Like, as I said, I
[04:03:38]  feel like we're already, keep in mind, I feel like these solutions are already an edge case. Um, because either you're going to read the data or someone
[04:03:50]  needs to show an affordance. And because of those two criteria, it's going to be very rare a situation where this isn't handled already simply from the fact that you
[04:04:02]  need, like, conceptually with async, you need to guard anyways. And you could say, like, whoa, I don't know if I'm async
[04:04:08] , but someone above you knows it's async, which means they will need to be responsible for an affordance. So, like, okay, let's try another solution
[04:04:18] . So this one is, like, the half-assed solution is, like, default back to React. And, like, this is, like, secretly just the
[04:04:25]  front half of a render effect. And now it suspends, because you told it to. I mean, what would that do? Signals aren't promises. Yeah
[04:04:44] , I mean, it is an edge case. Let's continue. The problem is, okay, so let's continue. Now, this is funny. Another React influence,
[04:04:58]  even though this one isn't, create callback. Kind of like use callback. Yeah, I'm not too happy about that one either. But in theory, you
[04:05:03]  could force the dependency where the callback is defined, and then essentially track it on read. This would require all event bindings to be reactive, but it would work.
[04:05:08]  So you can say create callback, you know, what it depends on, right? And then it creates an accessor for, like, the event handler. Then
[04:05:19]  if someone composed it, they could do the same thing down the line, because they could create their own callback and then depend on, again, the parent's callback
[04:05:27]  that they're calling, and then any new dependencies they add. So you could compose it, essentially, by adding dependencies. And then the final thing would depend on all of
[04:05:36]  those. Of course, while this removes the tearing bailing problem, it doesn't speak to affordances. This would be just delay attaching the event handler. You still
[04:05:45]  need to use other means. Yeah, the problem with this is even if we were so smart and reactive all the way down the line, I mean, I guess the trick
[04:05:52]  here is it would trigger suspense. But it also, like, what I'm getting at is you still need other affordances. Okay. I think the hardest part of
[04:06:04]  looking at solutions here is that as much as things change, they stay the same. Just because async is colorist doesn't mean you don't need to make affordances
[04:06:10]  for it. The weirdness can be summarized with this. Button disabled, not async value, click. This will suspend as you expect, right? Because it
[04:06:20] 'll read this async value and go like, okay, I'm disabled. Initially, it'll throw to suspense and won't show it. And then once it's shown
[04:06:28] , it will work properly. And then when it goes to load again, it'll be. Actually, this doesn't even. Yeah, I mean. This doesn't
[04:06:39]  even deal with the update. It still does. But my point is, like, you could conceptually see that this now puts a dependency that would cause it to throw.
[04:06:48]  And then once it's loaded, it will be fine. But if async value can never be null, then why would you ever write this code? Do you see where
[04:06:58]  I'm getting at? It's like, not async value is a very weird thing to write when it can't be non-nulled. I mean,
[04:07:18]  that defeats the point. I mean, they're non-colorless today. We've already shown why, like, how far that can go, right? Like,
[04:07:27]  solid 1.0 is not colorless. That's, this is basically the whole point. So, like. You know. But if async value can never be
[04:07:41]  null, then why would you ever write this code? Yet, write it offensively at the edge of the system exactly what you want to be doing, because you will do
[04:07:51]  it for the affordances. Inside the reactivity, non-nullability and colorless async is a gift. It is transportable. It reduces concerns with narrow
[04:07:57] ing. It even leads to less unnecessary waterfalls. Because you're not, like, wrapping things with show to, like, prevent it and then accidentally causing waterfalls
[04:08:05] . I can't blame TypeScript for this one. Even if we could achieve some perfect approach based on where things are read, the feasibility to type. Someone suggested this
[04:08:11]  earlier. Like, say, reactivity is nullable outside of tracking context. There was a time I would have said that's the beauty of JavaScript and it can model
[04:08:20]  anything. But JavaScript isn't what it used to be. And neither am I. I know. Very negative thing. I'm blaming TypeScript again. But, I
[04:08:32]  did have a little bit of a breakthrough. And I'm going to show that really quickly on stream here. Which is, let me, I'm going to pull this straight
[04:08:46]  out of a Discord chat. So give me two seconds. You know what? Let's see, maybe I can blow this up a little bit. Can I change the
[04:09:06]  width here? Barely. Honestly, this doesn't solve stuff much. But I had an idea of a proposal kind of related to these guard helpers. Because I think
[04:09:20]  the thing is, my conclusion from that is, after looking at suspend on and looking at, like, the crate callback. It was, like, these solutions don
[04:09:31] 't change the fact you need affordances. Which means we should focus on the behavior of the guards and the affordances. Rather than focus on, like, trying to solve
[04:09:46]  these edge cases. Which, hopefully, by writing good code should work anyways. So, my idea was, for a while I was talking about this idea that if there
[04:09:59] 's a default value for crate async. Then it could always read latest, you know, in those scenarios. And then you wouldn't, you could avoid suspense,
[04:10:08]  you know, from a guard standpoint. But the problem with that is, we need for consistency the throw inside the graph. The only place that we use, like, the
[04:10:17]  ability to read the latest is, like, at the edge on the render effects. That's how we get the tearing here. That's why suspense doesn't whip us
[04:10:26]  out again when we do this. Is because, initially, suspends when something throws. But in the after the fact, the final render effect basically always gets the latest value
[04:10:37]  where it can. And that's, that tearing is why we can do this. It's only new async that causes, you know, the suspense boundary. But
[04:10:47] , but, like, that means that default values can't, like, get us out of, out of it. Like, you, you, it's not enough just
[04:10:56]  to have a default value. That would have to be the last thing you read in the DOM to get it. And if you put a default value in async and then
[04:11:02]  put a create memo in the middle. And it doesn't have a default value. Well, it's going to suspend. So, what I decided, what I,
[04:11:09]  what I thought about doing was what if these kind of helpers had the ability to set their own fallback, essentially. So, I don't know if everyone can see
[04:11:27]  this code. Maybe I'll grab this and put this in a place where it's much larger and easier to read. Like, here. Let's do this. The idea
[04:11:40]  is, pretend you have create async with a fetch user. So, you're going to have an accessor type user, right? And then there's some dummy user
[04:11:54]  object. This is from my example. What I'm suggesting is, when we use latest on user, initially, it's going to throw to suspense. So, somewhere
[04:12:05]  in your UI, if you use latest, if there's no value, like it hasn't resolved before, it's going to throw to suspense. Otherwise, it uses the
[04:12:13]  latest. And this is the standard behavior that we use when we do render effects or wrap things where we're like... And it's also the standard behavior that we get
[04:12:25]  when you read a signal outside of effects. The reason is, if you notice, latest user returns user the same way that accessor user returns user. So, from
[04:12:37]  a TypeScript perspective, latest is consistent because when it's undefined, it throws. So, we can change the behavior of accessor to work latest when we
[04:12:45] 're not under a reactive context because the types are the same. And it's safe to do so from that perspective. So, we don't have to worry about it,
[04:12:55]  like when you're in an event handler, about it being after initial load. Like if it triggered suspense, that's the end of your concern there. But the idea
[04:13:08]  here is, if you did latest user default undefined, then you could resolve it to user or undefined. And this will not throw, by adding a second
[04:13:18]  argument for a default value on the latest helper. Instead of putting it on like the memo or the async, you put it on the latest, then you can get user
[04:13:25]  or undefined. And similarly, some people don't like suspense generally. They want to show like the real UI showing dummy data in some places. Well, you
[04:13:37]  could also do latest user dummy data. And then this will not suspend, essentially, because dummy user will, instead of throwing, it will return dummy user. This will catch
[04:13:48]  the throw. So, in a sense, this is like a fallback almost. But what it lets us do is, by default, have the behavior you want to
[04:14:02]  encourage. Where people asking for the latest value will trigger suspense and it will work. And generally, you know, as I said, events and stuff will, you know,
[04:14:11]  fall in as they do. But then, you know, as I said, most people aren't even going to need to use this. This is like, this is
[04:14:20]  just a, this is a pretty advanced API. Most people will just be tracking stuff in the general sense. But this helper is very important because it is the baseline.
[04:14:30]  It's used internally in other helpers and it's used inside create render effect. It's just the core thing. If you ever want to tear, this is the
[04:14:38]  way to do it. And if people really want to get undefined back, this is how you do it. The thing is, there's going to be somebody
[04:14:51]  who wants this for some crazy reason. Like maybe they want the section of the app to act in a way as if suspense doesn't exist or what, like. But
[04:15:01]  yes, I, I, I wonder if there is, but at least this, this, this gives people the ability to opt out of throwing by, by doing a guarded
[04:15:16]  read at some point in the tree. Because we don't care until we, it becomes a sink. So as long as there's this slides itself between the initial source signal
[04:15:26]  and the effect, it will not throw. It just like, it'll throw part of the way, but it won't throw all the way, which means the effect
[04:15:32]  won't throw, which won't trigger the suspense, went through the air boundary. And so like this, yeah. So this is, this is like the latest API.
[04:15:43]  And I was, I was like, I realized I could also use this more importantly for the stale API. Of course, what I want to do is I want to
[04:15:55]  make it is pending. So the idea here is if is pending user again, it throws initially to suspense, but otherwise it just, it returns true when it's pending
[04:16:08]  and when it's not. So this is useful for affordances. So in our example that I was doing here, what I'm saying is the default here would be
[04:16:24]  is pending upper phrase for here would actually throw to this suspense boundary, not this lower one. I think from a logic standpoint where people put this, you know, we
[04:16:33]  should throw, as I said, it's this a button, it's this effect that, you know, event that cares. We shouldn't be just by default,
[04:16:41]  like masking it because what if this requires something async or whatever, I've using opacity to say, well, whatever, it doesn't really matter. But what I'm
[04:16:50]  getting at is by default, I'm suggesting that it throws. And then after the fact it does this, you know, we're great. Sorry, this one's
[04:16:58]  a suspense boundary, but we're gray's out essentially as it does the update. And then similarly, there's a default value. So basically, if you say false
[04:17:16] , it doesn't throw. It returns false instead of throwing and then true update. So this is basically the same behavior as is stale is in that demo. So if
[04:17:26]  I wanted to convert that demo to have the exact same behavior today as what what I originally wrote, I would just change this to is pending upper phrase false. And this
[04:17:42]  is a way of telling it that, hey, initially we, because you don't want two affordances, we don't want it to turn gray while it's loading or
[04:17:50]  something, right? We only want to do it on update. So essentially that, where am I here? That could accomplish that. And then similarly, we can say it
[04:18:01] 's a true. So this always says a Boolean does not throw is true when the user is pending. So this is one like we always want to see. Again
[04:18:10] , I wouldn't use this one in the reactive scope, but this might be useful as a guard where you're just like, look, whether this is initially, whether this
[04:18:17]  is later, if this is in that state of like pending, I don't, you know, I want to guard against it. Oh, sorry. Yeah, Tanner
[04:18:27] , Tanner already left. I, um, but we were, we were covering tan stack, tan stack solid router has now been released. So, um, there is a
[04:18:40]  solid TypeScript tan stack router. So we are the first one other than react to also have it. But thank you for the rate anyways, even if it didn't
[04:18:59]  quite work out the way you're hoping. Yeah, so it's all good. Anyway. Um, when I, so this is, this makes a good guard
[04:19:25] , you know, you're like, you're saying, hey, you know, it's not maybe reactive scoping. You're like, if this is pending at all
[04:19:32]  loading or whatever, I do this versus do that. So basically these two APIs, their default throws for suspense cases. And then if you know what you're doing in advanced
[04:19:43]  cases, you have the ability to get the behavior you're looking for. Um, that's sort of where I've landed in the latest. It lets us not have
[04:19:52]  like, is stale is pending is loading. Well, someone might be like, well, how do you tell if it's loading initially? And this is the one that
[04:19:59]  I haven't made a helper for because I have to admit, um, I kind of want you to use suspense for that. Like if you only care about the initial loading
[04:20:10] , the be fair, you could, there's a couple of ways you could do it. Um, I think the easiest way to do is loading would be, uh
[04:20:18] , let me think it would be function is loading. So this is only initially like, like the, the suspense scenario. I think the way you would do this would be
[04:20:29]  return latest function, some symbol. Let's say, let's call it a loading symbol. Equals loading symbol. Um, so like the answer could be answered,
[04:20:48]  right? This loading symbol could be anything like loading any, because essentially if, if it with latest, it's only going to get this value if it's never resolved before
[04:21:05] , which means that if it equals that value, then it's that initial state. I don't know if we need a helper for this. I'm hoping people will just
[04:21:12]  use suspense and this is not the scenario. I think, I think most places where you're actually guarding, um, you want just this behavior because let's pretend if you
[04:21:22] 've got a button that the event does something async and you go change that async thing, you should disable the button. You shouldn't be reading. Like you
[04:21:30]  probably don't want to be reading from the old async value. Um, so to speak. And I, I mean, I guess if you do, yeah, I
[04:21:45]  don't know. I, it, it, it feels like the, the safest thing is like when something, you know, major asynx and flight that you put
[04:21:53]  the guards and the affordances in place. But as I, as I said, the whole, the more and more I, I explore this and I won't know
[04:21:59]  until we try with real apps or real scenarios, it feels that because you're going to add affordances, you're going to make loading states to show, you know,
[04:22:10]  stuff updates. it's, it's then you're going to likely already have the, the, the guards in place for these scenarios. Um, anyway. I
[04:22:44] 'm trying to think of what that means. Cause the mechanically, what, what I, what I've been like, um, looking at here is that there's two
[04:23:03]  different mechanisms when talking about the async. There's on read mechanisms and on read mechanisms. Uh, me, the data has to get passed into it, which means
[04:23:16] . Whether it's sibling or whether it's whatever, like, it doesn't matter. It's going to come in to you as a prop or it's, it's
[04:23:24]  going to come into you to context or something. It needs to be passed into you, which means that generally you're either going to use it directly and trigger parent suspense
[04:23:32]  or trigger your own suspense or whatever, like somewhere you're going to read it, or you're going to ask a question about that data, you know, get the latest
[04:23:42]  because pending, you know, whatever you you're going, you're going to, you're basically going to have the data and you're going to try and render something and
[04:23:50]  it's on read. So suspense, um, error boundaries, these kinds of things are all on read mechanisms. And then there's a second mechanism, which we haven
[04:24:00] 't showed on stream, uh, in solid 2.0 because it implemented solid 2.0, which transitions and transitions are like a right mechanism where they're like, it
[04:24:08] 's from the set of that change applied globally until everything resolves from a read standpoint. So from that perspective, when you ask if a transition is pending, you aren't
[04:24:21]  asking about the data, you're asking about the process. And that's something that a sibling might need to know about. Cause it's like, Oh, am I
[04:24:29] , is this change happening? Right. It doesn't have the data. It doesn't need to render the data. Um, it doesn't, it has no way,
[04:24:38]  like it, it has, it can't, it doesn't know about the data. It can only have to be told about some process that, that is happening. So
[04:24:47]  like technically you could get something similar with a sibling. Like if you, if it goes like, tell me if I'm loading and you put like is pending user as
[04:24:56]  a prop to like the loading prop to that sibling, but like, um, then it doesn't need the user. It doesn't care. But like conceptually the read
[04:25:08]  one will always have the data, which means you can always ask the question about the data or what you're going to show or what you're going to read. Right
[04:25:15] . Cause it's based on read. And then the process one is going to be based on some kind of, uh, event, something, you know, like it's
[04:25:23]  like these kinds of things, aren't enough to handle routing and rendering off screen because you're rendering something that you haven't even seen yet. And that's, what's
[04:25:31]  pending. You, you don't have the data, right? Like if you're on one page and you click to the next tab and it renders a different path tab
[04:25:37]  and you're, and you are trying to show on the current page that you're doing something that doesn't fit into this type of pattern because there's no, there
[04:25:46] 's no way to get the data that's down in the, in the second page back to the first page to tell it, Hey, you know, you can't,
[04:25:52]  you need to render this loading state. That's a transition. That's a scenario where at the top level, you know, at the router, wherever the switches, you
[04:25:59] 're like, Hey, I'm going to start this process and it's going to involve this change. And until this finishes, you know, listen to me is routing
[04:26:06]  is changing, you know, whatever. And I'll, I'll let you know. Whereas like this, these APIs only basically care is like, can I successfully render what
[04:26:17]  you've given to me? Um, and if I can't, I'll throw. And if I can, um, I'll try my best. And if I'm
[04:26:24] , you know, out of date or pending or ting, you can ask that too. And I'll tell you, but it might not even matter because you're not
[04:26:39]  actually even asking about the data. Like, like, yeah, it's kind of interesting. Like pending, you're right. Doesn't catch this in transition because the
[04:27:07]  transition applies itself holistically. Once it gets from start to end and that's off, like that's off the screen, so to speak. So like, I guess
[04:27:16]  the question could still get asked and ignored during that state. Um, but generally like transitions are usually for major changes, like routing where you're like replacing section of the page
[04:27:27] . What's cool about this API is I think that the need for transitions really becomes just for people writing routers or like libraries for the most part, like maybe someone's
[04:27:37]  building like a, a mechanism, like the place you might use transitions is if you have like a toolbar that changes based on the page you're in. And it's
[04:27:47]  some global thing. And then as you render different pages, the toolbar needs to be like, Hey, I'm changing my state. And like, I need to know this
[04:27:55] . There might be like, it might need to go like, Hey, I need to know about this navigation or about this change in the toolbar. Um, and what
[04:28:03] 's cool about it is you don't need the wiring, like classically, the way you would solve this would be, you'd have like a signal and then you do
[04:28:09]  something, you set a signal and then you, um, set the signal again, when you were done based on like some effect or something writing to that signal. And the
[04:28:17]  cool thing with transitions is that like, you can basically wrap the process. Say like, in fact, one of the APIs I'm considering for solid for transitions is,
[04:28:26]  is, is, is not even start or use transition, but run transition, which is essentially just so you can kind of see this idea of run transition. It's you
[04:28:37] , you might do something here like that page to, you know, page two, right. And everything downstream of this change happens, you know, due to this in its
[04:28:49]  own separate branch, separate reality, so to speak. And then you put a weight here. So this is, it's async. So essentially this is before,
[04:29:03]  and this is after, right? After, uh, after transition. And it's actually not even after we can make this, I was thinking we can make this actually
[04:29:15]  before effects, but after the pure, like when it's like, I am resolved, I'm going to run my effects. Um, I haven't quite figured out.
[04:29:25]  Um, but that's the, that that's like, that that's my thinking at least, um, like after pure before effect part. And it might like right
[04:29:38]  now, react has like an, is pending signal, but you could also just be like set signal, you know, set pending true that pending false. Like, I don
[04:29:53] 't know what you're like doing here. You might have multiple signals. You might not use a signal, you might use a store, you might do whatever, instead
[04:30:02]  of having the transition itself, provide the signal, um, state you, your process that, that does it can just be like async, you know, function, my
[04:30:16]  process, you know, this could be an event, it could be whatever. And essentially, you know, there you go. I mean, I don't even know
[04:30:32]  what, is it, is a transition the right term? Is it a transaction? I don't know, but I'm, I'm, I'm thinking something along these
[04:30:40]  lines where you, you just, the, what we're doing is we're creating a promise based API. Well, the thing is, yes, we could just make
[04:30:56]  this into, I can make a primitive that adds the create signal call for you. But what I'm getting at is this is so much more powerful because it could be literally
[04:31:08]  whatever the hell you want. Like making it, the other API is simple, but this is better. Like you say this on ergonomic, cause you're like, I
[04:31:15]  have to write create signal myself. But on the other hand, um, what if you have a store that you're using for global state, you, what would you
[04:31:27]  have to do? You'd have to, what would you write an effect that listens to is pending and then writes to the store? Would you create, uh, a derived
[04:31:35]  projection into your store of that state? The, the, the thing is, this is the best time for you to write like in an event, right to your state
[04:31:46]  directly rather than like create some quick, crazy synchronization chain. Right. Like, like the, the biggest problem is if, if you force state on someone in an
[04:32:16]  ephemeral process, and I mean, I should probably take my own thing on this because, uh, uh, uh, what's another example of this, uh
[04:32:23] , optimistic updates, you're forcing people to have to use some kind of diffing or synchronization. It's convenient from a declarative standpoint, but you are making assumptions
[04:32:40]  for them and you have to be ready to make those assumptions because you're, you're actually going to complicate their downstream code if like a signal isn't the right
[04:32:47]  affordance. Do you know what I mean? Like if, if, if, if you're suddenly pressed with actually having to like derive or synchronize data where this is
[04:33:02] , this is so much simpler. As I said, we could offer the other API too. I'm just saying like what it comes down to is actually this, but
[04:33:11] , and the reason I'm showing this is this question has nothing to do with the fact that set page loads user. You're not asking about is pending user here or whatever
[04:33:23]  this comes down to. I care that when I perform this action has it completed. So like at a very high level perspective, there is the, have, have I
[04:33:40]  done said thing? And then the, the opposite side of this is a weight resolve user, which, uh, is another helper I built, which it doesn't care
[04:33:54]  what this is. I could have just put resolve user if it's one thing, but it could be an expression or whatever, which is just like guarantee that this is resolved
[04:34:04] . So this is a read question and this is a process question, right? Anyway, I thought that was interesting. Maybe not. Maybe this is more of a me
[04:34:29]  thing, but yeah, I, I think we have the potential here to, to have good defaults, not explosion on helpers. Like I keep track. This
[04:34:46]  is, this is how I keep track to this inventory of reactive primitives. I, I update this like every time I make a decision change and I sit there and I
[04:34:53]  look at this and I go, is this everything that I need? And I try to make think about like, is this too much? And the, what's what
[04:35:00]  I'm getting excited about is the front half of this list is never been this small. We've never been at seven before, which makes me very excited, right? Because
[04:35:13] , um, for the, while there's some amount of overloads, these, um, these, uh, primitives don't, it's not like Svel
[04:35:26] te's ruins, like derive dot by drive dot this, you know, effect dot this, these are the, they, they, we don't have that. And there
[04:35:35]  isn't really much in the way of options. So there, these are single purpose primitives and that's it. They're not hidden underneath. This is, this is
[04:35:45] , this is the list. And even in this list, you probably not looking at this one. A lot of you will not look at this one, right? And
[04:35:55]  yeah, don't get me wrong. There are things like context. There are things hidden underneath components that you probably won't use directly. There's advanced APIs around owners and
[04:36:07]  observers. There's advanced around reactive cleanup. Again, you're probably not going to need this. Create root, which you won't probably see, cause it's going
[04:36:17]  to be under a render function. Untrack. That's real. Flatten or children. It's children's just based on this. That one's fine. Fl
[04:36:27] ush sync. It's the new batch. People use it. Resolve. I just showed you, but people are probably not going to need a promise for the most part
[04:36:35] . This is pretty rare. Latest is pending. We just talked about catch error. I showed in that one example. Again, I have it. Probably not that
[04:36:43]  important. Has updated. Again, very advanced. Create suspense under component. Run transaction. Just showed you. Reconcile. This is for diffing of stores. Un
[04:36:52] wrap. Unwrap your store. Omit and merge are store helpers for removing properties or merging properties. This is classic split and merge props, but it
[04:37:06] 's for stores and props. And then two more control flows. This from core reactive stance, I think is the full list. And most people will not even use half of
[04:37:18]  this list. And many people, when they are taught solid, will only need to know about five of them. So I think we're getting there. Yeah. Create
[04:37:31]  boundary. I haven't decided whether to expose it or not. It might be that there's like a create off screen or something that's a little bit more specific. Fl
[04:37:39] atten is the basis of children, but it's also the basis of DOM expression rendering. It's the thing that allows us with fragments to flatten out all the arrays and
[04:37:51]  also parallelize async. Because if you didn't use this, the first element in the array that threw would block and you'd have the React 19 problem with fragments.
[04:38:02]  Like sure, we nest effects often, which is fine, but fragments aren't effects and they have to channel through. So we actually have to be able to process each element
[04:38:12]  of an array separately from a async standpoint. Otherwise we'd have blocking rendering. So yeah. Oh yeah. Someone talked about, yeah. Produce on stores.
[04:38:25]  Well, yeah. I didn't add path here. I don't think I'm going to put that core. Someone else can, or we can put it in legacy maybe
[04:38:33] . Produce is the default for stores in. Oh, you might have missed Flatten. So Flatten's right here after OnTrack. But, uh,
[04:38:53]  yeah, yeah. It's funny. Cause yeah, there was some feedback. Uh, let me, sorry. SolidJS, not this one. Let's go to
[04:39:01]  this. No, no. Uh, discussions. Talking about solid 2.0. Um, and there was some actually decent feedback here. People wanting property structuring.
[04:39:20]  Um, I wrote a whole long thing about, um, why that's not happening. And then why again, people are like, well, let's use functions of props
[04:39:35] . And then I explain why that doesn't work. And then. Um, yeah, there's a suggestion about using stuff. Yeah. I, I think, I
[04:39:49]  think honestly, we just need to talk a bit more and get the RCs going at this point. Stuff is changing so rapidly. Like this is pending a stale stuff
[04:39:57]  that it's a little bit early, but the long story short, um, stuff there's a lot, I guess, did I not talk about stores at the top here
[04:40:06] ? There's a lot of, um, Um, do, do, do, do, do, do, do, do, do. Yeah. Immutable,
[04:40:11]  diffable stores. That's part of it, but I didn't talk about the AP. I actually, there's a lot of things that we've got a lot of
[04:40:16]  feedback over the year. And I think stores is one place where, um, we can definitely make improvements. Um, yeah, I, I, I, one of
[04:40:29]  the challenges I'm having realms is also like dom rendering because the API's aren't the same. The, the, the, the, the, I don't know if
[04:40:47]  people know this, but array is array exists. The reason you don't do instance of a, of an array is because, um, literally in different windows, it
[04:40:57] 's a different object. Like, like it's a different prototype. They don't view, like if you're in an iframe or not an iframe,
[04:41:03]  they don't view the like array type as the same every, all the types are different. So array is array is kind of like a way of saying like, this
[04:41:12]  is like a native JavaScript array. And that will, no matter what window you have it or what scope, it'll recognize that it's an array, but it's very
[04:41:21]  interesting because for things like proxies where like you can't fake it, you can't say I'm an instance of an array because it still won't match. Right
[04:41:30] . And array is array will be false. Right. And array is array will be false. So there's a lot of these weird exceptions that are kind of crazy,
[04:41:36]  which are really unfortunate. Um, they, you can, you can always push stuff from the target of the proxy, but you can't fake it. Like a proxy
[04:41:46]  is only an array. If it's targets an array, you can't put an object in it and then like fake it as an array. And I think, uh,
[04:41:54]  there's a lot of things like that in the, in, in the, in the, in the, in the kind of zone of, uh, multi window stuff.
[04:42:06]  Um, document isn't document. So like when people turn render stuff in portals that are in iframes, like there, there, there's, there's
[04:42:17]  a lot of trickiness. You almost have to use context to, to do it. Um, web components, make sure that this topic comes up all the freaking time.
[04:42:28]  Um, yeah, I don't know. Multi document is, is really annoying. Anyway, uh, let's see, do I have any more this week in JavaScript
[04:42:53] ? Give me a second. Let me prep, but I don't know. I, me and Tanner talked a lot about a lot of the stuff that I wanted to talk
[04:43:01]  about. So give me, give me a second. Let's see if I can prepare for that. Um, it's funny. Uh, yeah, technically Tanner is
[04:43:14]  still boosting the stream, which is so awesome. So big thanks to him. Um, okay. Let's see if I can, let's see if I can,
[04:43:39]  the truth of the matter is like, I only did the stream last week and, uh, I feel like most of the stuff me and Tanner talked about, oh, there
[04:43:50] 's a couple of things. February 14th. So there's that. Sorry, just give me two seconds. Just got so much stuff going here. All right.
[04:44:36]  This will be a short this week in JavaScript is basically what I'm, what I'm going to say here. Yeah. All right. All right. All right
[04:45:09] . All right. Let's talk about this week in JavaScript. Now. Um, a lot of the stuff we already covered earlier in the stream with Tanner. Um, I
[04:45:29]  think. It's there's not much. It's there's not much to add to it. Uh, I'm looking here at my bookmarks and almost all my
[04:45:39]  bookmarks were on this beat narrative. You know, I, I did the tweet a few weeks back where I was like, don't bet against feet. Um, there
[04:45:48] 's a lot of mixed messaging here. I think there's a lot of confusion. Um, I think some people, it's all about RSCs. Some people,
[04:45:58]  it's not about RSCs. I think there's different people even within react who have different opinions. I do wonder if there is a very big difference of opinion
[04:46:09] . Like they try to align and they probably meet up and they talk. But like, I feel like maybe Seb is on a different place than Joe is, uh,
[04:46:17]  Joe's working at Meta. Seb's working at Vercel, Joe big work on the compiler. The compiler is completely a client side feature. It's been the
[04:46:24]  very important part for react at Meta to improve performance. Server components are basically not even used in Meta or they're using a few places. They're not like
[04:46:34]  a primary thing, um, but very important to Vercel and next JS. Um, and you know, the, while the react core team follows Seb's vision in
[04:46:46]  terms of server components, being that unified future, that single story that they can tell, um, it creates tension like these, the create react app, um, stuff
[04:46:55]  that went down, you know, where a lot of people really just don't get it. Um, you know, they look at what Tanner's doing. They look at
[04:47:03] , you know, 10 stack, they look at, at these things. And they're just like, why can't we just use V or use parcel or whatever?
[04:47:11]  And why, why make this need a framework thing? And the truth of the matter is it's to get everything out of react, get everything, especially out of server components
[04:47:18] . You like SSR is hard enough as it is server components. There's pieces that need to be in place. And I don't know if the tooling's caught up
[04:47:26] , right? I think there's a quite a potential that would beat, you know, that could very much be the case. But today the tooling hasn't caught up the
[04:47:35]  easiest way to do server components or, you know, modern, modern react stuff is to pick up a framework. It's not the classic, you know, react slogan
[04:47:45] , you know, I'm just a UI library kind of thing, but react is not the same react it was 10 years ago. So I don't know if there's
[04:47:53]  much more to say people probably beat this topic to death. It's funny. I talked about it originally, but I don't think people understood what I was talking about when
[04:48:01]  I talked about last week, since then, literally every, I've seen so many YouTube videos go on and people covering it and all that stuff. Um, yeah,
[04:48:10]  I, it's funny. I saw something Ryan Florence saying is like, uh, about like how the react, like people, he didn't realize that people were mad at
[04:48:19]  react or like upset about it, but like there was an outcry. It just, I think it's goes beyond. And I, uh, this whole beat thing,
[04:48:26]  I think there's a certain scenario where the existing ecosystem is shifting to these changes. And we talked about that at length at the end of my last stream. So I
[04:48:34]  don't need to get into it again, which means that, um, there isn't really much on the bookmark side of things. Um, that was kind of what
[04:48:41]  was interesting this week. And we, and we had Tanner to join us to talk about it. Um, I, I think there's people are starting to feel like
[04:48:50]  they can write a final follow-up on this stuff. If you're not familiar, uh, with, uh, I don't know if that's first thing, Bobby
[04:48:59]  Kang's work, um, write some really great blog posts. Uh, a year ago wrote a react for solid versus HTMX and Theo's video on the topic
[04:49:07]  is one of my favorite Theo videos. Cause you know, the, this article we've covered on stream before, it was a really interesting thing where he talked about how each
[04:49:17]  of these three frameworks had a very distinct, um, view. And honestly, this is the way I very similar to the way I think about things. When I look at
[04:49:28]  these problems, a lot of people are like, um, obviously I'm in solid. So I'm like a little biased here, but when I look at like,
[04:49:35]  I do see react as a trailblazer on a certain path. I see solid as a trailblazer on a certain path. And I see HTMX as a
[04:49:40]  trailblazer on a certain path. And then I see a lot of other frameworks, um, doing similar things to those and maybe prioritizing different parts of different things.
[04:49:51]  But conceptually these three bets, we all made years and years ago. And we followed it in the most purest way where others have kind of just adopted the pieces
[04:50:04]  they liked. So I really liked this kind of framing. Um, and the original article was amazing. Um, the follow-up article is also interesting. He has
[04:50:13]  kind of different perspective here. Oh, and thank you, uh, Dev for the Ryan Florence tweet. I think that is the one that, uh, that I'm looking
[04:50:22]  for here. It's not really the react community. That's mad on my timeline anyways. Okay. He's talking about it because people outside of react or whatever talking
[04:50:35]  about it, but it's just gotten so crazy. I mean, it's more that the, the react, um, library maintainers have already expressed their grievances in
[04:50:49]  smaller ways. And then the react team was like, please don't publish what you want to publish. That's disrespectful or that's like nothing. And they've kind
[04:50:56]  of censored themselves to try and give the react team the best, uh, you know, benefit the doubt in the best way. Like you saw Tanner even today when he
[04:51:02]  was like, look, I've talked to these guys. They're trying, they're doing good things, you know, whatever. I would love, love, love
[04:51:08]  if Mark Erickson posted his thing, because even if they don't post it in the given time, there is this under the surface anger. You can feel it.
[04:51:18]  There's like a atmosphere. And as I said, I, I'm not putting my own words out there. I asked the question, maybe poked it out a bit
[04:51:28]  because you can sense it. I don't need to write thing. I personally obviously was a little bit annoyed with the direction of react because it changed to what it is
[04:51:38] , but it's not, I think it's, it is largely the react ecosystem. Yes. Sure. There's some people in the view side of each side are just
[04:51:46]  like, I don't get it. Like especially a lot of multi-framework types who people have used different tools and they're just like, this is crazy, you
[04:51:51]  know, in terms of CRA beat thing. But on the other hand, there's a lot of frustration, even in the react ecosystem itself and people just don't get
[04:52:03]  it. So yeah, this was the tweet I was talking about. Definitely. So where was I? I was going to look at this article. I asked him,
[04:52:20]  he's like, very likely not going to post. No, I don't think so. And it's, it's a shame. It's good because what he can
[04:52:26]  say could be damaging. Maybe he has to look at what's most constructive, but a certain point, not enough is enough. You know what I mean? And we're
[04:52:38]  not at that point and the team's working on this, but like, I think the funny thing is he doesn't have to post it for, for everyone to know what
[04:52:45]  it says. I don't think it's, I, I think you can feel it. So it's fine. Not everyone is in close enough proximity to feel it
[04:52:59] . So then, you know, generally it's a good thing. And if the react team is addressing it and that, but he wrote pages and pages, like I've
[04:53:08]  never written an article even close to half that long. It would take me more than one whole stream to cover it. This is immense amount of time. It took him
[04:53:21]  weeks to write this. The problem is sometimes you have to see the whole picture as a single narrative to understand how deep this runs. Like, it's not a series
[04:53:43]  of distinct events that have blown up and been forgotten on Twitter for a week. So like, yeah, I, I just said, I, I'm, I'm
[04:54:00]  sure he won't post it, but it's like, it was, it's funny. Cause I'd, I'd written something myself, but then I, I'm
[04:54:11]  not in a place to say anything. It's not my place. And then I read his and I just like, okay, I'm just going to put, put
[04:54:17]  this down. Nothing I said could compare to just the way that it wrote and the way that it felt and seeing the progression. Yeah. And I'm, I'm sorry
[04:54:33] . I know I'm talking about something you guys will never read, but. Yeah. It's real. This tweet made no sense. Yeah. Like people in my
[04:54:51]  room are suddenly not react. Yeah. Yeah. Beast mode. Definitely Jack. I'm just finishing up with a few things that happened this weekend, but we've, we
[04:55:05] 've almost gone full circle. Oh, sorry. Did you guys want me to, uh, dev already. This one, the Ryan Florence tweet, I can, I
[04:55:19]  can share it. Sorry. Give me two seconds. No, I was saying the Mark Erickson. Sorry. This is the Ryan Florence tweet, but I meant the
[04:55:30]  Mark Erickson article that he wrote about, um, the, you know, his friction or challenges he's been happening with communication and react. And it reads like
[04:55:42]  a, uh, several year, probably like five or six year narrative of the whole progression of what it's like to be a library author in the react ecosystem. And
[04:55:49] , and just like the whole progression and the overall, like where it leaves them now and today. Yeah. It will, it will, it will probably never be,
[04:56:02]  it will probably never be, uh, released is the thing. He, I've read it. A few other people he shared it with read it because he wanted feedback.
[04:56:14]  It's, it's amazing, but it will, as I said, he, to give react team proper credit, you know, space to do fixes and not cause,
[04:56:23]  you know, unnecessary destruction. He will probably never post it anyway, uh, where are we going? Uh, yeah, right. Let's check this article out.
[04:56:36]  React solid H2MX part two, despite being pulled into back and work, I've continued following the evolution of the three frames. So last time, I think this
[04:56:44]  isn't relevant. When he posted, he basically said, react, how far can component components go solid? How far primitives can go H2MX? How far
[04:56:53]  can hypermedia go right? Three very distinctive approaches, right? So we returned three years later and he said, or a year later, sorry. And he says
[04:57:00] , react cell paragraph shift. With the full vacuum index and Vercel, React has finally realized the original full stack vision. Next.js offers use cache directives as
[04:57:07]  a support proposal caching on server. Vercel offers a fluid compute that finished with rendered UI serverless environments. Addition primary first class supports hosting. Might remark
[04:57:17]  the culmination for cell's multi-year support for the future React, making the full-stack React architecture and Next app truly compelling option for building real-world apps
[04:57:24] . Developers can now take full advantage of the promises. And yet, we haven't seen many praise or success stories for adopting new server first version. After over two
[04:57:31]  years of adopting the app for our next remains only mainstream React framework to support RCs. Several witnessing an ongoing tension between React's server first version and React community at large.
[04:57:39]  The controversial initial 19 RC release last June. To more recent backlashing and sunsetting Create React app. Official blog posts in February. Reluctance towards VE
[04:57:49] AT. React team responded positively to community feedback in both cases. But the growing sense of mismatch was palpable. We know React community is largely experienced and renewed. Appreci
[04:57:57] ated for client first approach. Credit going to React Router and Remix. And HandStack. Which have both been perfectly established patterns that innovation support client first apps.
[04:58:07]  SSR with and without streaming. Nested routes. Route level parallel. Type safe. Navigation. Streamline. Server management. Blah blah blah. These patterns have
[04:58:14]  proven to effectively tackle the original limitation of client first React apps. And there is a promise to React compiler currently in beta that will help client first run faster. Is it
[04:58:22]  in beta? Or has it been released? I don't know. You can use it now and it's pretty sweet. It's a paradigm shift at first. Server for
[04:58:28]  path to React has become just another tool in the toolbox. Seenly not particularly popular at the moment. Many are still choosing the familiar path, but who can blame them
[04:58:35] ? Solid two steps ahead. Solid contingent inspired broader landscape in 2022. React signals appeared in 2023. We saw the reveal of Vapor mode and view as Rails ruins.
[04:58:46]  We saw the preview of Angular 16. And stable Angular 17 signals in 2024. Svelte 5 ruins went live. While Angular continued to iterate on signal-based iterations.
[04:58:55]  This momentum reached a new height with the interrupts of CC39 proposal signals, which were revealed in April shortly, reached stage 1. Meanwhile, Solid has not sat idly
[04:59:03]  by, waiting for everyone to catch up. After years of deep research, the shape of upgraded Solid reactivity has finally merged with Create Async. Signals won't need
[04:59:10]  special signature handling async values. Split effects, behavior predictable, holding async values, create projection, Solid reactivity will handle complex data structures more efficiently. We can
[04:59:19]  tell he was watching my last stream. Most importantly, all new primitives will work together to form a consistent reactive model. So get excited. While researching core reactivity
[04:59:29] , Solid also reached a big milestone in 2024. The release of Solid Start 1.0. Solid Start presents a uniquely modular incremental approach to building web framework where everything from SS
[04:59:39] R to server functions are totally optional, even the router. the backbone of most other frameworks is a matter of choice, which is cool because, sorry, I'm just
[04:59:47]  so excited. TanStack, router, Solid. There's already a Solid Start template for it. So just think. Just like Solid inspires money, the Doppsign
[04:59:54] al Solid Start is already making impact. Solid ecosystem, Tenor, TanStack, long-time collaborator, partner, crime, bringing Start velocity to React with Tan
[05:00:01] Stack Start. And between the two Start frameworks go much deeper, ranging in technology, Stack, and modular design, and the router is a separate component. Solid two
[05:00:12]  steps ahead. And then HTMLX finished software. An isolated event may be a simple coincidence, but repetition makes pattern. 2024 JavaScript rising stars, front-end category, HTML
[05:00:20] X added 16.8k GitHub stars to take the top spot, leading React by over 4k stars. On Hacker News, you can now find HTMLX in comments
[05:00:26]  on any popular posts about web development. While HTMLX is nowhere near React or other established options in terms of use, it proved to be more than just an internet meme.
[05:00:33]  No, HTMLX has become a proper meme and an idea infecting the minds of the web development community. Hypermedia is so back. So what's next for
[05:00:40]  HTMLX? Well, that's the neat part. Not so much. This is because HTMLX is a finished software. In the post to future HTMLX, the HTML
[05:00:46] X team states, people shouldn't feel pressured to upgrade HTMLX over time unless there are specific bugs they want to fix. They should feel comfortable with HTMLX that they write
[05:00:52]  in 2025 will look very similar to the HTMLX they write in 2035 and beyond. That's not to say HTMLX's quest for hypermedia resistance is over.
[05:00:59]  Now it has captured everyone's attention. HTMLX means to propel hypermedia forward by following jQuery's footsteps. A library's footsteps so that its core features
[05:01:08]  got incorporated into the JavaScript standard. At the heart of this suicide mission are the Tribe Tech proposals, which consist of three proposals to evolve HTML standards to support put, patch,
[05:01:18]  and delete on a form, a love button to issue HTML requests, and support partial replacement. In addition, HTTPX continues to promote hypermedia-oriented approaches and
[05:01:28]  keep research and discourse alive. In addition to famous online social media presence, this effort includes presenting conferences, appearing interviews, podcasts, publishing academic journals, and creating another project showc
[05:01:38] asing stripped-down version of generalized hypermedia controls. I wrote the original article out of deep appreciation for the relentless pursuit of clear and unique vision. I'm happy
[05:01:46]  to see that React contains a betting on components solid on performance and HTMLX on hypermedia. Regardless where those paths lead in the future, I'm confident React solid and
[05:01:52]  HTMLX are pushing the web forward each in their own way. Very nice. Yeah. Yeah, I guess less is new this year. I mean, that's not
[05:02:06]  true. I mean, you saw the new stuff with React, new stuff with Solid, HTMLX kind of standing on. It's just, it's an interesting how different
[05:02:13]  the paths have been since the beginning of our article, and I guess that makes it worthwhile. But this feels like a year-in-review article more than anything.
[05:02:21]  Definitely, I enjoyed the read. It's such a grim take for people with an innovative mindset, but treasure for people who want to write something right now and never visit
[05:02:36]  it again. Yeah. Yeah, it's just kind of funny. Things naturally change. But it's okay if things don't change for a long time. Yeah,
[05:03:00]  yeah, yeah, yeah, yeah, yeah, no, definitely, definitely, Jack, the whole thing that's happened has made real concrete improvements, things that are, that
[05:03:13]  are, that are, like, will improve React and help with the marketing. As we, everyone agreed on stream earlier that it was really a marketing thing, kind of mism
[05:03:26] atch. So, yeah, let me see here. That was that. Did I actually, like, post anything else this week? Okay, I guess we're just
[05:03:39]  on to solid news. So, not much to talk about, right? Last week, showed a bunch of the cool examples. What do we got here? What,
[05:03:49]  and then, obviously, the 2.0, beginning the journey stuff. New drag and drop library for solid. Always like seeing new libraries. So, I give that a
[05:04:00]  shout out. But the big one, which was our announcement for today, that I'm going to say again, is tan stack router for solid. Absolutely game-changing
[05:04:08]  to have that kind of TypeScript thing. Now, React is not the only one with that power. And as, as I said, they already have a solid start template
[05:04:16]  with it all working. So, this double win, because not only we have this capability, we get to kind of show that promise of router agnostic. Obviously
[05:04:27] , there's certain features that I'm sure aren't implemented in tan stack router that we'd have to work on to actually get the solid start integration to be, like,
[05:04:35]  as good as the native one. But, like, the core philosophy is holding up strongly here. So, I'm very stoked about this. This is what I always had
[05:04:46]  in mind, that we would have a different router, and we could all just work together. The amount of neighbors, I believe, is less than the group who wants
[05:05:06]  to stay the same for a decade. Yeah, I think so. I mean, it's pretty evident, right? Because I'm not even worried about a decade. What
[05:05:16]  I start getting worried about is, like, when it goes past a decade, you're just, like, something's got to move forward, you know, even an inch
[05:05:23] , you know? It's like, okay, maybe for something new or something small, I'm going to do something different. The sad part is that after, you
[05:05:31]  know, 10, 12, 15 years of React, people aren't like, okay, maybe there's something else out there, you know? I called it tan stack start
[05:05:43]  solid for playing solid on top, so it's, yeah, I mean, we are working very closely together since these things happen. The point of HTML is that HTML
[05:05:55]  can change and improve the author of HTML. I just, you know. When do you think solid router will be, it's a router app template solid. I mean
[05:06:10] , I don't know the state I wasn't working on it, but if it's just a VT router template, then I think it's, like, you're
[05:06:19]  talking about just using tan stack solid router with a VT template. I think we're not at all far off that at all because, like, literally, I,
[05:06:33]  there's a, there's one with solid query that they already have for template and they made a solid start template. So I don't, I imagine it could be
[05:06:40]  done at any time. Yeah. It should be fine to do today. Yeah. I haven't tested it from a bug standpoint, but yeah. Yeah. Um, I
[05:06:48]  wasn't involved, but they passed all 400 to test. So good for them. Burke and Brindley probably have the real answer. Yeah, definitely. Um,
[05:06:58]  but yeah, yeah, no, I, I, I love the fact that it's just a matter of like, it's going to like, this is, this might
[05:07:08]  be, this, this create TS router thing, forget tan stack start for a moment. Something like this might be the first realization of what, um, I, how
[05:07:20]  I see the future working because when it becomes an app, an option where you're just like solid react and you know, you get the experience you're familiar with that you
[05:07:32]  expect. Um, like it's, we're, we're just that much closer. So yeah, I'm, I'm, I'd be very excited to see that
[05:07:40]  Jack. Anyway, um, I think, I think that's it. I think I don't have to stream for six hours. Um, I think I can eat
[05:07:54]  dinner, um, at a reasonable time. I think you guys can all go for, uh, for a good weekend. Um, so I'm going to probably just call
[05:08:06]  it here and, uh, yeah, I'm just trying to think if there's a, if there's anything else, but I do not think so. Um,
[05:08:18]  so yeah, let's, yeah, let's just, uh, let's just call it a day. Um, yeah. All right. Everyone have a good, uh
[05:08:32] , good weekend and, uh, till next time.